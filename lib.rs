# ! [feature (abi_msp430_interrupt)]
# ! [doc = "Peripheral access API for MSP430FR2433 microcontrollers (generated using svd2rust v0.24.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.24.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (const_err)]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [cfg (feature = "rt")]
pub use msp430_rt :: interrupt ; # [cfg (feature = "rt")]
pub use self :: Interrupt as interrupt ; # [allow (unused_imports)]
use generic :: * ; # [doc = "Common register and bit access and modify traits"]
pub mod generic ; # [cfg (feature = "rt")]
extern "msp430-interrupt" { fn PORT2 () ; fn PORT1 () ; fn ADC () ; fn USCI_B0 () ; fn USCI_A1 () ; fn USCI_A0 () ; fn WDT () ; fn RTC () ; fn TIMER3_A1 () ; fn TIMER3_A0 () ; fn TIMER2_A1 () ; fn TIMER2_A0 () ; fn TIMER1_A1 () ; fn TIMER1_A0 () ; fn TIMER0_A1 () ; fn TIMER0_A0 () ; fn UNMI () ; fn SYSNMI () ; } # [doc (hidden)]
pub union Vector { _handler : unsafe extern "msp430-interrupt" fn () , _reserved : u16 , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [link_section = ".vector_table.interrupts"]
# [no_mangle]
# [used]
pub static __INTERRUPTS : [Vector ; 59]
= [Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : PORT2 } , Vector { _handler : PORT1 } , Vector { _handler : ADC } , Vector { _handler : USCI_B0 } , Vector { _handler : USCI_A1 } , Vector { _handler : USCI_A0 } , Vector { _handler : WDT } , Vector { _handler : RTC } , Vector { _handler : TIMER3_A1 } , Vector { _handler : TIMER3_A0 } , Vector { _handler : TIMER2_A1 } , Vector { _handler : TIMER2_A0 } , Vector { _handler : TIMER1_A1 } , Vector { _handler : TIMER1_A0 } , Vector { _handler : TIMER0_A1 } , Vector { _handler : TIMER0_A0 } , Vector { _handler : UNMI } , Vector { _handler : SYSNMI } ,]
; # [doc = r"Enumeration of all the interrupts. This enum is seldom used in application or library crates. It is present primarily for documenting the device's implemented interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "41 - 0xFFDA Port 2"]
PORT2 = 41 , # [doc = "42 - 0xFFDC Port 1"]
PORT1 = 42 , # [doc = "43 - 0xFFDE ADC"]
ADC = 43 , # [doc = "44 - 0xFFE0 USCI B0 Receive/Transmit"]
USCI_B0 = 44 , # [doc = "45 - 0xFFE2 USCI A1 Receive/Transmit"]
USCI_A1 = 45 , # [doc = "46 - 0xFFE4 USCI A0 Receive/Transmit"]
USCI_A0 = 46 , # [doc = "47 - 0xFFE6 Watchdog Timer"]
WDT = 47 , # [doc = "48 - 0xFFE8 RTC"]
RTC = 48 , # [doc = "49 - 0xFFEA Timer3_A2 CC1, TA"]
TIMER3_A1 = 49 , # [doc = "50 - 0xFFEC Timer3_A2 CC0"]
TIMER3_A0 = 50 , # [doc = "51 - 0xFFEE Timer2_A2 CC1, TA"]
TIMER2_A1 = 51 , # [doc = "52 - 0xFFF0 Timer2_A2 CC0"]
TIMER2_A0 = 52 , # [doc = "53 - 0xFFF2 Timer1_A3 CC1-2, TA"]
TIMER1_A1 = 53 , # [doc = "54 - 0xFFF4 Timer1_A3 CC0"]
TIMER1_A0 = 54 , # [doc = "55 - 0xFFF6 Timer0_A3 CC1-2, TA"]
TIMER0_A1 = 55 , # [doc = "56 - 0xFFE8 Timer0_A3 CC0"]
TIMER0_A0 = 56 , # [doc = "57 - 0xFFFA User Non-maskable"]
UNMI = 57 , # [doc = "58 - 0xFFFC System Non-maskable"]
SYSNMI = 58 , } # [doc = "Port 1/2"]
pub struct PORT_1_2 { _marker : PhantomData < * const () > } unsafe impl Send for PORT_1_2 { } impl PORT_1_2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const port_1_2 :: RegisterBlock = 0x0200 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const port_1_2 :: RegisterBlock { Self :: PTR } } impl Deref for PORT_1_2 { type Target = port_1_2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORT_1_2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORT_1_2") . finish () } } # [doc = "Port 1/2"]
pub mod port_1_2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port 1 Input"]
pub p1in : crate :: Reg < p1in :: P1IN_SPEC > , # [doc = "0x01 - Port 2 Input"]
pub p2in : crate :: Reg < p2in :: P2IN_SPEC > , # [doc = "0x02 - Port 1 Output"]
pub p1out : crate :: Reg < p1out :: P1OUT_SPEC > , # [doc = "0x03 - Port 2 Output"]
pub p2out : crate :: Reg < p2out :: P2OUT_SPEC > , # [doc = "0x04 - Port 1 Direction"]
pub p1dir : crate :: Reg < p1dir :: P1DIR_SPEC > , # [doc = "0x05 - Port 2 Direction"]
pub p2dir : crate :: Reg < p2dir :: P2DIR_SPEC > , # [doc = "0x06 - Port 1 Resistor Enable"]
pub p1ren : crate :: Reg < p1ren :: P1REN_SPEC > , # [doc = "0x07 - Port 2 Resistor Enable"]
pub p2ren : crate :: Reg < p2ren :: P2REN_SPEC > , _reserved8 : [u8 ; 0x02]
, # [doc = "0x0a - Port 1 Selection 0"]
pub p1sel0 : crate :: Reg < p1sel0 :: P1SEL0_SPEC > , # [doc = "0x0b - Port 2 Selection 0"]
pub p2sel0 : crate :: Reg < p2sel0 :: P2SEL0_SPEC > , # [doc = "0x0c - Port 1 Selection 1"]
pub p1sel1 : crate :: Reg < p1sel1 :: P1SEL1_SPEC > , # [doc = "0x0d - Port 2 Selection 1"]
pub p2sel1 : crate :: Reg < p2sel1 :: P2SEL1_SPEC > , # [doc = "0x0e - Port 1 Interrupt Vector Word"]
pub p1iv : crate :: Reg < p1iv :: P1IV_SPEC > , _reserved13 : [u8 ; 0x08]
, # [doc = "0x18 - Port 1 Interrupt Edge Select"]
pub p1ies : crate :: Reg < p1ies :: P1IES_SPEC > , # [doc = "0x19 - Port 2 Interrupt Edge Select"]
pub p2ies : crate :: Reg < p2ies :: P2IES_SPEC > , # [doc = "0x1a - Port 1 Interrupt Enable"]
pub p1ie : crate :: Reg < p1ie :: P1IE_SPEC > , # [doc = "0x1b - Port 2 Interrupt Enable"]
pub p2ie : crate :: Reg < p2ie :: P2IE_SPEC > , # [doc = "0x1c - Port 1 Interrupt Flag"]
pub p1ifg : crate :: Reg < p1ifg :: P1IFG_SPEC > , # [doc = "0x1d - Port 2 Interrupt Flag"]
pub p2ifg : crate :: Reg < p2ifg :: P2IFG_SPEC > , # [doc = "0x1e - Port 2 Interrupt Vector Word"]
pub p2iv : crate :: Reg < p2iv :: P2IV_SPEC > , } # [doc = "P1IN register accessor: an alias for `Reg<P1IN_SPEC>`"]
pub type P1IN = crate :: Reg < p1in :: P1IN_SPEC > ; # [doc = "Port 1 Input"]
pub mod p1in { # [doc = "Register `P1IN` reader"]
pub struct R (crate :: R < P1IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1IN` writer"]
pub struct W (crate :: W < P1IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1IN0` reader - P1IN0"]
pub type P1IN0_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN0` writer - P1IN0"]
pub type P1IN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN1` reader - P1IN1"]
pub type P1IN1_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN1` writer - P1IN1"]
pub type P1IN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN2` reader - P1IN2"]
pub type P1IN2_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN2` writer - P1IN2"]
pub type P1IN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN3` reader - P1IN3"]
pub type P1IN3_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN3` writer - P1IN3"]
pub type P1IN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN4` reader - P1IN4"]
pub type P1IN4_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN4` writer - P1IN4"]
pub type P1IN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN5` reader - P1IN5"]
pub type P1IN5_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN5` writer - P1IN5"]
pub type P1IN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN6` reader - P1IN6"]
pub type P1IN6_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN6` writer - P1IN6"]
pub type P1IN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; # [doc = "Field `P1IN7` reader - P1IN7"]
pub type P1IN7_R = crate :: BitReader < bool > ; # [doc = "Field `P1IN7` writer - P1IN7"]
pub type P1IN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1IN0"]
# [inline (always)]
pub fn p1in0 (& self) -> P1IN0_R { P1IN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1IN1"]
# [inline (always)]
pub fn p1in1 (& self) -> P1IN1_R { P1IN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1IN2"]
# [inline (always)]
pub fn p1in2 (& self) -> P1IN2_R { P1IN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1IN3"]
# [inline (always)]
pub fn p1in3 (& self) -> P1IN3_R { P1IN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1IN4"]
# [inline (always)]
pub fn p1in4 (& self) -> P1IN4_R { P1IN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1IN5"]
# [inline (always)]
pub fn p1in5 (& self) -> P1IN5_R { P1IN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1IN6"]
# [inline (always)]
pub fn p1in6 (& self) -> P1IN6_R { P1IN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1IN7"]
# [inline (always)]
pub fn p1in7 (& self) -> P1IN7_R { P1IN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1IN0"]
# [inline (always)]
pub fn p1in0 (& mut self) -> P1IN0_W < 0 > { P1IN0_W :: new (self) } # [doc = "Bit 1 - P1IN1"]
# [inline (always)]
pub fn p1in1 (& mut self) -> P1IN1_W < 1 > { P1IN1_W :: new (self) } # [doc = "Bit 2 - P1IN2"]
# [inline (always)]
pub fn p1in2 (& mut self) -> P1IN2_W < 2 > { P1IN2_W :: new (self) } # [doc = "Bit 3 - P1IN3"]
# [inline (always)]
pub fn p1in3 (& mut self) -> P1IN3_W < 3 > { P1IN3_W :: new (self) } # [doc = "Bit 4 - P1IN4"]
# [inline (always)]
pub fn p1in4 (& mut self) -> P1IN4_W < 4 > { P1IN4_W :: new (self) } # [doc = "Bit 5 - P1IN5"]
# [inline (always)]
pub fn p1in5 (& mut self) -> P1IN5_W < 5 > { P1IN5_W :: new (self) } # [doc = "Bit 6 - P1IN6"]
# [inline (always)]
pub fn p1in6 (& mut self) -> P1IN6_W < 6 > { P1IN6_W :: new (self) } # [doc = "Bit 7 - P1IN7"]
# [inline (always)]
pub fn p1in7 (& mut self) -> P1IN7_W < 7 > { P1IN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1in](index.html) module"]
pub struct P1IN_SPEC ; impl crate :: RegisterSpec for P1IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1in::R](R) reader structure"]
impl crate :: Readable for P1IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1in::W](W) writer structure"]
impl crate :: Writable for P1IN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1IN to value 0"]
impl crate :: Resettable for P1IN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2IN register accessor: an alias for `Reg<P2IN_SPEC>`"]
pub type P2IN = crate :: Reg < p2in :: P2IN_SPEC > ; # [doc = "Port 2 Input"]
pub mod p2in { # [doc = "Register `P2IN` reader"]
pub struct R (crate :: R < P2IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2IN` writer"]
pub struct W (crate :: W < P2IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2IN0` reader - P2IN0"]
pub type P2IN0_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN0` writer - P2IN0"]
pub type P2IN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN1` reader - P2IN1"]
pub type P2IN1_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN1` writer - P2IN1"]
pub type P2IN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN2` reader - P2IN2"]
pub type P2IN2_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN2` writer - P2IN2"]
pub type P2IN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN3` reader - P2IN3"]
pub type P2IN3_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN3` writer - P2IN3"]
pub type P2IN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN4` reader - P2IN4"]
pub type P2IN4_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN4` writer - P2IN4"]
pub type P2IN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN5` reader - P2IN5"]
pub type P2IN5_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN5` writer - P2IN5"]
pub type P2IN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN6` reader - P2IN6"]
pub type P2IN6_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN6` writer - P2IN6"]
pub type P2IN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; # [doc = "Field `P2IN7` reader - P2IN7"]
pub type P2IN7_R = crate :: BitReader < bool > ; # [doc = "Field `P2IN7` writer - P2IN7"]
pub type P2IN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2IN0"]
# [inline (always)]
pub fn p2in0 (& self) -> P2IN0_R { P2IN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2IN1"]
# [inline (always)]
pub fn p2in1 (& self) -> P2IN1_R { P2IN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2IN2"]
# [inline (always)]
pub fn p2in2 (& self) -> P2IN2_R { P2IN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2IN3"]
# [inline (always)]
pub fn p2in3 (& self) -> P2IN3_R { P2IN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2IN4"]
# [inline (always)]
pub fn p2in4 (& self) -> P2IN4_R { P2IN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2IN5"]
# [inline (always)]
pub fn p2in5 (& self) -> P2IN5_R { P2IN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2IN6"]
# [inline (always)]
pub fn p2in6 (& self) -> P2IN6_R { P2IN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2IN7"]
# [inline (always)]
pub fn p2in7 (& self) -> P2IN7_R { P2IN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2IN0"]
# [inline (always)]
pub fn p2in0 (& mut self) -> P2IN0_W < 0 > { P2IN0_W :: new (self) } # [doc = "Bit 1 - P2IN1"]
# [inline (always)]
pub fn p2in1 (& mut self) -> P2IN1_W < 1 > { P2IN1_W :: new (self) } # [doc = "Bit 2 - P2IN2"]
# [inline (always)]
pub fn p2in2 (& mut self) -> P2IN2_W < 2 > { P2IN2_W :: new (self) } # [doc = "Bit 3 - P2IN3"]
# [inline (always)]
pub fn p2in3 (& mut self) -> P2IN3_W < 3 > { P2IN3_W :: new (self) } # [doc = "Bit 4 - P2IN4"]
# [inline (always)]
pub fn p2in4 (& mut self) -> P2IN4_W < 4 > { P2IN4_W :: new (self) } # [doc = "Bit 5 - P2IN5"]
# [inline (always)]
pub fn p2in5 (& mut self) -> P2IN5_W < 5 > { P2IN5_W :: new (self) } # [doc = "Bit 6 - P2IN6"]
# [inline (always)]
pub fn p2in6 (& mut self) -> P2IN6_W < 6 > { P2IN6_W :: new (self) } # [doc = "Bit 7 - P2IN7"]
# [inline (always)]
pub fn p2in7 (& mut self) -> P2IN7_W < 7 > { P2IN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2in](index.html) module"]
pub struct P2IN_SPEC ; impl crate :: RegisterSpec for P2IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2in::R](R) reader structure"]
impl crate :: Readable for P2IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2in::W](W) writer structure"]
impl crate :: Writable for P2IN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2IN to value 0"]
impl crate :: Resettable for P2IN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1OUT register accessor: an alias for `Reg<P1OUT_SPEC>`"]
pub type P1OUT = crate :: Reg < p1out :: P1OUT_SPEC > ; # [doc = "Port 1 Output"]
pub mod p1out { # [doc = "Register `P1OUT` reader"]
pub struct R (crate :: R < P1OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1OUT` writer"]
pub struct W (crate :: W < P1OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1OUT0` reader - P1OUT0"]
pub type P1OUT0_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT0` writer - P1OUT0"]
pub type P1OUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT1` reader - P1OUT1"]
pub type P1OUT1_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT1` writer - P1OUT1"]
pub type P1OUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT2` reader - P1OUT2"]
pub type P1OUT2_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT2` writer - P1OUT2"]
pub type P1OUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT3` reader - P1OUT3"]
pub type P1OUT3_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT3` writer - P1OUT3"]
pub type P1OUT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT4` reader - P1OUT4"]
pub type P1OUT4_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT4` writer - P1OUT4"]
pub type P1OUT4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT5` reader - P1OUT5"]
pub type P1OUT5_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT5` writer - P1OUT5"]
pub type P1OUT5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT6` reader - P1OUT6"]
pub type P1OUT6_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT6` writer - P1OUT6"]
pub type P1OUT6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; # [doc = "Field `P1OUT7` reader - P1OUT7"]
pub type P1OUT7_R = crate :: BitReader < bool > ; # [doc = "Field `P1OUT7` writer - P1OUT7"]
pub type P1OUT7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1OUT0"]
# [inline (always)]
pub fn p1out0 (& self) -> P1OUT0_R { P1OUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1OUT1"]
# [inline (always)]
pub fn p1out1 (& self) -> P1OUT1_R { P1OUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1OUT2"]
# [inline (always)]
pub fn p1out2 (& self) -> P1OUT2_R { P1OUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1OUT3"]
# [inline (always)]
pub fn p1out3 (& self) -> P1OUT3_R { P1OUT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1OUT4"]
# [inline (always)]
pub fn p1out4 (& self) -> P1OUT4_R { P1OUT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1OUT5"]
# [inline (always)]
pub fn p1out5 (& self) -> P1OUT5_R { P1OUT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1OUT6"]
# [inline (always)]
pub fn p1out6 (& self) -> P1OUT6_R { P1OUT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1OUT7"]
# [inline (always)]
pub fn p1out7 (& self) -> P1OUT7_R { P1OUT7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1OUT0"]
# [inline (always)]
pub fn p1out0 (& mut self) -> P1OUT0_W < 0 > { P1OUT0_W :: new (self) } # [doc = "Bit 1 - P1OUT1"]
# [inline (always)]
pub fn p1out1 (& mut self) -> P1OUT1_W < 1 > { P1OUT1_W :: new (self) } # [doc = "Bit 2 - P1OUT2"]
# [inline (always)]
pub fn p1out2 (& mut self) -> P1OUT2_W < 2 > { P1OUT2_W :: new (self) } # [doc = "Bit 3 - P1OUT3"]
# [inline (always)]
pub fn p1out3 (& mut self) -> P1OUT3_W < 3 > { P1OUT3_W :: new (self) } # [doc = "Bit 4 - P1OUT4"]
# [inline (always)]
pub fn p1out4 (& mut self) -> P1OUT4_W < 4 > { P1OUT4_W :: new (self) } # [doc = "Bit 5 - P1OUT5"]
# [inline (always)]
pub fn p1out5 (& mut self) -> P1OUT5_W < 5 > { P1OUT5_W :: new (self) } # [doc = "Bit 6 - P1OUT6"]
# [inline (always)]
pub fn p1out6 (& mut self) -> P1OUT6_W < 6 > { P1OUT6_W :: new (self) } # [doc = "Bit 7 - P1OUT7"]
# [inline (always)]
pub fn p1out7 (& mut self) -> P1OUT7_W < 7 > { P1OUT7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1out](index.html) module"]
pub struct P1OUT_SPEC ; impl crate :: RegisterSpec for P1OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1out::R](R) reader structure"]
impl crate :: Readable for P1OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1out::W](W) writer structure"]
impl crate :: Writable for P1OUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1OUT to value 0"]
impl crate :: Resettable for P1OUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2OUT register accessor: an alias for `Reg<P2OUT_SPEC>`"]
pub type P2OUT = crate :: Reg < p2out :: P2OUT_SPEC > ; # [doc = "Port 2 Output"]
pub mod p2out { # [doc = "Register `P2OUT` reader"]
pub struct R (crate :: R < P2OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2OUT` writer"]
pub struct W (crate :: W < P2OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2OUT0` reader - P2OUT0"]
pub type P2OUT0_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT0` writer - P2OUT0"]
pub type P2OUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT1` reader - P2OUT1"]
pub type P2OUT1_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT1` writer - P2OUT1"]
pub type P2OUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT2` reader - P2OUT2"]
pub type P2OUT2_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT2` writer - P2OUT2"]
pub type P2OUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT3` reader - P2OUT3"]
pub type P2OUT3_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT3` writer - P2OUT3"]
pub type P2OUT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT4` reader - P2OUT4"]
pub type P2OUT4_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT4` writer - P2OUT4"]
pub type P2OUT4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT5` reader - P2OUT5"]
pub type P2OUT5_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT5` writer - P2OUT5"]
pub type P2OUT5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT6` reader - P2OUT6"]
pub type P2OUT6_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT6` writer - P2OUT6"]
pub type P2OUT6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; # [doc = "Field `P2OUT7` reader - P2OUT7"]
pub type P2OUT7_R = crate :: BitReader < bool > ; # [doc = "Field `P2OUT7` writer - P2OUT7"]
pub type P2OUT7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2OUT0"]
# [inline (always)]
pub fn p2out0 (& self) -> P2OUT0_R { P2OUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2OUT1"]
# [inline (always)]
pub fn p2out1 (& self) -> P2OUT1_R { P2OUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2OUT2"]
# [inline (always)]
pub fn p2out2 (& self) -> P2OUT2_R { P2OUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2OUT3"]
# [inline (always)]
pub fn p2out3 (& self) -> P2OUT3_R { P2OUT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2OUT4"]
# [inline (always)]
pub fn p2out4 (& self) -> P2OUT4_R { P2OUT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2OUT5"]
# [inline (always)]
pub fn p2out5 (& self) -> P2OUT5_R { P2OUT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2OUT6"]
# [inline (always)]
pub fn p2out6 (& self) -> P2OUT6_R { P2OUT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2OUT7"]
# [inline (always)]
pub fn p2out7 (& self) -> P2OUT7_R { P2OUT7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2OUT0"]
# [inline (always)]
pub fn p2out0 (& mut self) -> P2OUT0_W < 0 > { P2OUT0_W :: new (self) } # [doc = "Bit 1 - P2OUT1"]
# [inline (always)]
pub fn p2out1 (& mut self) -> P2OUT1_W < 1 > { P2OUT1_W :: new (self) } # [doc = "Bit 2 - P2OUT2"]
# [inline (always)]
pub fn p2out2 (& mut self) -> P2OUT2_W < 2 > { P2OUT2_W :: new (self) } # [doc = "Bit 3 - P2OUT3"]
# [inline (always)]
pub fn p2out3 (& mut self) -> P2OUT3_W < 3 > { P2OUT3_W :: new (self) } # [doc = "Bit 4 - P2OUT4"]
# [inline (always)]
pub fn p2out4 (& mut self) -> P2OUT4_W < 4 > { P2OUT4_W :: new (self) } # [doc = "Bit 5 - P2OUT5"]
# [inline (always)]
pub fn p2out5 (& mut self) -> P2OUT5_W < 5 > { P2OUT5_W :: new (self) } # [doc = "Bit 6 - P2OUT6"]
# [inline (always)]
pub fn p2out6 (& mut self) -> P2OUT6_W < 6 > { P2OUT6_W :: new (self) } # [doc = "Bit 7 - P2OUT7"]
# [inline (always)]
pub fn p2out7 (& mut self) -> P2OUT7_W < 7 > { P2OUT7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2out](index.html) module"]
pub struct P2OUT_SPEC ; impl crate :: RegisterSpec for P2OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2out::R](R) reader structure"]
impl crate :: Readable for P2OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2out::W](W) writer structure"]
impl crate :: Writable for P2OUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2OUT to value 0"]
impl crate :: Resettable for P2OUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1DIR register accessor: an alias for `Reg<P1DIR_SPEC>`"]
pub type P1DIR = crate :: Reg < p1dir :: P1DIR_SPEC > ; # [doc = "Port 1 Direction"]
pub mod p1dir { # [doc = "Register `P1DIR` reader"]
pub struct R (crate :: R < P1DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1DIR` writer"]
pub struct W (crate :: W < P1DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1DIR0` reader - P1DIR0"]
pub type P1DIR0_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR0` writer - P1DIR0"]
pub type P1DIR0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR1` reader - P1DIR1"]
pub type P1DIR1_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR1` writer - P1DIR1"]
pub type P1DIR1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR2` reader - P1DIR2"]
pub type P1DIR2_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR2` writer - P1DIR2"]
pub type P1DIR2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR3` reader - P1DIR3"]
pub type P1DIR3_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR3` writer - P1DIR3"]
pub type P1DIR3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR4` reader - P1DIR4"]
pub type P1DIR4_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR4` writer - P1DIR4"]
pub type P1DIR4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR5` reader - P1DIR5"]
pub type P1DIR5_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR5` writer - P1DIR5"]
pub type P1DIR5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR6` reader - P1DIR6"]
pub type P1DIR6_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR6` writer - P1DIR6"]
pub type P1DIR6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; # [doc = "Field `P1DIR7` reader - P1DIR7"]
pub type P1DIR7_R = crate :: BitReader < bool > ; # [doc = "Field `P1DIR7` writer - P1DIR7"]
pub type P1DIR7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1DIR0"]
# [inline (always)]
pub fn p1dir0 (& self) -> P1DIR0_R { P1DIR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1DIR1"]
# [inline (always)]
pub fn p1dir1 (& self) -> P1DIR1_R { P1DIR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1DIR2"]
# [inline (always)]
pub fn p1dir2 (& self) -> P1DIR2_R { P1DIR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1DIR3"]
# [inline (always)]
pub fn p1dir3 (& self) -> P1DIR3_R { P1DIR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1DIR4"]
# [inline (always)]
pub fn p1dir4 (& self) -> P1DIR4_R { P1DIR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1DIR5"]
# [inline (always)]
pub fn p1dir5 (& self) -> P1DIR5_R { P1DIR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1DIR6"]
# [inline (always)]
pub fn p1dir6 (& self) -> P1DIR6_R { P1DIR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1DIR7"]
# [inline (always)]
pub fn p1dir7 (& self) -> P1DIR7_R { P1DIR7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1DIR0"]
# [inline (always)]
pub fn p1dir0 (& mut self) -> P1DIR0_W < 0 > { P1DIR0_W :: new (self) } # [doc = "Bit 1 - P1DIR1"]
# [inline (always)]
pub fn p1dir1 (& mut self) -> P1DIR1_W < 1 > { P1DIR1_W :: new (self) } # [doc = "Bit 2 - P1DIR2"]
# [inline (always)]
pub fn p1dir2 (& mut self) -> P1DIR2_W < 2 > { P1DIR2_W :: new (self) } # [doc = "Bit 3 - P1DIR3"]
# [inline (always)]
pub fn p1dir3 (& mut self) -> P1DIR3_W < 3 > { P1DIR3_W :: new (self) } # [doc = "Bit 4 - P1DIR4"]
# [inline (always)]
pub fn p1dir4 (& mut self) -> P1DIR4_W < 4 > { P1DIR4_W :: new (self) } # [doc = "Bit 5 - P1DIR5"]
# [inline (always)]
pub fn p1dir5 (& mut self) -> P1DIR5_W < 5 > { P1DIR5_W :: new (self) } # [doc = "Bit 6 - P1DIR6"]
# [inline (always)]
pub fn p1dir6 (& mut self) -> P1DIR6_W < 6 > { P1DIR6_W :: new (self) } # [doc = "Bit 7 - P1DIR7"]
# [inline (always)]
pub fn p1dir7 (& mut self) -> P1DIR7_W < 7 > { P1DIR7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1dir](index.html) module"]
pub struct P1DIR_SPEC ; impl crate :: RegisterSpec for P1DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1dir::R](R) reader structure"]
impl crate :: Readable for P1DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1dir::W](W) writer structure"]
impl crate :: Writable for P1DIR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1DIR to value 0"]
impl crate :: Resettable for P1DIR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2DIR register accessor: an alias for `Reg<P2DIR_SPEC>`"]
pub type P2DIR = crate :: Reg < p2dir :: P2DIR_SPEC > ; # [doc = "Port 2 Direction"]
pub mod p2dir { # [doc = "Register `P2DIR` reader"]
pub struct R (crate :: R < P2DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2DIR` writer"]
pub struct W (crate :: W < P2DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2DIR0` reader - P2DIR0"]
pub type P2DIR0_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR0` writer - P2DIR0"]
pub type P2DIR0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR1` reader - P2DIR1"]
pub type P2DIR1_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR1` writer - P2DIR1"]
pub type P2DIR1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR2` reader - P2DIR2"]
pub type P2DIR2_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR2` writer - P2DIR2"]
pub type P2DIR2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR3` reader - P2DIR3"]
pub type P2DIR3_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR3` writer - P2DIR3"]
pub type P2DIR3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR4` reader - P2DIR4"]
pub type P2DIR4_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR4` writer - P2DIR4"]
pub type P2DIR4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR5` reader - P2DIR5"]
pub type P2DIR5_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR5` writer - P2DIR5"]
pub type P2DIR5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR6` reader - P2DIR6"]
pub type P2DIR6_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR6` writer - P2DIR6"]
pub type P2DIR6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; # [doc = "Field `P2DIR7` reader - P2DIR7"]
pub type P2DIR7_R = crate :: BitReader < bool > ; # [doc = "Field `P2DIR7` writer - P2DIR7"]
pub type P2DIR7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2DIR0"]
# [inline (always)]
pub fn p2dir0 (& self) -> P2DIR0_R { P2DIR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2DIR1"]
# [inline (always)]
pub fn p2dir1 (& self) -> P2DIR1_R { P2DIR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2DIR2"]
# [inline (always)]
pub fn p2dir2 (& self) -> P2DIR2_R { P2DIR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2DIR3"]
# [inline (always)]
pub fn p2dir3 (& self) -> P2DIR3_R { P2DIR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2DIR4"]
# [inline (always)]
pub fn p2dir4 (& self) -> P2DIR4_R { P2DIR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2DIR5"]
# [inline (always)]
pub fn p2dir5 (& self) -> P2DIR5_R { P2DIR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2DIR6"]
# [inline (always)]
pub fn p2dir6 (& self) -> P2DIR6_R { P2DIR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2DIR7"]
# [inline (always)]
pub fn p2dir7 (& self) -> P2DIR7_R { P2DIR7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2DIR0"]
# [inline (always)]
pub fn p2dir0 (& mut self) -> P2DIR0_W < 0 > { P2DIR0_W :: new (self) } # [doc = "Bit 1 - P2DIR1"]
# [inline (always)]
pub fn p2dir1 (& mut self) -> P2DIR1_W < 1 > { P2DIR1_W :: new (self) } # [doc = "Bit 2 - P2DIR2"]
# [inline (always)]
pub fn p2dir2 (& mut self) -> P2DIR2_W < 2 > { P2DIR2_W :: new (self) } # [doc = "Bit 3 - P2DIR3"]
# [inline (always)]
pub fn p2dir3 (& mut self) -> P2DIR3_W < 3 > { P2DIR3_W :: new (self) } # [doc = "Bit 4 - P2DIR4"]
# [inline (always)]
pub fn p2dir4 (& mut self) -> P2DIR4_W < 4 > { P2DIR4_W :: new (self) } # [doc = "Bit 5 - P2DIR5"]
# [inline (always)]
pub fn p2dir5 (& mut self) -> P2DIR5_W < 5 > { P2DIR5_W :: new (self) } # [doc = "Bit 6 - P2DIR6"]
# [inline (always)]
pub fn p2dir6 (& mut self) -> P2DIR6_W < 6 > { P2DIR6_W :: new (self) } # [doc = "Bit 7 - P2DIR7"]
# [inline (always)]
pub fn p2dir7 (& mut self) -> P2DIR7_W < 7 > { P2DIR7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2dir](index.html) module"]
pub struct P2DIR_SPEC ; impl crate :: RegisterSpec for P2DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2dir::R](R) reader structure"]
impl crate :: Readable for P2DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2dir::W](W) writer structure"]
impl crate :: Writable for P2DIR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2DIR to value 0"]
impl crate :: Resettable for P2DIR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1REN register accessor: an alias for `Reg<P1REN_SPEC>`"]
pub type P1REN = crate :: Reg < p1ren :: P1REN_SPEC > ; # [doc = "Port 1 Resistor Enable"]
pub mod p1ren { # [doc = "Register `P1REN` reader"]
pub struct R (crate :: R < P1REN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1REN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1REN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1REN` writer"]
pub struct W (crate :: W < P1REN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1REN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1REN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1REN0` reader - P1REN0"]
pub type P1REN0_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN0` writer - P1REN0"]
pub type P1REN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN1` reader - P1REN1"]
pub type P1REN1_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN1` writer - P1REN1"]
pub type P1REN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN2` reader - P1REN2"]
pub type P1REN2_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN2` writer - P1REN2"]
pub type P1REN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN3` reader - P1REN3"]
pub type P1REN3_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN3` writer - P1REN3"]
pub type P1REN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN4` reader - P1REN4"]
pub type P1REN4_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN4` writer - P1REN4"]
pub type P1REN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN5` reader - P1REN5"]
pub type P1REN5_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN5` writer - P1REN5"]
pub type P1REN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN6` reader - P1REN6"]
pub type P1REN6_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN6` writer - P1REN6"]
pub type P1REN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; # [doc = "Field `P1REN7` reader - P1REN7"]
pub type P1REN7_R = crate :: BitReader < bool > ; # [doc = "Field `P1REN7` writer - P1REN7"]
pub type P1REN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1REN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1REN0"]
# [inline (always)]
pub fn p1ren0 (& self) -> P1REN0_R { P1REN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1REN1"]
# [inline (always)]
pub fn p1ren1 (& self) -> P1REN1_R { P1REN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1REN2"]
# [inline (always)]
pub fn p1ren2 (& self) -> P1REN2_R { P1REN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1REN3"]
# [inline (always)]
pub fn p1ren3 (& self) -> P1REN3_R { P1REN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1REN4"]
# [inline (always)]
pub fn p1ren4 (& self) -> P1REN4_R { P1REN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1REN5"]
# [inline (always)]
pub fn p1ren5 (& self) -> P1REN5_R { P1REN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1REN6"]
# [inline (always)]
pub fn p1ren6 (& self) -> P1REN6_R { P1REN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1REN7"]
# [inline (always)]
pub fn p1ren7 (& self) -> P1REN7_R { P1REN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1REN0"]
# [inline (always)]
pub fn p1ren0 (& mut self) -> P1REN0_W < 0 > { P1REN0_W :: new (self) } # [doc = "Bit 1 - P1REN1"]
# [inline (always)]
pub fn p1ren1 (& mut self) -> P1REN1_W < 1 > { P1REN1_W :: new (self) } # [doc = "Bit 2 - P1REN2"]
# [inline (always)]
pub fn p1ren2 (& mut self) -> P1REN2_W < 2 > { P1REN2_W :: new (self) } # [doc = "Bit 3 - P1REN3"]
# [inline (always)]
pub fn p1ren3 (& mut self) -> P1REN3_W < 3 > { P1REN3_W :: new (self) } # [doc = "Bit 4 - P1REN4"]
# [inline (always)]
pub fn p1ren4 (& mut self) -> P1REN4_W < 4 > { P1REN4_W :: new (self) } # [doc = "Bit 5 - P1REN5"]
# [inline (always)]
pub fn p1ren5 (& mut self) -> P1REN5_W < 5 > { P1REN5_W :: new (self) } # [doc = "Bit 6 - P1REN6"]
# [inline (always)]
pub fn p1ren6 (& mut self) -> P1REN6_W < 6 > { P1REN6_W :: new (self) } # [doc = "Bit 7 - P1REN7"]
# [inline (always)]
pub fn p1ren7 (& mut self) -> P1REN7_W < 7 > { P1REN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ren](index.html) module"]
pub struct P1REN_SPEC ; impl crate :: RegisterSpec for P1REN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1ren::R](R) reader structure"]
impl crate :: Readable for P1REN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1ren::W](W) writer structure"]
impl crate :: Writable for P1REN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1REN to value 0"]
impl crate :: Resettable for P1REN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2REN register accessor: an alias for `Reg<P2REN_SPEC>`"]
pub type P2REN = crate :: Reg < p2ren :: P2REN_SPEC > ; # [doc = "Port 2 Resistor Enable"]
pub mod p2ren { # [doc = "Register `P2REN` reader"]
pub struct R (crate :: R < P2REN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2REN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2REN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2REN` writer"]
pub struct W (crate :: W < P2REN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2REN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2REN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2REN0` reader - P2REN0"]
pub type P2REN0_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN0` writer - P2REN0"]
pub type P2REN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN1` reader - P2REN1"]
pub type P2REN1_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN1` writer - P2REN1"]
pub type P2REN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN2` reader - P2REN2"]
pub type P2REN2_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN2` writer - P2REN2"]
pub type P2REN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN3` reader - P2REN3"]
pub type P2REN3_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN3` writer - P2REN3"]
pub type P2REN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN4` reader - P2REN4"]
pub type P2REN4_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN4` writer - P2REN4"]
pub type P2REN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN5` reader - P2REN5"]
pub type P2REN5_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN5` writer - P2REN5"]
pub type P2REN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN6` reader - P2REN6"]
pub type P2REN6_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN6` writer - P2REN6"]
pub type P2REN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; # [doc = "Field `P2REN7` reader - P2REN7"]
pub type P2REN7_R = crate :: BitReader < bool > ; # [doc = "Field `P2REN7` writer - P2REN7"]
pub type P2REN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2REN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2REN0"]
# [inline (always)]
pub fn p2ren0 (& self) -> P2REN0_R { P2REN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2REN1"]
# [inline (always)]
pub fn p2ren1 (& self) -> P2REN1_R { P2REN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2REN2"]
# [inline (always)]
pub fn p2ren2 (& self) -> P2REN2_R { P2REN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2REN3"]
# [inline (always)]
pub fn p2ren3 (& self) -> P2REN3_R { P2REN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2REN4"]
# [inline (always)]
pub fn p2ren4 (& self) -> P2REN4_R { P2REN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2REN5"]
# [inline (always)]
pub fn p2ren5 (& self) -> P2REN5_R { P2REN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2REN6"]
# [inline (always)]
pub fn p2ren6 (& self) -> P2REN6_R { P2REN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2REN7"]
# [inline (always)]
pub fn p2ren7 (& self) -> P2REN7_R { P2REN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2REN0"]
# [inline (always)]
pub fn p2ren0 (& mut self) -> P2REN0_W < 0 > { P2REN0_W :: new (self) } # [doc = "Bit 1 - P2REN1"]
# [inline (always)]
pub fn p2ren1 (& mut self) -> P2REN1_W < 1 > { P2REN1_W :: new (self) } # [doc = "Bit 2 - P2REN2"]
# [inline (always)]
pub fn p2ren2 (& mut self) -> P2REN2_W < 2 > { P2REN2_W :: new (self) } # [doc = "Bit 3 - P2REN3"]
# [inline (always)]
pub fn p2ren3 (& mut self) -> P2REN3_W < 3 > { P2REN3_W :: new (self) } # [doc = "Bit 4 - P2REN4"]
# [inline (always)]
pub fn p2ren4 (& mut self) -> P2REN4_W < 4 > { P2REN4_W :: new (self) } # [doc = "Bit 5 - P2REN5"]
# [inline (always)]
pub fn p2ren5 (& mut self) -> P2REN5_W < 5 > { P2REN5_W :: new (self) } # [doc = "Bit 6 - P2REN6"]
# [inline (always)]
pub fn p2ren6 (& mut self) -> P2REN6_W < 6 > { P2REN6_W :: new (self) } # [doc = "Bit 7 - P2REN7"]
# [inline (always)]
pub fn p2ren7 (& mut self) -> P2REN7_W < 7 > { P2REN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ren](index.html) module"]
pub struct P2REN_SPEC ; impl crate :: RegisterSpec for P2REN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2ren::R](R) reader structure"]
impl crate :: Readable for P2REN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2ren::W](W) writer structure"]
impl crate :: Writable for P2REN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2REN to value 0"]
impl crate :: Resettable for P2REN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1SEL0 register accessor: an alias for `Reg<P1SEL0_SPEC>`"]
pub type P1SEL0 = crate :: Reg < p1sel0 :: P1SEL0_SPEC > ; # [doc = "Port 1 Selection 0"]
pub mod p1sel0 { # [doc = "Register `P1SEL0` reader"]
pub struct R (crate :: R < P1SEL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1SEL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1SEL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1SEL0` writer"]
pub struct W (crate :: W < P1SEL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1SEL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1SEL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1SEL0_0` reader - P1SEL0_0"]
pub type P1SEL0_0_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_0` writer - P1SEL0_0"]
pub type P1SEL0_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_1` reader - P1SEL0_1"]
pub type P1SEL0_1_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_1` writer - P1SEL0_1"]
pub type P1SEL0_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_2` reader - P1SEL0_2"]
pub type P1SEL0_2_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_2` writer - P1SEL0_2"]
pub type P1SEL0_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_3` reader - P1SEL0_3"]
pub type P1SEL0_3_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_3` writer - P1SEL0_3"]
pub type P1SEL0_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_4` reader - P1SEL0_4"]
pub type P1SEL0_4_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_4` writer - P1SEL0_4"]
pub type P1SEL0_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_5` reader - P1SEL0_5"]
pub type P1SEL0_5_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_5` writer - P1SEL0_5"]
pub type P1SEL0_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_6` reader - P1SEL0_6"]
pub type P1SEL0_6_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_6` writer - P1SEL0_6"]
pub type P1SEL0_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; # [doc = "Field `P1SEL0_7` reader - P1SEL0_7"]
pub type P1SEL0_7_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL0_7` writer - P1SEL0_7"]
pub type P1SEL0_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1SEL0_0"]
# [inline (always)]
pub fn p1sel0_0 (& self) -> P1SEL0_0_R { P1SEL0_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1SEL0_1"]
# [inline (always)]
pub fn p1sel0_1 (& self) -> P1SEL0_1_R { P1SEL0_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1SEL0_2"]
# [inline (always)]
pub fn p1sel0_2 (& self) -> P1SEL0_2_R { P1SEL0_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1SEL0_3"]
# [inline (always)]
pub fn p1sel0_3 (& self) -> P1SEL0_3_R { P1SEL0_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1SEL0_4"]
# [inline (always)]
pub fn p1sel0_4 (& self) -> P1SEL0_4_R { P1SEL0_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1SEL0_5"]
# [inline (always)]
pub fn p1sel0_5 (& self) -> P1SEL0_5_R { P1SEL0_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1SEL0_6"]
# [inline (always)]
pub fn p1sel0_6 (& self) -> P1SEL0_6_R { P1SEL0_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1SEL0_7"]
# [inline (always)]
pub fn p1sel0_7 (& self) -> P1SEL0_7_R { P1SEL0_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1SEL0_0"]
# [inline (always)]
pub fn p1sel0_0 (& mut self) -> P1SEL0_0_W < 0 > { P1SEL0_0_W :: new (self) } # [doc = "Bit 1 - P1SEL0_1"]
# [inline (always)]
pub fn p1sel0_1 (& mut self) -> P1SEL0_1_W < 1 > { P1SEL0_1_W :: new (self) } # [doc = "Bit 2 - P1SEL0_2"]
# [inline (always)]
pub fn p1sel0_2 (& mut self) -> P1SEL0_2_W < 2 > { P1SEL0_2_W :: new (self) } # [doc = "Bit 3 - P1SEL0_3"]
# [inline (always)]
pub fn p1sel0_3 (& mut self) -> P1SEL0_3_W < 3 > { P1SEL0_3_W :: new (self) } # [doc = "Bit 4 - P1SEL0_4"]
# [inline (always)]
pub fn p1sel0_4 (& mut self) -> P1SEL0_4_W < 4 > { P1SEL0_4_W :: new (self) } # [doc = "Bit 5 - P1SEL0_5"]
# [inline (always)]
pub fn p1sel0_5 (& mut self) -> P1SEL0_5_W < 5 > { P1SEL0_5_W :: new (self) } # [doc = "Bit 6 - P1SEL0_6"]
# [inline (always)]
pub fn p1sel0_6 (& mut self) -> P1SEL0_6_W < 6 > { P1SEL0_6_W :: new (self) } # [doc = "Bit 7 - P1SEL0_7"]
# [inline (always)]
pub fn p1sel0_7 (& mut self) -> P1SEL0_7_W < 7 > { P1SEL0_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Selection 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel0](index.html) module"]
pub struct P1SEL0_SPEC ; impl crate :: RegisterSpec for P1SEL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1sel0::R](R) reader structure"]
impl crate :: Readable for P1SEL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1sel0::W](W) writer structure"]
impl crate :: Writable for P1SEL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1SEL0 to value 0"]
impl crate :: Resettable for P1SEL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2SEL0 register accessor: an alias for `Reg<P2SEL0_SPEC>`"]
pub type P2SEL0 = crate :: Reg < p2sel0 :: P2SEL0_SPEC > ; # [doc = "Port 2 Selection 0"]
pub mod p2sel0 { # [doc = "Register `P2SEL0` reader"]
pub struct R (crate :: R < P2SEL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2SEL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2SEL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2SEL0` writer"]
pub struct W (crate :: W < P2SEL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2SEL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2SEL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2SEL0_0` reader - P2SEL0_0"]
pub type P2SEL0_0_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_0` writer - P2SEL0_0"]
pub type P2SEL0_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_1` reader - P2SEL0_1"]
pub type P2SEL0_1_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_1` writer - P2SEL0_1"]
pub type P2SEL0_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_2` reader - P2SEL0_2"]
pub type P2SEL0_2_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_2` writer - P2SEL0_2"]
pub type P2SEL0_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_3` reader - P2SEL0_3"]
pub type P2SEL0_3_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_3` writer - P2SEL0_3"]
pub type P2SEL0_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_4` reader - P2SEL0_4"]
pub type P2SEL0_4_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_4` writer - P2SEL0_4"]
pub type P2SEL0_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_5` reader - P2SEL0_5"]
pub type P2SEL0_5_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_5` writer - P2SEL0_5"]
pub type P2SEL0_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_6` reader - P2SEL0_6"]
pub type P2SEL0_6_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_6` writer - P2SEL0_6"]
pub type P2SEL0_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; # [doc = "Field `P2SEL0_7` reader - P2SEL0_7"]
pub type P2SEL0_7_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL0_7` writer - P2SEL0_7"]
pub type P2SEL0_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2SEL0_0"]
# [inline (always)]
pub fn p2sel0_0 (& self) -> P2SEL0_0_R { P2SEL0_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2SEL0_1"]
# [inline (always)]
pub fn p2sel0_1 (& self) -> P2SEL0_1_R { P2SEL0_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2SEL0_2"]
# [inline (always)]
pub fn p2sel0_2 (& self) -> P2SEL0_2_R { P2SEL0_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2SEL0_3"]
# [inline (always)]
pub fn p2sel0_3 (& self) -> P2SEL0_3_R { P2SEL0_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2SEL0_4"]
# [inline (always)]
pub fn p2sel0_4 (& self) -> P2SEL0_4_R { P2SEL0_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2SEL0_5"]
# [inline (always)]
pub fn p2sel0_5 (& self) -> P2SEL0_5_R { P2SEL0_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2SEL0_6"]
# [inline (always)]
pub fn p2sel0_6 (& self) -> P2SEL0_6_R { P2SEL0_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2SEL0_7"]
# [inline (always)]
pub fn p2sel0_7 (& self) -> P2SEL0_7_R { P2SEL0_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2SEL0_0"]
# [inline (always)]
pub fn p2sel0_0 (& mut self) -> P2SEL0_0_W < 0 > { P2SEL0_0_W :: new (self) } # [doc = "Bit 1 - P2SEL0_1"]
# [inline (always)]
pub fn p2sel0_1 (& mut self) -> P2SEL0_1_W < 1 > { P2SEL0_1_W :: new (self) } # [doc = "Bit 2 - P2SEL0_2"]
# [inline (always)]
pub fn p2sel0_2 (& mut self) -> P2SEL0_2_W < 2 > { P2SEL0_2_W :: new (self) } # [doc = "Bit 3 - P2SEL0_3"]
# [inline (always)]
pub fn p2sel0_3 (& mut self) -> P2SEL0_3_W < 3 > { P2SEL0_3_W :: new (self) } # [doc = "Bit 4 - P2SEL0_4"]
# [inline (always)]
pub fn p2sel0_4 (& mut self) -> P2SEL0_4_W < 4 > { P2SEL0_4_W :: new (self) } # [doc = "Bit 5 - P2SEL0_5"]
# [inline (always)]
pub fn p2sel0_5 (& mut self) -> P2SEL0_5_W < 5 > { P2SEL0_5_W :: new (self) } # [doc = "Bit 6 - P2SEL0_6"]
# [inline (always)]
pub fn p2sel0_6 (& mut self) -> P2SEL0_6_W < 6 > { P2SEL0_6_W :: new (self) } # [doc = "Bit 7 - P2SEL0_7"]
# [inline (always)]
pub fn p2sel0_7 (& mut self) -> P2SEL0_7_W < 7 > { P2SEL0_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Selection 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel0](index.html) module"]
pub struct P2SEL0_SPEC ; impl crate :: RegisterSpec for P2SEL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2sel0::R](R) reader structure"]
impl crate :: Readable for P2SEL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2sel0::W](W) writer structure"]
impl crate :: Writable for P2SEL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2SEL0 to value 0"]
impl crate :: Resettable for P2SEL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1SEL1 register accessor: an alias for `Reg<P1SEL1_SPEC>`"]
pub type P1SEL1 = crate :: Reg < p1sel1 :: P1SEL1_SPEC > ; # [doc = "Port 1 Selection 1"]
pub mod p1sel1 { # [doc = "Register `P1SEL1` reader"]
pub struct R (crate :: R < P1SEL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1SEL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1SEL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1SEL1` writer"]
pub struct W (crate :: W < P1SEL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1SEL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1SEL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1SEL1_0` reader - P1SEL1_0"]
pub type P1SEL1_0_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_0` writer - P1SEL1_0"]
pub type P1SEL1_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_1` reader - P1SEL1_1"]
pub type P1SEL1_1_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_1` writer - P1SEL1_1"]
pub type P1SEL1_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_2` reader - P1SEL1_2"]
pub type P1SEL1_2_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_2` writer - P1SEL1_2"]
pub type P1SEL1_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_3` reader - P1SEL1_3"]
pub type P1SEL1_3_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_3` writer - P1SEL1_3"]
pub type P1SEL1_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_4` reader - P1SEL1_4"]
pub type P1SEL1_4_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_4` writer - P1SEL1_4"]
pub type P1SEL1_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_5` reader - P1SEL1_5"]
pub type P1SEL1_5_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_5` writer - P1SEL1_5"]
pub type P1SEL1_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_6` reader - P1SEL1_6"]
pub type P1SEL1_6_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_6` writer - P1SEL1_6"]
pub type P1SEL1_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; # [doc = "Field `P1SEL1_7` reader - P1SEL1_7"]
pub type P1SEL1_7_R = crate :: BitReader < bool > ; # [doc = "Field `P1SEL1_7` writer - P1SEL1_7"]
pub type P1SEL1_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1SEL1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1SEL1_0"]
# [inline (always)]
pub fn p1sel1_0 (& self) -> P1SEL1_0_R { P1SEL1_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1SEL1_1"]
# [inline (always)]
pub fn p1sel1_1 (& self) -> P1SEL1_1_R { P1SEL1_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1SEL1_2"]
# [inline (always)]
pub fn p1sel1_2 (& self) -> P1SEL1_2_R { P1SEL1_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1SEL1_3"]
# [inline (always)]
pub fn p1sel1_3 (& self) -> P1SEL1_3_R { P1SEL1_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1SEL1_4"]
# [inline (always)]
pub fn p1sel1_4 (& self) -> P1SEL1_4_R { P1SEL1_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1SEL1_5"]
# [inline (always)]
pub fn p1sel1_5 (& self) -> P1SEL1_5_R { P1SEL1_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1SEL1_6"]
# [inline (always)]
pub fn p1sel1_6 (& self) -> P1SEL1_6_R { P1SEL1_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1SEL1_7"]
# [inline (always)]
pub fn p1sel1_7 (& self) -> P1SEL1_7_R { P1SEL1_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1SEL1_0"]
# [inline (always)]
pub fn p1sel1_0 (& mut self) -> P1SEL1_0_W < 0 > { P1SEL1_0_W :: new (self) } # [doc = "Bit 1 - P1SEL1_1"]
# [inline (always)]
pub fn p1sel1_1 (& mut self) -> P1SEL1_1_W < 1 > { P1SEL1_1_W :: new (self) } # [doc = "Bit 2 - P1SEL1_2"]
# [inline (always)]
pub fn p1sel1_2 (& mut self) -> P1SEL1_2_W < 2 > { P1SEL1_2_W :: new (self) } # [doc = "Bit 3 - P1SEL1_3"]
# [inline (always)]
pub fn p1sel1_3 (& mut self) -> P1SEL1_3_W < 3 > { P1SEL1_3_W :: new (self) } # [doc = "Bit 4 - P1SEL1_4"]
# [inline (always)]
pub fn p1sel1_4 (& mut self) -> P1SEL1_4_W < 4 > { P1SEL1_4_W :: new (self) } # [doc = "Bit 5 - P1SEL1_5"]
# [inline (always)]
pub fn p1sel1_5 (& mut self) -> P1SEL1_5_W < 5 > { P1SEL1_5_W :: new (self) } # [doc = "Bit 6 - P1SEL1_6"]
# [inline (always)]
pub fn p1sel1_6 (& mut self) -> P1SEL1_6_W < 6 > { P1SEL1_6_W :: new (self) } # [doc = "Bit 7 - P1SEL1_7"]
# [inline (always)]
pub fn p1sel1_7 (& mut self) -> P1SEL1_7_W < 7 > { P1SEL1_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Selection 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1sel1](index.html) module"]
pub struct P1SEL1_SPEC ; impl crate :: RegisterSpec for P1SEL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1sel1::R](R) reader structure"]
impl crate :: Readable for P1SEL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1sel1::W](W) writer structure"]
impl crate :: Writable for P1SEL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1SEL1 to value 0"]
impl crate :: Resettable for P1SEL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2SEL1 register accessor: an alias for `Reg<P2SEL1_SPEC>`"]
pub type P2SEL1 = crate :: Reg < p2sel1 :: P2SEL1_SPEC > ; # [doc = "Port 2 Selection 1"]
pub mod p2sel1 { # [doc = "Register `P2SEL1` reader"]
pub struct R (crate :: R < P2SEL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2SEL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2SEL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2SEL1` writer"]
pub struct W (crate :: W < P2SEL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2SEL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2SEL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2SEL1_0` reader - P2SEL1_0"]
pub type P2SEL1_0_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_0` writer - P2SEL1_0"]
pub type P2SEL1_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_1` reader - P2SEL1_1"]
pub type P2SEL1_1_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_1` writer - P2SEL1_1"]
pub type P2SEL1_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_2` reader - P2SEL1_2"]
pub type P2SEL1_2_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_2` writer - P2SEL1_2"]
pub type P2SEL1_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_3` reader - P2SEL1_3"]
pub type P2SEL1_3_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_3` writer - P2SEL1_3"]
pub type P2SEL1_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_4` reader - P2SEL1_4"]
pub type P2SEL1_4_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_4` writer - P2SEL1_4"]
pub type P2SEL1_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_5` reader - P2SEL1_5"]
pub type P2SEL1_5_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_5` writer - P2SEL1_5"]
pub type P2SEL1_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_6` reader - P2SEL1_6"]
pub type P2SEL1_6_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_6` writer - P2SEL1_6"]
pub type P2SEL1_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; # [doc = "Field `P2SEL1_7` reader - P2SEL1_7"]
pub type P2SEL1_7_R = crate :: BitReader < bool > ; # [doc = "Field `P2SEL1_7` writer - P2SEL1_7"]
pub type P2SEL1_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2SEL1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2SEL1_0"]
# [inline (always)]
pub fn p2sel1_0 (& self) -> P2SEL1_0_R { P2SEL1_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2SEL1_1"]
# [inline (always)]
pub fn p2sel1_1 (& self) -> P2SEL1_1_R { P2SEL1_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2SEL1_2"]
# [inline (always)]
pub fn p2sel1_2 (& self) -> P2SEL1_2_R { P2SEL1_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2SEL1_3"]
# [inline (always)]
pub fn p2sel1_3 (& self) -> P2SEL1_3_R { P2SEL1_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2SEL1_4"]
# [inline (always)]
pub fn p2sel1_4 (& self) -> P2SEL1_4_R { P2SEL1_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2SEL1_5"]
# [inline (always)]
pub fn p2sel1_5 (& self) -> P2SEL1_5_R { P2SEL1_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2SEL1_6"]
# [inline (always)]
pub fn p2sel1_6 (& self) -> P2SEL1_6_R { P2SEL1_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2SEL1_7"]
# [inline (always)]
pub fn p2sel1_7 (& self) -> P2SEL1_7_R { P2SEL1_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2SEL1_0"]
# [inline (always)]
pub fn p2sel1_0 (& mut self) -> P2SEL1_0_W < 0 > { P2SEL1_0_W :: new (self) } # [doc = "Bit 1 - P2SEL1_1"]
# [inline (always)]
pub fn p2sel1_1 (& mut self) -> P2SEL1_1_W < 1 > { P2SEL1_1_W :: new (self) } # [doc = "Bit 2 - P2SEL1_2"]
# [inline (always)]
pub fn p2sel1_2 (& mut self) -> P2SEL1_2_W < 2 > { P2SEL1_2_W :: new (self) } # [doc = "Bit 3 - P2SEL1_3"]
# [inline (always)]
pub fn p2sel1_3 (& mut self) -> P2SEL1_3_W < 3 > { P2SEL1_3_W :: new (self) } # [doc = "Bit 4 - P2SEL1_4"]
# [inline (always)]
pub fn p2sel1_4 (& mut self) -> P2SEL1_4_W < 4 > { P2SEL1_4_W :: new (self) } # [doc = "Bit 5 - P2SEL1_5"]
# [inline (always)]
pub fn p2sel1_5 (& mut self) -> P2SEL1_5_W < 5 > { P2SEL1_5_W :: new (self) } # [doc = "Bit 6 - P2SEL1_6"]
# [inline (always)]
pub fn p2sel1_6 (& mut self) -> P2SEL1_6_W < 6 > { P2SEL1_6_W :: new (self) } # [doc = "Bit 7 - P2SEL1_7"]
# [inline (always)]
pub fn p2sel1_7 (& mut self) -> P2SEL1_7_W < 7 > { P2SEL1_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Selection 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2sel1](index.html) module"]
pub struct P2SEL1_SPEC ; impl crate :: RegisterSpec for P2SEL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2sel1::R](R) reader structure"]
impl crate :: Readable for P2SEL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2sel1::W](W) writer structure"]
impl crate :: Writable for P2SEL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2SEL1 to value 0"]
impl crate :: Resettable for P2SEL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1IES register accessor: an alias for `Reg<P1IES_SPEC>`"]
pub type P1IES = crate :: Reg < p1ies :: P1IES_SPEC > ; # [doc = "Port 1 Interrupt Edge Select"]
pub mod p1ies { # [doc = "Register `P1IES` reader"]
pub struct R (crate :: R < P1IES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1IES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1IES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1IES_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1IES` writer"]
pub struct W (crate :: W < P1IES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1IES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1IES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1IES_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1IES0` reader - P1IES0"]
pub type P1IES0_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES0` writer - P1IES0"]
pub type P1IES0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES1` reader - P1IES1"]
pub type P1IES1_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES1` writer - P1IES1"]
pub type P1IES1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES2` reader - P1IES2"]
pub type P1IES2_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES2` writer - P1IES2"]
pub type P1IES2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES3` reader - P1IES3"]
pub type P1IES3_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES3` writer - P1IES3"]
pub type P1IES3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES4` reader - P1IES4"]
pub type P1IES4_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES4` writer - P1IES4"]
pub type P1IES4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES5` reader - P1IES5"]
pub type P1IES5_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES5` writer - P1IES5"]
pub type P1IES5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES6` reader - P1IES6"]
pub type P1IES6_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES6` writer - P1IES6"]
pub type P1IES6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; # [doc = "Field `P1IES7` reader - P1IES7"]
pub type P1IES7_R = crate :: BitReader < bool > ; # [doc = "Field `P1IES7` writer - P1IES7"]
pub type P1IES7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IES_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1IES0"]
# [inline (always)]
pub fn p1ies0 (& self) -> P1IES0_R { P1IES0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1IES1"]
# [inline (always)]
pub fn p1ies1 (& self) -> P1IES1_R { P1IES1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1IES2"]
# [inline (always)]
pub fn p1ies2 (& self) -> P1IES2_R { P1IES2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1IES3"]
# [inline (always)]
pub fn p1ies3 (& self) -> P1IES3_R { P1IES3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1IES4"]
# [inline (always)]
pub fn p1ies4 (& self) -> P1IES4_R { P1IES4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1IES5"]
# [inline (always)]
pub fn p1ies5 (& self) -> P1IES5_R { P1IES5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1IES6"]
# [inline (always)]
pub fn p1ies6 (& self) -> P1IES6_R { P1IES6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1IES7"]
# [inline (always)]
pub fn p1ies7 (& self) -> P1IES7_R { P1IES7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1IES0"]
# [inline (always)]
pub fn p1ies0 (& mut self) -> P1IES0_W < 0 > { P1IES0_W :: new (self) } # [doc = "Bit 1 - P1IES1"]
# [inline (always)]
pub fn p1ies1 (& mut self) -> P1IES1_W < 1 > { P1IES1_W :: new (self) } # [doc = "Bit 2 - P1IES2"]
# [inline (always)]
pub fn p1ies2 (& mut self) -> P1IES2_W < 2 > { P1IES2_W :: new (self) } # [doc = "Bit 3 - P1IES3"]
# [inline (always)]
pub fn p1ies3 (& mut self) -> P1IES3_W < 3 > { P1IES3_W :: new (self) } # [doc = "Bit 4 - P1IES4"]
# [inline (always)]
pub fn p1ies4 (& mut self) -> P1IES4_W < 4 > { P1IES4_W :: new (self) } # [doc = "Bit 5 - P1IES5"]
# [inline (always)]
pub fn p1ies5 (& mut self) -> P1IES5_W < 5 > { P1IES5_W :: new (self) } # [doc = "Bit 6 - P1IES6"]
# [inline (always)]
pub fn p1ies6 (& mut self) -> P1IES6_W < 6 > { P1IES6_W :: new (self) } # [doc = "Bit 7 - P1IES7"]
# [inline (always)]
pub fn p1ies7 (& mut self) -> P1IES7_W < 7 > { P1IES7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ies](index.html) module"]
pub struct P1IES_SPEC ; impl crate :: RegisterSpec for P1IES_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1ies::R](R) reader structure"]
impl crate :: Readable for P1IES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1ies::W](W) writer structure"]
impl crate :: Writable for P1IES_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1IES to value 0"]
impl crate :: Resettable for P1IES_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2IES register accessor: an alias for `Reg<P2IES_SPEC>`"]
pub type P2IES = crate :: Reg < p2ies :: P2IES_SPEC > ; # [doc = "Port 2 Interrupt Edge Select"]
pub mod p2ies { # [doc = "Register `P2IES` reader"]
pub struct R (crate :: R < P2IES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2IES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2IES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2IES_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2IES` writer"]
pub struct W (crate :: W < P2IES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2IES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2IES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2IES_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2IES0` reader - P2IES0"]
pub type P2IES0_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES0` writer - P2IES0"]
pub type P2IES0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES1` reader - P2IES1"]
pub type P2IES1_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES1` writer - P2IES1"]
pub type P2IES1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES2` reader - P2IES2"]
pub type P2IES2_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES2` writer - P2IES2"]
pub type P2IES2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES3` reader - P2IES3"]
pub type P2IES3_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES3` writer - P2IES3"]
pub type P2IES3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES4` reader - P2IES4"]
pub type P2IES4_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES4` writer - P2IES4"]
pub type P2IES4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES5` reader - P2IES5"]
pub type P2IES5_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES5` writer - P2IES5"]
pub type P2IES5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES6` reader - P2IES6"]
pub type P2IES6_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES6` writer - P2IES6"]
pub type P2IES6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; # [doc = "Field `P2IES7` reader - P2IES7"]
pub type P2IES7_R = crate :: BitReader < bool > ; # [doc = "Field `P2IES7` writer - P2IES7"]
pub type P2IES7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IES_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2IES0"]
# [inline (always)]
pub fn p2ies0 (& self) -> P2IES0_R { P2IES0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2IES1"]
# [inline (always)]
pub fn p2ies1 (& self) -> P2IES1_R { P2IES1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2IES2"]
# [inline (always)]
pub fn p2ies2 (& self) -> P2IES2_R { P2IES2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2IES3"]
# [inline (always)]
pub fn p2ies3 (& self) -> P2IES3_R { P2IES3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2IES4"]
# [inline (always)]
pub fn p2ies4 (& self) -> P2IES4_R { P2IES4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2IES5"]
# [inline (always)]
pub fn p2ies5 (& self) -> P2IES5_R { P2IES5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2IES6"]
# [inline (always)]
pub fn p2ies6 (& self) -> P2IES6_R { P2IES6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2IES7"]
# [inline (always)]
pub fn p2ies7 (& self) -> P2IES7_R { P2IES7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2IES0"]
# [inline (always)]
pub fn p2ies0 (& mut self) -> P2IES0_W < 0 > { P2IES0_W :: new (self) } # [doc = "Bit 1 - P2IES1"]
# [inline (always)]
pub fn p2ies1 (& mut self) -> P2IES1_W < 1 > { P2IES1_W :: new (self) } # [doc = "Bit 2 - P2IES2"]
# [inline (always)]
pub fn p2ies2 (& mut self) -> P2IES2_W < 2 > { P2IES2_W :: new (self) } # [doc = "Bit 3 - P2IES3"]
# [inline (always)]
pub fn p2ies3 (& mut self) -> P2IES3_W < 3 > { P2IES3_W :: new (self) } # [doc = "Bit 4 - P2IES4"]
# [inline (always)]
pub fn p2ies4 (& mut self) -> P2IES4_W < 4 > { P2IES4_W :: new (self) } # [doc = "Bit 5 - P2IES5"]
# [inline (always)]
pub fn p2ies5 (& mut self) -> P2IES5_W < 5 > { P2IES5_W :: new (self) } # [doc = "Bit 6 - P2IES6"]
# [inline (always)]
pub fn p2ies6 (& mut self) -> P2IES6_W < 6 > { P2IES6_W :: new (self) } # [doc = "Bit 7 - P2IES7"]
# [inline (always)]
pub fn p2ies7 (& mut self) -> P2IES7_W < 7 > { P2IES7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Interrupt Edge Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ies](index.html) module"]
pub struct P2IES_SPEC ; impl crate :: RegisterSpec for P2IES_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2ies::R](R) reader structure"]
impl crate :: Readable for P2IES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2ies::W](W) writer structure"]
impl crate :: Writable for P2IES_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2IES to value 0"]
impl crate :: Resettable for P2IES_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1IE register accessor: an alias for `Reg<P1IE_SPEC>`"]
pub type P1IE = crate :: Reg < p1ie :: P1IE_SPEC > ; # [doc = "Port 1 Interrupt Enable"]
pub mod p1ie { # [doc = "Register `P1IE` reader"]
pub struct R (crate :: R < P1IE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1IE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1IE_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1IE` writer"]
pub struct W (crate :: W < P1IE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1IE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1IE_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1IE0` reader - P1IE0"]
pub type P1IE0_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE0` writer - P1IE0"]
pub type P1IE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE1` reader - P1IE1"]
pub type P1IE1_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE1` writer - P1IE1"]
pub type P1IE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE2` reader - P1IE2"]
pub type P1IE2_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE2` writer - P1IE2"]
pub type P1IE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE3` reader - P1IE3"]
pub type P1IE3_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE3` writer - P1IE3"]
pub type P1IE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE4` reader - P1IE4"]
pub type P1IE4_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE4` writer - P1IE4"]
pub type P1IE4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE5` reader - P1IE5"]
pub type P1IE5_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE5` writer - P1IE5"]
pub type P1IE5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE6` reader - P1IE6"]
pub type P1IE6_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE6` writer - P1IE6"]
pub type P1IE6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; # [doc = "Field `P1IE7` reader - P1IE7"]
pub type P1IE7_R = crate :: BitReader < bool > ; # [doc = "Field `P1IE7` writer - P1IE7"]
pub type P1IE7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1IE0"]
# [inline (always)]
pub fn p1ie0 (& self) -> P1IE0_R { P1IE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1IE1"]
# [inline (always)]
pub fn p1ie1 (& self) -> P1IE1_R { P1IE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1IE2"]
# [inline (always)]
pub fn p1ie2 (& self) -> P1IE2_R { P1IE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1IE3"]
# [inline (always)]
pub fn p1ie3 (& self) -> P1IE3_R { P1IE3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1IE4"]
# [inline (always)]
pub fn p1ie4 (& self) -> P1IE4_R { P1IE4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1IE5"]
# [inline (always)]
pub fn p1ie5 (& self) -> P1IE5_R { P1IE5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1IE6"]
# [inline (always)]
pub fn p1ie6 (& self) -> P1IE6_R { P1IE6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1IE7"]
# [inline (always)]
pub fn p1ie7 (& self) -> P1IE7_R { P1IE7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1IE0"]
# [inline (always)]
pub fn p1ie0 (& mut self) -> P1IE0_W < 0 > { P1IE0_W :: new (self) } # [doc = "Bit 1 - P1IE1"]
# [inline (always)]
pub fn p1ie1 (& mut self) -> P1IE1_W < 1 > { P1IE1_W :: new (self) } # [doc = "Bit 2 - P1IE2"]
# [inline (always)]
pub fn p1ie2 (& mut self) -> P1IE2_W < 2 > { P1IE2_W :: new (self) } # [doc = "Bit 3 - P1IE3"]
# [inline (always)]
pub fn p1ie3 (& mut self) -> P1IE3_W < 3 > { P1IE3_W :: new (self) } # [doc = "Bit 4 - P1IE4"]
# [inline (always)]
pub fn p1ie4 (& mut self) -> P1IE4_W < 4 > { P1IE4_W :: new (self) } # [doc = "Bit 5 - P1IE5"]
# [inline (always)]
pub fn p1ie5 (& mut self) -> P1IE5_W < 5 > { P1IE5_W :: new (self) } # [doc = "Bit 6 - P1IE6"]
# [inline (always)]
pub fn p1ie6 (& mut self) -> P1IE6_W < 6 > { P1IE6_W :: new (self) } # [doc = "Bit 7 - P1IE7"]
# [inline (always)]
pub fn p1ie7 (& mut self) -> P1IE7_W < 7 > { P1IE7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ie](index.html) module"]
pub struct P1IE_SPEC ; impl crate :: RegisterSpec for P1IE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1ie::R](R) reader structure"]
impl crate :: Readable for P1IE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1ie::W](W) writer structure"]
impl crate :: Writable for P1IE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1IE to value 0"]
impl crate :: Resettable for P1IE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2IE register accessor: an alias for `Reg<P2IE_SPEC>`"]
pub type P2IE = crate :: Reg < p2ie :: P2IE_SPEC > ; # [doc = "Port 2 Interrupt Enable"]
pub mod p2ie { # [doc = "Register `P2IE` reader"]
pub struct R (crate :: R < P2IE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2IE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2IE_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2IE` writer"]
pub struct W (crate :: W < P2IE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2IE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2IE_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2IE0` reader - P2IE0"]
pub type P2IE0_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE0` writer - P2IE0"]
pub type P2IE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE1` reader - P2IE1"]
pub type P2IE1_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE1` writer - P2IE1"]
pub type P2IE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE2` reader - P2IE2"]
pub type P2IE2_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE2` writer - P2IE2"]
pub type P2IE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE3` reader - P2IE3"]
pub type P2IE3_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE3` writer - P2IE3"]
pub type P2IE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE4` reader - P2IE4"]
pub type P2IE4_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE4` writer - P2IE4"]
pub type P2IE4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE5` reader - P2IE5"]
pub type P2IE5_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE5` writer - P2IE5"]
pub type P2IE5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE6` reader - P2IE6"]
pub type P2IE6_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE6` writer - P2IE6"]
pub type P2IE6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; # [doc = "Field `P2IE7` reader - P2IE7"]
pub type P2IE7_R = crate :: BitReader < bool > ; # [doc = "Field `P2IE7` writer - P2IE7"]
pub type P2IE7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2IE0"]
# [inline (always)]
pub fn p2ie0 (& self) -> P2IE0_R { P2IE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2IE1"]
# [inline (always)]
pub fn p2ie1 (& self) -> P2IE1_R { P2IE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2IE2"]
# [inline (always)]
pub fn p2ie2 (& self) -> P2IE2_R { P2IE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2IE3"]
# [inline (always)]
pub fn p2ie3 (& self) -> P2IE3_R { P2IE3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2IE4"]
# [inline (always)]
pub fn p2ie4 (& self) -> P2IE4_R { P2IE4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2IE5"]
# [inline (always)]
pub fn p2ie5 (& self) -> P2IE5_R { P2IE5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2IE6"]
# [inline (always)]
pub fn p2ie6 (& self) -> P2IE6_R { P2IE6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2IE7"]
# [inline (always)]
pub fn p2ie7 (& self) -> P2IE7_R { P2IE7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2IE0"]
# [inline (always)]
pub fn p2ie0 (& mut self) -> P2IE0_W < 0 > { P2IE0_W :: new (self) } # [doc = "Bit 1 - P2IE1"]
# [inline (always)]
pub fn p2ie1 (& mut self) -> P2IE1_W < 1 > { P2IE1_W :: new (self) } # [doc = "Bit 2 - P2IE2"]
# [inline (always)]
pub fn p2ie2 (& mut self) -> P2IE2_W < 2 > { P2IE2_W :: new (self) } # [doc = "Bit 3 - P2IE3"]
# [inline (always)]
pub fn p2ie3 (& mut self) -> P2IE3_W < 3 > { P2IE3_W :: new (self) } # [doc = "Bit 4 - P2IE4"]
# [inline (always)]
pub fn p2ie4 (& mut self) -> P2IE4_W < 4 > { P2IE4_W :: new (self) } # [doc = "Bit 5 - P2IE5"]
# [inline (always)]
pub fn p2ie5 (& mut self) -> P2IE5_W < 5 > { P2IE5_W :: new (self) } # [doc = "Bit 6 - P2IE6"]
# [inline (always)]
pub fn p2ie6 (& mut self) -> P2IE6_W < 6 > { P2IE6_W :: new (self) } # [doc = "Bit 7 - P2IE7"]
# [inline (always)]
pub fn p2ie7 (& mut self) -> P2IE7_W < 7 > { P2IE7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ie](index.html) module"]
pub struct P2IE_SPEC ; impl crate :: RegisterSpec for P2IE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2ie::R](R) reader structure"]
impl crate :: Readable for P2IE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2ie::W](W) writer structure"]
impl crate :: Writable for P2IE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2IE to value 0"]
impl crate :: Resettable for P2IE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1IFG register accessor: an alias for `Reg<P1IFG_SPEC>`"]
pub type P1IFG = crate :: Reg < p1ifg :: P1IFG_SPEC > ; # [doc = "Port 1 Interrupt Flag"]
pub mod p1ifg { # [doc = "Register `P1IFG` reader"]
pub struct R (crate :: R < P1IFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1IFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1IFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1IFG` writer"]
pub struct W (crate :: W < P1IFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1IFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1IFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `P1IFG0` reader - P1IFG0"]
pub type P1IFG0_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG0` writer - P1IFG0"]
pub type P1IFG0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG1` reader - P1IFG1"]
pub type P1IFG1_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG1` writer - P1IFG1"]
pub type P1IFG1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG2` reader - P1IFG2"]
pub type P1IFG2_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG2` writer - P1IFG2"]
pub type P1IFG2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG3` reader - P1IFG3"]
pub type P1IFG3_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG3` writer - P1IFG3"]
pub type P1IFG3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG4` reader - P1IFG4"]
pub type P1IFG4_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG4` writer - P1IFG4"]
pub type P1IFG4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG5` reader - P1IFG5"]
pub type P1IFG5_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG5` writer - P1IFG5"]
pub type P1IFG5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG6` reader - P1IFG6"]
pub type P1IFG6_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG6` writer - P1IFG6"]
pub type P1IFG6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; # [doc = "Field `P1IFG7` reader - P1IFG7"]
pub type P1IFG7_R = crate :: BitReader < bool > ; # [doc = "Field `P1IFG7` writer - P1IFG7"]
pub type P1IFG7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P1IFG_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P1IFG0"]
# [inline (always)]
pub fn p1ifg0 (& self) -> P1IFG0_R { P1IFG0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P1IFG1"]
# [inline (always)]
pub fn p1ifg1 (& self) -> P1IFG1_R { P1IFG1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P1IFG2"]
# [inline (always)]
pub fn p1ifg2 (& self) -> P1IFG2_R { P1IFG2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P1IFG3"]
# [inline (always)]
pub fn p1ifg3 (& self) -> P1IFG3_R { P1IFG3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P1IFG4"]
# [inline (always)]
pub fn p1ifg4 (& self) -> P1IFG4_R { P1IFG4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P1IFG5"]
# [inline (always)]
pub fn p1ifg5 (& self) -> P1IFG5_R { P1IFG5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P1IFG6"]
# [inline (always)]
pub fn p1ifg6 (& self) -> P1IFG6_R { P1IFG6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P1IFG7"]
# [inline (always)]
pub fn p1ifg7 (& self) -> P1IFG7_R { P1IFG7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P1IFG0"]
# [inline (always)]
pub fn p1ifg0 (& mut self) -> P1IFG0_W < 0 > { P1IFG0_W :: new (self) } # [doc = "Bit 1 - P1IFG1"]
# [inline (always)]
pub fn p1ifg1 (& mut self) -> P1IFG1_W < 1 > { P1IFG1_W :: new (self) } # [doc = "Bit 2 - P1IFG2"]
# [inline (always)]
pub fn p1ifg2 (& mut self) -> P1IFG2_W < 2 > { P1IFG2_W :: new (self) } # [doc = "Bit 3 - P1IFG3"]
# [inline (always)]
pub fn p1ifg3 (& mut self) -> P1IFG3_W < 3 > { P1IFG3_W :: new (self) } # [doc = "Bit 4 - P1IFG4"]
# [inline (always)]
pub fn p1ifg4 (& mut self) -> P1IFG4_W < 4 > { P1IFG4_W :: new (self) } # [doc = "Bit 5 - P1IFG5"]
# [inline (always)]
pub fn p1ifg5 (& mut self) -> P1IFG5_W < 5 > { P1IFG5_W :: new (self) } # [doc = "Bit 6 - P1IFG6"]
# [inline (always)]
pub fn p1ifg6 (& mut self) -> P1IFG6_W < 6 > { P1IFG6_W :: new (self) } # [doc = "Bit 7 - P1IFG7"]
# [inline (always)]
pub fn p1ifg7 (& mut self) -> P1IFG7_W < 7 > { P1IFG7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1ifg](index.html) module"]
pub struct P1IFG_SPEC ; impl crate :: RegisterSpec for P1IFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p1ifg::R](R) reader structure"]
impl crate :: Readable for P1IFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1ifg::W](W) writer structure"]
impl crate :: Writable for P1IFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1IFG to value 0"]
impl crate :: Resettable for P1IFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2IFG register accessor: an alias for `Reg<P2IFG_SPEC>`"]
pub type P2IFG = crate :: Reg < p2ifg :: P2IFG_SPEC > ; # [doc = "Port 2 Interrupt Flag"]
pub mod p2ifg { # [doc = "Register `P2IFG` reader"]
pub struct R (crate :: R < P2IFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2IFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2IFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2IFG` writer"]
pub struct W (crate :: W < P2IFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2IFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2IFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `P2IFG0` reader - P2IFG0"]
pub type P2IFG0_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG0` writer - P2IFG0"]
pub type P2IFG0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG1` reader - P2IFG1"]
pub type P2IFG1_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG1` writer - P2IFG1"]
pub type P2IFG1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG2` reader - P2IFG2"]
pub type P2IFG2_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG2` writer - P2IFG2"]
pub type P2IFG2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG3` reader - P2IFG3"]
pub type P2IFG3_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG3` writer - P2IFG3"]
pub type P2IFG3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG4` reader - P2IFG4"]
pub type P2IFG4_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG4` writer - P2IFG4"]
pub type P2IFG4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG5` reader - P2IFG5"]
pub type P2IFG5_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG5` writer - P2IFG5"]
pub type P2IFG5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG6` reader - P2IFG6"]
pub type P2IFG6_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG6` writer - P2IFG6"]
pub type P2IFG6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; # [doc = "Field `P2IFG7` reader - P2IFG7"]
pub type P2IFG7_R = crate :: BitReader < bool > ; # [doc = "Field `P2IFG7` writer - P2IFG7"]
pub type P2IFG7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P2IFG_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P2IFG0"]
# [inline (always)]
pub fn p2ifg0 (& self) -> P2IFG0_R { P2IFG0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P2IFG1"]
# [inline (always)]
pub fn p2ifg1 (& self) -> P2IFG1_R { P2IFG1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P2IFG2"]
# [inline (always)]
pub fn p2ifg2 (& self) -> P2IFG2_R { P2IFG2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P2IFG3"]
# [inline (always)]
pub fn p2ifg3 (& self) -> P2IFG3_R { P2IFG3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P2IFG4"]
# [inline (always)]
pub fn p2ifg4 (& self) -> P2IFG4_R { P2IFG4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P2IFG5"]
# [inline (always)]
pub fn p2ifg5 (& self) -> P2IFG5_R { P2IFG5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P2IFG6"]
# [inline (always)]
pub fn p2ifg6 (& self) -> P2IFG6_R { P2IFG6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P2IFG7"]
# [inline (always)]
pub fn p2ifg7 (& self) -> P2IFG7_R { P2IFG7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P2IFG0"]
# [inline (always)]
pub fn p2ifg0 (& mut self) -> P2IFG0_W < 0 > { P2IFG0_W :: new (self) } # [doc = "Bit 1 - P2IFG1"]
# [inline (always)]
pub fn p2ifg1 (& mut self) -> P2IFG1_W < 1 > { P2IFG1_W :: new (self) } # [doc = "Bit 2 - P2IFG2"]
# [inline (always)]
pub fn p2ifg2 (& mut self) -> P2IFG2_W < 2 > { P2IFG2_W :: new (self) } # [doc = "Bit 3 - P2IFG3"]
# [inline (always)]
pub fn p2ifg3 (& mut self) -> P2IFG3_W < 3 > { P2IFG3_W :: new (self) } # [doc = "Bit 4 - P2IFG4"]
# [inline (always)]
pub fn p2ifg4 (& mut self) -> P2IFG4_W < 4 > { P2IFG4_W :: new (self) } # [doc = "Bit 5 - P2IFG5"]
# [inline (always)]
pub fn p2ifg5 (& mut self) -> P2IFG5_W < 5 > { P2IFG5_W :: new (self) } # [doc = "Bit 6 - P2IFG6"]
# [inline (always)]
pub fn p2ifg6 (& mut self) -> P2IFG6_W < 6 > { P2IFG6_W :: new (self) } # [doc = "Bit 7 - P2IFG7"]
# [inline (always)]
pub fn p2ifg7 (& mut self) -> P2IFG7_W < 7 > { P2IFG7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2ifg](index.html) module"]
pub struct P2IFG_SPEC ; impl crate :: RegisterSpec for P2IFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p2ifg::R](R) reader structure"]
impl crate :: Readable for P2IFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2ifg::W](W) writer structure"]
impl crate :: Writable for P2IFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2IFG to value 0"]
impl crate :: Resettable for P2IFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P1IV register accessor: an alias for `Reg<P1IV_SPEC>`"]
pub type P1IV = crate :: Reg < p1iv :: P1IV_SPEC > ; # [doc = "Port 1 Interrupt Vector Word"]
pub mod p1iv { # [doc = "Register `P1IV` reader"]
pub struct R (crate :: R < P1IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P1IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P1IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `P1IV` writer"]
pub struct W (crate :: W < P1IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P1IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P1IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 1 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p1iv](index.html) module"]
pub struct P1IV_SPEC ; impl crate :: RegisterSpec for P1IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [p1iv::R](R) reader structure"]
impl crate :: Readable for P1IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p1iv::W](W) writer structure"]
impl crate :: Writable for P1IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P1IV to value 0"]
impl crate :: Resettable for P1IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P2IV register accessor: an alias for `Reg<P2IV_SPEC>`"]
pub type P2IV = crate :: Reg < p2iv :: P2IV_SPEC > ; # [doc = "Port 2 Interrupt Vector Word"]
pub mod p2iv { # [doc = "Register `P2IV` reader"]
pub struct R (crate :: R < P2IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P2IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P2IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P2IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `P2IV` writer"]
pub struct W (crate :: W < P2IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P2IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P2IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P2IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 2 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p2iv](index.html) module"]
pub struct P2IV_SPEC ; impl crate :: RegisterSpec for P2IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [p2iv::R](R) reader structure"]
impl crate :: Readable for P2IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p2iv::W](W) writer structure"]
impl crate :: Writable for P2IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P2IV to value 0"]
impl crate :: Resettable for P2IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Port 3"]
pub struct PORT_3 { _marker : PhantomData < * const () > } unsafe impl Send for PORT_3 { } impl PORT_3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const port_3 :: RegisterBlock = 0x0220 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const port_3 :: RegisterBlock { Self :: PTR } } impl Deref for PORT_3 { type Target = port_3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORT_3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORT_3") . finish () } } # [doc = "Port 3"]
pub mod port_3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port 3 Input"]
pub p3in : crate :: Reg < p3in :: P3IN_SPEC > , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Port 3 Output"]
pub p3out : crate :: Reg < p3out :: P3OUT_SPEC > , _reserved2 : [u8 ; 0x01]
, # [doc = "0x04 - Port 3 Direction"]
pub p3dir : crate :: Reg < p3dir :: P3DIR_SPEC > , _reserved3 : [u8 ; 0x01]
, # [doc = "0x06 - Port 3 Resistor Enable"]
pub p3ren : crate :: Reg < p3ren :: P3REN_SPEC > , _reserved4 : [u8 ; 0x03]
, # [doc = "0x0a - Port 3 Selection0"]
pub p3sel0 : crate :: Reg < p3sel0 :: P3SEL0_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x0c - Port 3 Selection1"]
pub p3sel1 : crate :: Reg < p3sel1 :: P3SEL1_SPEC > , } # [doc = "P3IN register accessor: an alias for `Reg<P3IN_SPEC>`"]
pub type P3IN = crate :: Reg < p3in :: P3IN_SPEC > ; # [doc = "Port 3 Input"]
pub mod p3in { # [doc = "Register `P3IN` reader"]
pub struct R (crate :: R < P3IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3IN` writer"]
pub struct W (crate :: W < P3IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3IN0` reader - P3IN0"]
pub type P3IN0_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN0` writer - P3IN0"]
pub type P3IN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN1` reader - P3IN1"]
pub type P3IN1_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN1` writer - P3IN1"]
pub type P3IN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN2` reader - P3IN2"]
pub type P3IN2_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN2` writer - P3IN2"]
pub type P3IN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN3` reader - P3IN3"]
pub type P3IN3_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN3` writer - P3IN3"]
pub type P3IN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN4` reader - P3IN4"]
pub type P3IN4_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN4` writer - P3IN4"]
pub type P3IN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN5` reader - P3IN5"]
pub type P3IN5_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN5` writer - P3IN5"]
pub type P3IN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN6` reader - P3IN6"]
pub type P3IN6_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN6` writer - P3IN6"]
pub type P3IN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; # [doc = "Field `P3IN7` reader - P3IN7"]
pub type P3IN7_R = crate :: BitReader < bool > ; # [doc = "Field `P3IN7` writer - P3IN7"]
pub type P3IN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3IN0"]
# [inline (always)]
pub fn p3in0 (& self) -> P3IN0_R { P3IN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3IN1"]
# [inline (always)]
pub fn p3in1 (& self) -> P3IN1_R { P3IN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3IN2"]
# [inline (always)]
pub fn p3in2 (& self) -> P3IN2_R { P3IN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3IN3"]
# [inline (always)]
pub fn p3in3 (& self) -> P3IN3_R { P3IN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3IN4"]
# [inline (always)]
pub fn p3in4 (& self) -> P3IN4_R { P3IN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3IN5"]
# [inline (always)]
pub fn p3in5 (& self) -> P3IN5_R { P3IN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3IN6"]
# [inline (always)]
pub fn p3in6 (& self) -> P3IN6_R { P3IN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3IN7"]
# [inline (always)]
pub fn p3in7 (& self) -> P3IN7_R { P3IN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3IN0"]
# [inline (always)]
pub fn p3in0 (& mut self) -> P3IN0_W < 0 > { P3IN0_W :: new (self) } # [doc = "Bit 1 - P3IN1"]
# [inline (always)]
pub fn p3in1 (& mut self) -> P3IN1_W < 1 > { P3IN1_W :: new (self) } # [doc = "Bit 2 - P3IN2"]
# [inline (always)]
pub fn p3in2 (& mut self) -> P3IN2_W < 2 > { P3IN2_W :: new (self) } # [doc = "Bit 3 - P3IN3"]
# [inline (always)]
pub fn p3in3 (& mut self) -> P3IN3_W < 3 > { P3IN3_W :: new (self) } # [doc = "Bit 4 - P3IN4"]
# [inline (always)]
pub fn p3in4 (& mut self) -> P3IN4_W < 4 > { P3IN4_W :: new (self) } # [doc = "Bit 5 - P3IN5"]
# [inline (always)]
pub fn p3in5 (& mut self) -> P3IN5_W < 5 > { P3IN5_W :: new (self) } # [doc = "Bit 6 - P3IN6"]
# [inline (always)]
pub fn p3in6 (& mut self) -> P3IN6_W < 6 > { P3IN6_W :: new (self) } # [doc = "Bit 7 - P3IN7"]
# [inline (always)]
pub fn p3in7 (& mut self) -> P3IN7_W < 7 > { P3IN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3in](index.html) module"]
pub struct P3IN_SPEC ; impl crate :: RegisterSpec for P3IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3in::R](R) reader structure"]
impl crate :: Readable for P3IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3in::W](W) writer structure"]
impl crate :: Writable for P3IN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3IN to value 0"]
impl crate :: Resettable for P3IN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P3OUT register accessor: an alias for `Reg<P3OUT_SPEC>`"]
pub type P3OUT = crate :: Reg < p3out :: P3OUT_SPEC > ; # [doc = "Port 3 Output"]
pub mod p3out { # [doc = "Register `P3OUT` reader"]
pub struct R (crate :: R < P3OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3OUT` writer"]
pub struct W (crate :: W < P3OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3OUT0` reader - P3OUT0"]
pub type P3OUT0_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT0` writer - P3OUT0"]
pub type P3OUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT1` reader - P3OUT1"]
pub type P3OUT1_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT1` writer - P3OUT1"]
pub type P3OUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT2` reader - P3OUT2"]
pub type P3OUT2_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT2` writer - P3OUT2"]
pub type P3OUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT3` reader - P3OUT3"]
pub type P3OUT3_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT3` writer - P3OUT3"]
pub type P3OUT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT4` reader - P3OUT4"]
pub type P3OUT4_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT4` writer - P3OUT4"]
pub type P3OUT4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT5` reader - P3OUT5"]
pub type P3OUT5_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT5` writer - P3OUT5"]
pub type P3OUT5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT6` reader - P3OUT6"]
pub type P3OUT6_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT6` writer - P3OUT6"]
pub type P3OUT6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; # [doc = "Field `P3OUT7` reader - P3OUT7"]
pub type P3OUT7_R = crate :: BitReader < bool > ; # [doc = "Field `P3OUT7` writer - P3OUT7"]
pub type P3OUT7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3OUT0"]
# [inline (always)]
pub fn p3out0 (& self) -> P3OUT0_R { P3OUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3OUT1"]
# [inline (always)]
pub fn p3out1 (& self) -> P3OUT1_R { P3OUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3OUT2"]
# [inline (always)]
pub fn p3out2 (& self) -> P3OUT2_R { P3OUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3OUT3"]
# [inline (always)]
pub fn p3out3 (& self) -> P3OUT3_R { P3OUT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3OUT4"]
# [inline (always)]
pub fn p3out4 (& self) -> P3OUT4_R { P3OUT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3OUT5"]
# [inline (always)]
pub fn p3out5 (& self) -> P3OUT5_R { P3OUT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3OUT6"]
# [inline (always)]
pub fn p3out6 (& self) -> P3OUT6_R { P3OUT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3OUT7"]
# [inline (always)]
pub fn p3out7 (& self) -> P3OUT7_R { P3OUT7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3OUT0"]
# [inline (always)]
pub fn p3out0 (& mut self) -> P3OUT0_W < 0 > { P3OUT0_W :: new (self) } # [doc = "Bit 1 - P3OUT1"]
# [inline (always)]
pub fn p3out1 (& mut self) -> P3OUT1_W < 1 > { P3OUT1_W :: new (self) } # [doc = "Bit 2 - P3OUT2"]
# [inline (always)]
pub fn p3out2 (& mut self) -> P3OUT2_W < 2 > { P3OUT2_W :: new (self) } # [doc = "Bit 3 - P3OUT3"]
# [inline (always)]
pub fn p3out3 (& mut self) -> P3OUT3_W < 3 > { P3OUT3_W :: new (self) } # [doc = "Bit 4 - P3OUT4"]
# [inline (always)]
pub fn p3out4 (& mut self) -> P3OUT4_W < 4 > { P3OUT4_W :: new (self) } # [doc = "Bit 5 - P3OUT5"]
# [inline (always)]
pub fn p3out5 (& mut self) -> P3OUT5_W < 5 > { P3OUT5_W :: new (self) } # [doc = "Bit 6 - P3OUT6"]
# [inline (always)]
pub fn p3out6 (& mut self) -> P3OUT6_W < 6 > { P3OUT6_W :: new (self) } # [doc = "Bit 7 - P3OUT7"]
# [inline (always)]
pub fn p3out7 (& mut self) -> P3OUT7_W < 7 > { P3OUT7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3out](index.html) module"]
pub struct P3OUT_SPEC ; impl crate :: RegisterSpec for P3OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3out::R](R) reader structure"]
impl crate :: Readable for P3OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3out::W](W) writer structure"]
impl crate :: Writable for P3OUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3OUT to value 0"]
impl crate :: Resettable for P3OUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P3DIR register accessor: an alias for `Reg<P3DIR_SPEC>`"]
pub type P3DIR = crate :: Reg < p3dir :: P3DIR_SPEC > ; # [doc = "Port 3 Direction"]
pub mod p3dir { # [doc = "Register `P3DIR` reader"]
pub struct R (crate :: R < P3DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3DIR` writer"]
pub struct W (crate :: W < P3DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3DIR0` reader - P3DIR0"]
pub type P3DIR0_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR0` writer - P3DIR0"]
pub type P3DIR0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR1` reader - P3DIR1"]
pub type P3DIR1_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR1` writer - P3DIR1"]
pub type P3DIR1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR2` reader - P3DIR2"]
pub type P3DIR2_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR2` writer - P3DIR2"]
pub type P3DIR2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR3` reader - P3DIR3"]
pub type P3DIR3_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR3` writer - P3DIR3"]
pub type P3DIR3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR4` reader - P3DIR4"]
pub type P3DIR4_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR4` writer - P3DIR4"]
pub type P3DIR4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR5` reader - P3DIR5"]
pub type P3DIR5_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR5` writer - P3DIR5"]
pub type P3DIR5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR6` reader - P3DIR6"]
pub type P3DIR6_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR6` writer - P3DIR6"]
pub type P3DIR6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; # [doc = "Field `P3DIR7` reader - P3DIR7"]
pub type P3DIR7_R = crate :: BitReader < bool > ; # [doc = "Field `P3DIR7` writer - P3DIR7"]
pub type P3DIR7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3DIR0"]
# [inline (always)]
pub fn p3dir0 (& self) -> P3DIR0_R { P3DIR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3DIR1"]
# [inline (always)]
pub fn p3dir1 (& self) -> P3DIR1_R { P3DIR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3DIR2"]
# [inline (always)]
pub fn p3dir2 (& self) -> P3DIR2_R { P3DIR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3DIR3"]
# [inline (always)]
pub fn p3dir3 (& self) -> P3DIR3_R { P3DIR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3DIR4"]
# [inline (always)]
pub fn p3dir4 (& self) -> P3DIR4_R { P3DIR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3DIR5"]
# [inline (always)]
pub fn p3dir5 (& self) -> P3DIR5_R { P3DIR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3DIR6"]
# [inline (always)]
pub fn p3dir6 (& self) -> P3DIR6_R { P3DIR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3DIR7"]
# [inline (always)]
pub fn p3dir7 (& self) -> P3DIR7_R { P3DIR7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3DIR0"]
# [inline (always)]
pub fn p3dir0 (& mut self) -> P3DIR0_W < 0 > { P3DIR0_W :: new (self) } # [doc = "Bit 1 - P3DIR1"]
# [inline (always)]
pub fn p3dir1 (& mut self) -> P3DIR1_W < 1 > { P3DIR1_W :: new (self) } # [doc = "Bit 2 - P3DIR2"]
# [inline (always)]
pub fn p3dir2 (& mut self) -> P3DIR2_W < 2 > { P3DIR2_W :: new (self) } # [doc = "Bit 3 - P3DIR3"]
# [inline (always)]
pub fn p3dir3 (& mut self) -> P3DIR3_W < 3 > { P3DIR3_W :: new (self) } # [doc = "Bit 4 - P3DIR4"]
# [inline (always)]
pub fn p3dir4 (& mut self) -> P3DIR4_W < 4 > { P3DIR4_W :: new (self) } # [doc = "Bit 5 - P3DIR5"]
# [inline (always)]
pub fn p3dir5 (& mut self) -> P3DIR5_W < 5 > { P3DIR5_W :: new (self) } # [doc = "Bit 6 - P3DIR6"]
# [inline (always)]
pub fn p3dir6 (& mut self) -> P3DIR6_W < 6 > { P3DIR6_W :: new (self) } # [doc = "Bit 7 - P3DIR7"]
# [inline (always)]
pub fn p3dir7 (& mut self) -> P3DIR7_W < 7 > { P3DIR7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3dir](index.html) module"]
pub struct P3DIR_SPEC ; impl crate :: RegisterSpec for P3DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3dir::R](R) reader structure"]
impl crate :: Readable for P3DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3dir::W](W) writer structure"]
impl crate :: Writable for P3DIR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3DIR to value 0"]
impl crate :: Resettable for P3DIR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P3REN register accessor: an alias for `Reg<P3REN_SPEC>`"]
pub type P3REN = crate :: Reg < p3ren :: P3REN_SPEC > ; # [doc = "Port 3 Resistor Enable"]
pub mod p3ren { # [doc = "Register `P3REN` reader"]
pub struct R (crate :: R < P3REN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3REN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3REN_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3REN` writer"]
pub struct W (crate :: W < P3REN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3REN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3REN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3REN_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3REN0` reader - P3REN0"]
pub type P3REN0_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN0` writer - P3REN0"]
pub type P3REN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN1` reader - P3REN1"]
pub type P3REN1_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN1` writer - P3REN1"]
pub type P3REN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN2` reader - P3REN2"]
pub type P3REN2_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN2` writer - P3REN2"]
pub type P3REN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN3` reader - P3REN3"]
pub type P3REN3_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN3` writer - P3REN3"]
pub type P3REN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN4` reader - P3REN4"]
pub type P3REN4_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN4` writer - P3REN4"]
pub type P3REN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN5` reader - P3REN5"]
pub type P3REN5_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN5` writer - P3REN5"]
pub type P3REN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN6` reader - P3REN6"]
pub type P3REN6_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN6` writer - P3REN6"]
pub type P3REN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; # [doc = "Field `P3REN7` reader - P3REN7"]
pub type P3REN7_R = crate :: BitReader < bool > ; # [doc = "Field `P3REN7` writer - P3REN7"]
pub type P3REN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3REN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3REN0"]
# [inline (always)]
pub fn p3ren0 (& self) -> P3REN0_R { P3REN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3REN1"]
# [inline (always)]
pub fn p3ren1 (& self) -> P3REN1_R { P3REN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3REN2"]
# [inline (always)]
pub fn p3ren2 (& self) -> P3REN2_R { P3REN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3REN3"]
# [inline (always)]
pub fn p3ren3 (& self) -> P3REN3_R { P3REN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3REN4"]
# [inline (always)]
pub fn p3ren4 (& self) -> P3REN4_R { P3REN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3REN5"]
# [inline (always)]
pub fn p3ren5 (& self) -> P3REN5_R { P3REN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3REN6"]
# [inline (always)]
pub fn p3ren6 (& self) -> P3REN6_R { P3REN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3REN7"]
# [inline (always)]
pub fn p3ren7 (& self) -> P3REN7_R { P3REN7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3REN0"]
# [inline (always)]
pub fn p3ren0 (& mut self) -> P3REN0_W < 0 > { P3REN0_W :: new (self) } # [doc = "Bit 1 - P3REN1"]
# [inline (always)]
pub fn p3ren1 (& mut self) -> P3REN1_W < 1 > { P3REN1_W :: new (self) } # [doc = "Bit 2 - P3REN2"]
# [inline (always)]
pub fn p3ren2 (& mut self) -> P3REN2_W < 2 > { P3REN2_W :: new (self) } # [doc = "Bit 3 - P3REN3"]
# [inline (always)]
pub fn p3ren3 (& mut self) -> P3REN3_W < 3 > { P3REN3_W :: new (self) } # [doc = "Bit 4 - P3REN4"]
# [inline (always)]
pub fn p3ren4 (& mut self) -> P3REN4_W < 4 > { P3REN4_W :: new (self) } # [doc = "Bit 5 - P3REN5"]
# [inline (always)]
pub fn p3ren5 (& mut self) -> P3REN5_W < 5 > { P3REN5_W :: new (self) } # [doc = "Bit 6 - P3REN6"]
# [inline (always)]
pub fn p3ren6 (& mut self) -> P3REN6_W < 6 > { P3REN6_W :: new (self) } # [doc = "Bit 7 - P3REN7"]
# [inline (always)]
pub fn p3ren7 (& mut self) -> P3REN7_W < 7 > { P3REN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Resistor Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3ren](index.html) module"]
pub struct P3REN_SPEC ; impl crate :: RegisterSpec for P3REN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3ren::R](R) reader structure"]
impl crate :: Readable for P3REN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3ren::W](W) writer structure"]
impl crate :: Writable for P3REN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3REN to value 0"]
impl crate :: Resettable for P3REN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P3SEL0 register accessor: an alias for `Reg<P3SEL0_SPEC>`"]
pub type P3SEL0 = crate :: Reg < p3sel0 :: P3SEL0_SPEC > ; # [doc = "Port 3 Selection0"]
pub mod p3sel0 { # [doc = "Register `P3SEL0` reader"]
pub struct R (crate :: R < P3SEL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3SEL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3SEL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3SEL0` writer"]
pub struct W (crate :: W < P3SEL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3SEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3SEL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3SEL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3SEL0_0` reader - P3SEL0_0"]
pub type P3SEL0_0_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_0` writer - P3SEL0_0"]
pub type P3SEL0_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_1` reader - P3SEL0_1"]
pub type P3SEL0_1_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_1` writer - P3SEL0_1"]
pub type P3SEL0_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_2` reader - P3SEL0_2"]
pub type P3SEL0_2_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_2` writer - P3SEL0_2"]
pub type P3SEL0_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_3` reader - P3SEL0_3"]
pub type P3SEL0_3_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_3` writer - P3SEL0_3"]
pub type P3SEL0_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_4` reader - P3SEL0_4"]
pub type P3SEL0_4_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_4` writer - P3SEL0_4"]
pub type P3SEL0_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_5` reader - P3SEL0_5"]
pub type P3SEL0_5_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_5` writer - P3SEL0_5"]
pub type P3SEL0_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_6` reader - P3SEL0_6"]
pub type P3SEL0_6_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_6` writer - P3SEL0_6"]
pub type P3SEL0_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; # [doc = "Field `P3SEL0_7` reader - P3SEL0_7"]
pub type P3SEL0_7_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL0_7` writer - P3SEL0_7"]
pub type P3SEL0_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3SEL0_0"]
# [inline (always)]
pub fn p3sel0_0 (& self) -> P3SEL0_0_R { P3SEL0_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3SEL0_1"]
# [inline (always)]
pub fn p3sel0_1 (& self) -> P3SEL0_1_R { P3SEL0_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3SEL0_2"]
# [inline (always)]
pub fn p3sel0_2 (& self) -> P3SEL0_2_R { P3SEL0_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3SEL0_3"]
# [inline (always)]
pub fn p3sel0_3 (& self) -> P3SEL0_3_R { P3SEL0_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3SEL0_4"]
# [inline (always)]
pub fn p3sel0_4 (& self) -> P3SEL0_4_R { P3SEL0_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3SEL0_5"]
# [inline (always)]
pub fn p3sel0_5 (& self) -> P3SEL0_5_R { P3SEL0_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3SEL0_6"]
# [inline (always)]
pub fn p3sel0_6 (& self) -> P3SEL0_6_R { P3SEL0_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3SEL0_7"]
# [inline (always)]
pub fn p3sel0_7 (& self) -> P3SEL0_7_R { P3SEL0_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3SEL0_0"]
# [inline (always)]
pub fn p3sel0_0 (& mut self) -> P3SEL0_0_W < 0 > { P3SEL0_0_W :: new (self) } # [doc = "Bit 1 - P3SEL0_1"]
# [inline (always)]
pub fn p3sel0_1 (& mut self) -> P3SEL0_1_W < 1 > { P3SEL0_1_W :: new (self) } # [doc = "Bit 2 - P3SEL0_2"]
# [inline (always)]
pub fn p3sel0_2 (& mut self) -> P3SEL0_2_W < 2 > { P3SEL0_2_W :: new (self) } # [doc = "Bit 3 - P3SEL0_3"]
# [inline (always)]
pub fn p3sel0_3 (& mut self) -> P3SEL0_3_W < 3 > { P3SEL0_3_W :: new (self) } # [doc = "Bit 4 - P3SEL0_4"]
# [inline (always)]
pub fn p3sel0_4 (& mut self) -> P3SEL0_4_W < 4 > { P3SEL0_4_W :: new (self) } # [doc = "Bit 5 - P3SEL0_5"]
# [inline (always)]
pub fn p3sel0_5 (& mut self) -> P3SEL0_5_W < 5 > { P3SEL0_5_W :: new (self) } # [doc = "Bit 6 - P3SEL0_6"]
# [inline (always)]
pub fn p3sel0_6 (& mut self) -> P3SEL0_6_W < 6 > { P3SEL0_6_W :: new (self) } # [doc = "Bit 7 - P3SEL0_7"]
# [inline (always)]
pub fn p3sel0_7 (& mut self) -> P3SEL0_7_W < 7 > { P3SEL0_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Selection0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel0](index.html) module"]
pub struct P3SEL0_SPEC ; impl crate :: RegisterSpec for P3SEL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3sel0::R](R) reader structure"]
impl crate :: Readable for P3SEL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3sel0::W](W) writer structure"]
impl crate :: Writable for P3SEL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3SEL0 to value 0"]
impl crate :: Resettable for P3SEL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "P3SEL1 register accessor: an alias for `Reg<P3SEL1_SPEC>`"]
pub type P3SEL1 = crate :: Reg < p3sel1 :: P3SEL1_SPEC > ; # [doc = "Port 3 Selection1"]
pub mod p3sel1 { # [doc = "Register `P3SEL1` reader"]
pub struct R (crate :: R < P3SEL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < P3SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < P3SEL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < P3SEL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `P3SEL1` writer"]
pub struct W (crate :: W < P3SEL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < P3SEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < P3SEL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < P3SEL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `P3SEL1_0` reader - P3SEL1_0"]
pub type P3SEL1_0_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_0` writer - P3SEL1_0"]
pub type P3SEL1_0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_1` reader - P3SEL1_1"]
pub type P3SEL1_1_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_1` writer - P3SEL1_1"]
pub type P3SEL1_1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_2` reader - P3SEL1_2"]
pub type P3SEL1_2_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_2` writer - P3SEL1_2"]
pub type P3SEL1_2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_3` reader - P3SEL1_3"]
pub type P3SEL1_3_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_3` writer - P3SEL1_3"]
pub type P3SEL1_3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_4` reader - P3SEL1_4"]
pub type P3SEL1_4_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_4` writer - P3SEL1_4"]
pub type P3SEL1_4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_5` reader - P3SEL1_5"]
pub type P3SEL1_5_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_5` writer - P3SEL1_5"]
pub type P3SEL1_5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_6` reader - P3SEL1_6"]
pub type P3SEL1_6_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_6` writer - P3SEL1_6"]
pub type P3SEL1_6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; # [doc = "Field `P3SEL1_7` reader - P3SEL1_7"]
pub type P3SEL1_7_R = crate :: BitReader < bool > ; # [doc = "Field `P3SEL1_7` writer - P3SEL1_7"]
pub type P3SEL1_7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , P3SEL1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - P3SEL1_0"]
# [inline (always)]
pub fn p3sel1_0 (& self) -> P3SEL1_0_R { P3SEL1_0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - P3SEL1_1"]
# [inline (always)]
pub fn p3sel1_1 (& self) -> P3SEL1_1_R { P3SEL1_1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - P3SEL1_2"]
# [inline (always)]
pub fn p3sel1_2 (& self) -> P3SEL1_2_R { P3SEL1_2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - P3SEL1_3"]
# [inline (always)]
pub fn p3sel1_3 (& self) -> P3SEL1_3_R { P3SEL1_3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - P3SEL1_4"]
# [inline (always)]
pub fn p3sel1_4 (& self) -> P3SEL1_4_R { P3SEL1_4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - P3SEL1_5"]
# [inline (always)]
pub fn p3sel1_5 (& self) -> P3SEL1_5_R { P3SEL1_5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - P3SEL1_6"]
# [inline (always)]
pub fn p3sel1_6 (& self) -> P3SEL1_6_R { P3SEL1_6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - P3SEL1_7"]
# [inline (always)]
pub fn p3sel1_7 (& self) -> P3SEL1_7_R { P3SEL1_7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - P3SEL1_0"]
# [inline (always)]
pub fn p3sel1_0 (& mut self) -> P3SEL1_0_W < 0 > { P3SEL1_0_W :: new (self) } # [doc = "Bit 1 - P3SEL1_1"]
# [inline (always)]
pub fn p3sel1_1 (& mut self) -> P3SEL1_1_W < 1 > { P3SEL1_1_W :: new (self) } # [doc = "Bit 2 - P3SEL1_2"]
# [inline (always)]
pub fn p3sel1_2 (& mut self) -> P3SEL1_2_W < 2 > { P3SEL1_2_W :: new (self) } # [doc = "Bit 3 - P3SEL1_3"]
# [inline (always)]
pub fn p3sel1_3 (& mut self) -> P3SEL1_3_W < 3 > { P3SEL1_3_W :: new (self) } # [doc = "Bit 4 - P3SEL1_4"]
# [inline (always)]
pub fn p3sel1_4 (& mut self) -> P3SEL1_4_W < 4 > { P3SEL1_4_W :: new (self) } # [doc = "Bit 5 - P3SEL1_5"]
# [inline (always)]
pub fn p3sel1_5 (& mut self) -> P3SEL1_5_W < 5 > { P3SEL1_5_W :: new (self) } # [doc = "Bit 6 - P3SEL1_6"]
# [inline (always)]
pub fn p3sel1_6 (& mut self) -> P3SEL1_6_W < 6 > { P3SEL1_6_W :: new (self) } # [doc = "Bit 7 - P3SEL1_7"]
# [inline (always)]
pub fn p3sel1_7 (& mut self) -> P3SEL1_7_W < 7 > { P3SEL1_7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port 3 Selection1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [p3sel1](index.html) module"]
pub struct P3SEL1_SPEC ; impl crate :: RegisterSpec for P3SEL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [p3sel1::R](R) reader structure"]
impl crate :: Readable for P3SEL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [p3sel1::W](W) writer structure"]
impl crate :: Writable for P3SEL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets P3SEL1 to value 0"]
impl crate :: Resettable for P3SEL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_A0 UART Mode"]
pub struct USCI_A0_UART_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_A0_UART_MODE { } impl USCI_A0_UART_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_a0_uart_mode :: RegisterBlock = 0x0500 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_a0_uart_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_A0_UART_MODE { type Target = usci_a0_uart_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_A0_UART_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_A0_UART_MODE") . finish () } } # [doc = "USCI_A0 UART Mode"]
pub mod usci_a0_uart_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI A0 Control Register 1"]
pub uca0ctl1 : crate :: Reg < uca0ctl1 :: UCA0CTL1_SPEC > , # [doc = "0x01 - USCI A0 Control Register 0"]
pub uca0ctl0 : crate :: Reg < uca0ctl0 :: UCA0CTL0_SPEC > , # [doc = "0x02 - USCI A0 Control Word Register 1"]
pub uca0ctlw1 : crate :: Reg < uca0ctlw1 :: UCA0CTLW1_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x06 - USCI A0 Baud Rate 0"]
pub uca0br0 : crate :: Reg < uca0br0 :: UCA0BR0_SPEC > , # [doc = "0x07 - USCI A0 Baud Rate 1"]
pub uca0br1 : crate :: Reg < uca0br1 :: UCA0BR1_SPEC > , # [doc = "0x08 - USCI A0 Modulation Control"]
pub uca0mctlw : crate :: Reg < uca0mctlw :: UCA0MCTLW_SPEC > , # [doc = "0x0a - USCI A0 Status Register"]
pub uca0statw : crate :: Reg < uca0statw :: UCA0STATW_SPEC > , _reserved7 : [u8 ; 0x01]
, # [doc = "0x0c - USCI A0 Receive Buffer"]
pub uca0rxbuf : crate :: Reg < uca0rxbuf :: UCA0RXBUF_SPEC > , # [doc = "0x0e - USCI A0 Transmit Buffer"]
pub uca0txbuf : crate :: Reg < uca0txbuf :: UCA0TXBUF_SPEC > , # [doc = "0x10 - USCI A0 LIN Control"]
pub uca0abctl : crate :: Reg < uca0abctl :: UCA0ABCTL_SPEC > , _reserved10 : [u8 ; 0x01]
, # [doc = "0x12 - USCI A0 IrDA Transmit Control"]
pub uca0irtctl : crate :: Reg < uca0irtctl :: UCA0IRTCTL_SPEC > , # [doc = "0x13 - USCI A0 IrDA Receive Control"]
pub uca0irrctl : crate :: Reg < uca0irrctl :: UCA0IRRCTL_SPEC > , _reserved12 : [u8 ; 0x0a]
, # [doc = "0x1e - USCI A0 Interrupt Vector Register"]
pub uca0iv : crate :: Reg < uca0iv :: UCA0IV_SPEC > , } # [doc = "UCA0CTL1 register accessor: an alias for `Reg<UCA0CTL1_SPEC>`"]
pub type UCA0CTL1 = crate :: Reg < uca0ctl1 :: UCA0CTL1_SPEC > ; # [doc = "USCI A0 Control Register 1"]
pub mod uca0ctl1 { # [doc = "Register `UCA0CTL1` reader"]
pub struct R (crate :: R < UCA0CTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0CTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0CTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0CTL1` writer"]
pub struct W (crate :: W < UCA0CTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0CTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0CTL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctl1](index.html) module"]
pub struct UCA0CTL1_SPEC ; impl crate :: RegisterSpec for UCA0CTL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ctl1::R](R) reader structure"]
impl crate :: Readable for UCA0CTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ctl1::W](W) writer structure"]
impl crate :: Writable for UCA0CTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0CTL1 to value 0"]
impl crate :: Resettable for UCA0CTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0CTL0 register accessor: an alias for `Reg<UCA0CTL0_SPEC>`"]
pub type UCA0CTL0 = crate :: Reg < uca0ctl0 :: UCA0CTL0_SPEC > ; # [doc = "USCI A0 Control Register 0"]
pub mod uca0ctl0 { # [doc = "Register `UCA0CTL0` reader"]
pub struct R (crate :: R < UCA0CTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0CTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0CTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0CTL0` writer"]
pub struct W (crate :: W < UCA0CTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0CTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0CTL0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctl0](index.html) module"]
pub struct UCA0CTL0_SPEC ; impl crate :: RegisterSpec for UCA0CTL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ctl0::R](R) reader structure"]
impl crate :: Readable for UCA0CTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ctl0::W](W) writer structure"]
impl crate :: Writable for UCA0CTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0CTL0 to value 0"]
impl crate :: Resettable for UCA0CTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0BR0 register accessor: an alias for `Reg<UCA0BR0_SPEC>`"]
pub type UCA0BR0 = crate :: Reg < uca0br0 :: UCA0BR0_SPEC > ; # [doc = "USCI A0 Baud Rate 0"]
pub mod uca0br0 { # [doc = "Register `UCA0BR0` reader"]
pub struct R (crate :: R < UCA0BR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0BR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0BR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0BR0` writer"]
pub struct W (crate :: W < UCA0BR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0BR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0BR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0br0](index.html) module"]
pub struct UCA0BR0_SPEC ; impl crate :: RegisterSpec for UCA0BR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0br0::R](R) reader structure"]
impl crate :: Readable for UCA0BR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0br0::W](W) writer structure"]
impl crate :: Writable for UCA0BR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0BR0 to value 0"]
impl crate :: Resettable for UCA0BR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0BR1 register accessor: an alias for `Reg<UCA0BR1_SPEC>`"]
pub type UCA0BR1 = crate :: Reg < uca0br1 :: UCA0BR1_SPEC > ; # [doc = "USCI A0 Baud Rate 1"]
pub mod uca0br1 { # [doc = "Register `UCA0BR1` reader"]
pub struct R (crate :: R < UCA0BR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0BR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0BR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0BR1` writer"]
pub struct W (crate :: W < UCA0BR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0BR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0BR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0br1](index.html) module"]
pub struct UCA0BR1_SPEC ; impl crate :: RegisterSpec for UCA0BR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0br1::R](R) reader structure"]
impl crate :: Readable for UCA0BR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0br1::W](W) writer structure"]
impl crate :: Writable for UCA0BR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0BR1 to value 0"]
impl crate :: Resettable for UCA0BR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0STATW register accessor: an alias for `Reg<UCA0STATW_SPEC>`"]
pub type UCA0STATW = crate :: Reg < uca0statw :: UCA0STATW_SPEC > ; # [doc = "USCI A0 Status Register"]
pub mod uca0statw { # [doc = "Register `UCA0STATW` reader"]
pub struct R (crate :: R < UCA0STATW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0STATW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0STATW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0STATW_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0STATW` writer"]
pub struct W (crate :: W < UCA0STATW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0STATW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0STATW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0STATW_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBUSY` reader - USCI Busy Flag"]
pub type UCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `UCBUSY` writer - USCI Busy Flag"]
pub type UCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCADDR` reader - USCI Address received Flag"]
pub type UCADDR_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDR` writer - USCI Address received Flag"]
pub type UCADDR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCRXERR` reader - USCI RX Error Flag"]
pub type UCRXERR_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXERR` writer - USCI RX Error Flag"]
pub type UCRXERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCBRK` reader - USCI Break received"]
pub type UCBRK_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRK` writer - USCI Break received"]
pub type UCBRK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCPE` reader - USCI Parity Error Flag"]
pub type UCPE_R = crate :: BitReader < bool > ; # [doc = "Field `UCPE` writer - USCI Parity Error Flag"]
pub type UCPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCOE` reader - USCI Overrun Error Flag"]
pub type UCOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCOE` writer - USCI Overrun Error Flag"]
pub type UCOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCFE` reader - USCI Frame Error Flag"]
pub type UCFE_R = crate :: BitReader < bool > ; # [doc = "Field `UCFE` writer - USCI Frame Error Flag"]
pub type UCFE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; # [doc = "Field `UCLISTEN` reader - USCI Listen mode"]
pub type UCLISTEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCLISTEN` writer - USCI Listen mode"]
pub type UCLISTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& self) -> UCBUSY_R { UCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Address received Flag"]
# [inline (always)]
pub fn ucaddr (& self) -> UCADDR_R { UCADDR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - USCI RX Error Flag"]
# [inline (always)]
pub fn ucrxerr (& self) -> UCRXERR_R { UCRXERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - USCI Break received"]
# [inline (always)]
pub fn ucbrk (& self) -> UCBRK_R { UCBRK_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - USCI Parity Error Flag"]
# [inline (always)]
pub fn ucpe (& self) -> UCPE_R { UCPE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& self) -> UCOE_R { UCOE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& self) -> UCFE_R { UCFE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& self) -> UCLISTEN_R { UCLISTEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& mut self) -> UCBUSY_W < 0 > { UCBUSY_W :: new (self) } # [doc = "Bit 1 - USCI Address received Flag"]
# [inline (always)]
pub fn ucaddr (& mut self) -> UCADDR_W < 1 > { UCADDR_W :: new (self) } # [doc = "Bit 2 - USCI RX Error Flag"]
# [inline (always)]
pub fn ucrxerr (& mut self) -> UCRXERR_W < 2 > { UCRXERR_W :: new (self) } # [doc = "Bit 3 - USCI Break received"]
# [inline (always)]
pub fn ucbrk (& mut self) -> UCBRK_W < 3 > { UCBRK_W :: new (self) } # [doc = "Bit 4 - USCI Parity Error Flag"]
# [inline (always)]
pub fn ucpe (& mut self) -> UCPE_W < 4 > { UCPE_W :: new (self) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& mut self) -> UCOE_W < 5 > { UCOE_W :: new (self) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& mut self) -> UCFE_W < 6 > { UCFE_W :: new (self) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& mut self) -> UCLISTEN_W < 7 > { UCLISTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw](index.html) module"]
pub struct UCA0STATW_SPEC ; impl crate :: RegisterSpec for UCA0STATW_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0statw::R](R) reader structure"]
impl crate :: Readable for UCA0STATW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0statw::W](W) writer structure"]
impl crate :: Writable for UCA0STATW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0STATW to value 0"]
impl crate :: Resettable for UCA0STATW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0ABCTL register accessor: an alias for `Reg<UCA0ABCTL_SPEC>`"]
pub type UCA0ABCTL = crate :: Reg < uca0abctl :: UCA0ABCTL_SPEC > ; # [doc = "USCI A0 LIN Control"]
pub mod uca0abctl { # [doc = "Register `UCA0ABCTL` reader"]
pub struct R (crate :: R < UCA0ABCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0ABCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0ABCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0ABCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0ABCTL` writer"]
pub struct W (crate :: W < UCA0ABCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0ABCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0ABCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0ABCTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCABDEN` reader - Auto Baud Rate detect enable"]
pub type UCABDEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCABDEN` writer - Auto Baud Rate detect enable"]
pub type UCABDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0ABCTL_SPEC , bool , O > ; # [doc = "Field `UCBTOE` reader - Break Timeout error"]
pub type UCBTOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCBTOE` writer - Break Timeout error"]
pub type UCBTOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0ABCTL_SPEC , bool , O > ; # [doc = "Field `UCSTOE` reader - Sync-Field Timeout error"]
pub type UCSTOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTOE` writer - Sync-Field Timeout error"]
pub type UCSTOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0ABCTL_SPEC , bool , O > ; # [doc = "Field `UCDELIM0` reader - Break Sync Delimiter 0"]
pub type UCDELIM0_R = crate :: BitReader < bool > ; # [doc = "Field `UCDELIM0` writer - Break Sync Delimiter 0"]
pub type UCDELIM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0ABCTL_SPEC , bool , O > ; # [doc = "Field `UCDELIM1` reader - Break Sync Delimiter 1"]
pub type UCDELIM1_R = crate :: BitReader < bool > ; # [doc = "Field `UCDELIM1` writer - Break Sync Delimiter 1"]
pub type UCDELIM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0ABCTL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Auto Baud Rate detect enable"]
# [inline (always)]
pub fn ucabden (& self) -> UCABDEN_R { UCABDEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Break Timeout error"]
# [inline (always)]
pub fn ucbtoe (& self) -> UCBTOE_R { UCBTOE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Sync-Field Timeout error"]
# [inline (always)]
pub fn ucstoe (& self) -> UCSTOE_R { UCSTOE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Break Sync Delimiter 0"]
# [inline (always)]
pub fn ucdelim0 (& self) -> UCDELIM0_R { UCDELIM0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Break Sync Delimiter 1"]
# [inline (always)]
pub fn ucdelim1 (& self) -> UCDELIM1_R { UCDELIM1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Auto Baud Rate detect enable"]
# [inline (always)]
pub fn ucabden (& mut self) -> UCABDEN_W < 0 > { UCABDEN_W :: new (self) } # [doc = "Bit 2 - Break Timeout error"]
# [inline (always)]
pub fn ucbtoe (& mut self) -> UCBTOE_W < 2 > { UCBTOE_W :: new (self) } # [doc = "Bit 3 - Sync-Field Timeout error"]
# [inline (always)]
pub fn ucstoe (& mut self) -> UCSTOE_W < 3 > { UCSTOE_W :: new (self) } # [doc = "Bit 4 - Break Sync Delimiter 0"]
# [inline (always)]
pub fn ucdelim0 (& mut self) -> UCDELIM0_W < 4 > { UCDELIM0_W :: new (self) } # [doc = "Bit 5 - Break Sync Delimiter 1"]
# [inline (always)]
pub fn ucdelim1 (& mut self) -> UCDELIM1_W < 5 > { UCDELIM1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 LIN Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0abctl](index.html) module"]
pub struct UCA0ABCTL_SPEC ; impl crate :: RegisterSpec for UCA0ABCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0abctl::R](R) reader structure"]
impl crate :: Readable for UCA0ABCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0abctl::W](W) writer structure"]
impl crate :: Writable for UCA0ABCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0ABCTL to value 0"]
impl crate :: Resettable for UCA0ABCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IRTCTL register accessor: an alias for `Reg<UCA0IRTCTL_SPEC>`"]
pub type UCA0IRTCTL = crate :: Reg < uca0irtctl :: UCA0IRTCTL_SPEC > ; # [doc = "USCI A0 IrDA Transmit Control"]
pub mod uca0irtctl { # [doc = "Register `UCA0IRTCTL` reader"]
pub struct R (crate :: R < UCA0IRTCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IRTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IRTCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IRTCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IRTCTL` writer"]
pub struct W (crate :: W < UCA0IRTCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IRTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IRTCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IRTCTL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 IrDA Transmit Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0irtctl](index.html) module"]
pub struct UCA0IRTCTL_SPEC ; impl crate :: RegisterSpec for UCA0IRTCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0irtctl::R](R) reader structure"]
impl crate :: Readable for UCA0IRTCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0irtctl::W](W) writer structure"]
impl crate :: Writable for UCA0IRTCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IRTCTL to value 0"]
impl crate :: Resettable for UCA0IRTCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IRRCTL register accessor: an alias for `Reg<UCA0IRRCTL_SPEC>`"]
pub type UCA0IRRCTL = crate :: Reg < uca0irrctl :: UCA0IRRCTL_SPEC > ; # [doc = "USCI A0 IrDA Receive Control"]
pub mod uca0irrctl { # [doc = "Register `UCA0IRRCTL` reader"]
pub struct R (crate :: R < UCA0IRRCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IRRCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IRRCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IRRCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IRRCTL` writer"]
pub struct W (crate :: W < UCA0IRRCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IRRCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IRRCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IRRCTL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 IrDA Receive Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0irrctl](index.html) module"]
pub struct UCA0IRRCTL_SPEC ; impl crate :: RegisterSpec for UCA0IRRCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0irrctl::R](R) reader structure"]
impl crate :: Readable for UCA0IRRCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0irrctl::W](W) writer structure"]
impl crate :: Writable for UCA0IRRCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IRRCTL to value 0"]
impl crate :: Resettable for UCA0IRRCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0CTLW1 register accessor: an alias for `Reg<UCA0CTLW1_SPEC>`"]
pub type UCA0CTLW1 = crate :: Reg < uca0ctlw1 :: UCA0CTLW1_SPEC > ; # [doc = "USCI A0 Control Word Register 1"]
pub mod uca0ctlw1 { # [doc = "Register `UCA0CTLW1` reader"]
pub struct R (crate :: R < UCA0CTLW1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0CTLW1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0CTLW1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0CTLW1` writer"]
pub struct W (crate :: W < UCA0CTLW1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0CTLW1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0CTLW1_SPEC >) -> Self { W (writer) } } # [doc = "USCI Deglitch Time Bit 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCGLIT_A { # [doc = "0: USCI Deglitch time: 0"]
UCGLIT_0 = 0 , # [doc = "1: USCI Deglitch time: 1"]
UCGLIT_1 = 1 , # [doc = "2: USCI Deglitch time: 2"]
UCGLIT_2 = 2 , # [doc = "3: USCI Deglitch time: 3"]
UCGLIT_3 = 3 , } impl From < UCGLIT_A > for u8 { # [inline (always)]
fn from (variant : UCGLIT_A) -> Self { variant as _ } } # [doc = "Field `UCGLIT` reader - USCI Deglitch Time Bit 1"]
pub type UCGLIT_R = crate :: FieldReader < u8 , UCGLIT_A > ; impl UCGLIT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCGLIT_0`"]
# [inline (always)]
pub fn is_ucglit_0 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [doc = "Checks if the value of the field is `UCGLIT_1`"]
# [inline (always)]
pub fn is_ucglit_1 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [doc = "Checks if the value of the field is `UCGLIT_2`"]
# [inline (always)]
pub fn is_ucglit_2 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [doc = "Checks if the value of the field is `UCGLIT_3`"]
# [inline (always)]
pub fn is_ucglit_3 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_3 } } # [doc = "Field `UCGLIT` writer - USCI Deglitch Time Bit 1"]
pub type UCGLIT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCA0CTLW1_SPEC , u8 , UCGLIT_A , 2 , O > ; impl < 'a , const O : u8 > UCGLIT_W < 'a , O > { # [doc = "USCI Deglitch time: 0"]
# [inline (always)]
pub fn ucglit_0 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_0) } # [doc = "USCI Deglitch time: 1"]
# [inline (always)]
pub fn ucglit_1 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_1) } # [doc = "USCI Deglitch time: 2"]
# [inline (always)]
pub fn ucglit_2 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_2) } # [doc = "USCI Deglitch time: 3"]
# [inline (always)]
pub fn ucglit_3 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_3) } } impl R { # [doc = "Bits 0:1 - USCI Deglitch Time Bit 1"]
# [inline (always)]
pub fn ucglit (& self) -> UCGLIT_R { UCGLIT_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1 - USCI Deglitch Time Bit 1"]
# [inline (always)]
pub fn ucglit (& mut self) -> UCGLIT_W < 0 > { UCGLIT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctlw1](index.html) module"]
pub struct UCA0CTLW1_SPEC ; impl crate :: RegisterSpec for UCA0CTLW1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0ctlw1::R](R) reader structure"]
impl crate :: Readable for UCA0CTLW1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ctlw1::W](W) writer structure"]
impl crate :: Writable for UCA0CTLW1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0CTLW1 to value 0"]
impl crate :: Resettable for UCA0CTLW1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0MCTLW register accessor: an alias for `Reg<UCA0MCTLW_SPEC>`"]
pub type UCA0MCTLW = crate :: Reg < uca0mctlw :: UCA0MCTLW_SPEC > ; # [doc = "USCI A0 Modulation Control"]
pub mod uca0mctlw { # [doc = "Register `UCA0MCTLW` reader"]
pub struct R (crate :: R < UCA0MCTLW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0MCTLW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0MCTLW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0MCTLW_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0MCTLW` writer"]
pub struct W (crate :: W < UCA0MCTLW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0MCTLW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0MCTLW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0MCTLW_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOS16` reader - USCI 16-times Oversampling enable"]
pub type UCOS16_R = crate :: BitReader < bool > ; # [doc = "Field `UCOS16` writer - USCI 16-times Oversampling enable"]
pub type UCOS16_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "USCI First Stage Modulation Select 3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCBRF_A { # [doc = "0: USCI First Stage Modulation: 0"]
UCBRF_0 = 0 , # [doc = "1: USCI First Stage Modulation: 1"]
UCBRF_1 = 1 , # [doc = "2: USCI First Stage Modulation: 2"]
UCBRF_2 = 2 , # [doc = "3: USCI First Stage Modulation: 3"]
UCBRF_3 = 3 , # [doc = "4: USCI First Stage Modulation: 4"]
UCBRF_4 = 4 , # [doc = "5: USCI First Stage Modulation: 5"]
UCBRF_5 = 5 , # [doc = "6: USCI First Stage Modulation: 6"]
UCBRF_6 = 6 , # [doc = "7: USCI First Stage Modulation: 7"]
UCBRF_7 = 7 , # [doc = "8: USCI First Stage Modulation: 8"]
UCBRF_8 = 8 , # [doc = "9: USCI First Stage Modulation: 9"]
UCBRF_9 = 9 , # [doc = "10: USCI First Stage Modulation: A"]
UCBRF_10 = 10 , # [doc = "11: USCI First Stage Modulation: B"]
UCBRF_11 = 11 , # [doc = "12: USCI First Stage Modulation: C"]
UCBRF_12 = 12 , # [doc = "13: USCI First Stage Modulation: D"]
UCBRF_13 = 13 , # [doc = "14: USCI First Stage Modulation: E"]
UCBRF_14 = 14 , # [doc = "15: USCI First Stage Modulation: F"]
UCBRF_15 = 15 , } impl From < UCBRF_A > for u8 { # [inline (always)]
fn from (variant : UCBRF_A) -> Self { variant as _ } } # [doc = "Field `UCBRF` reader - USCI First Stage Modulation Select 3"]
pub type UCBRF_R = crate :: FieldReader < u8 , UCBRF_A > ; impl UCBRF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCBRF_A { match self . bits { 0 => UCBRF_A :: UCBRF_0 , 1 => UCBRF_A :: UCBRF_1 , 2 => UCBRF_A :: UCBRF_2 , 3 => UCBRF_A :: UCBRF_3 , 4 => UCBRF_A :: UCBRF_4 , 5 => UCBRF_A :: UCBRF_5 , 6 => UCBRF_A :: UCBRF_6 , 7 => UCBRF_A :: UCBRF_7 , 8 => UCBRF_A :: UCBRF_8 , 9 => UCBRF_A :: UCBRF_9 , 10 => UCBRF_A :: UCBRF_10 , 11 => UCBRF_A :: UCBRF_11 , 12 => UCBRF_A :: UCBRF_12 , 13 => UCBRF_A :: UCBRF_13 , 14 => UCBRF_A :: UCBRF_14 , 15 => UCBRF_A :: UCBRF_15 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCBRF_0`"]
# [inline (always)]
pub fn is_ucbrf_0 (& self) -> bool { * self == UCBRF_A :: UCBRF_0 } # [doc = "Checks if the value of the field is `UCBRF_1`"]
# [inline (always)]
pub fn is_ucbrf_1 (& self) -> bool { * self == UCBRF_A :: UCBRF_1 } # [doc = "Checks if the value of the field is `UCBRF_2`"]
# [inline (always)]
pub fn is_ucbrf_2 (& self) -> bool { * self == UCBRF_A :: UCBRF_2 } # [doc = "Checks if the value of the field is `UCBRF_3`"]
# [inline (always)]
pub fn is_ucbrf_3 (& self) -> bool { * self == UCBRF_A :: UCBRF_3 } # [doc = "Checks if the value of the field is `UCBRF_4`"]
# [inline (always)]
pub fn is_ucbrf_4 (& self) -> bool { * self == UCBRF_A :: UCBRF_4 } # [doc = "Checks if the value of the field is `UCBRF_5`"]
# [inline (always)]
pub fn is_ucbrf_5 (& self) -> bool { * self == UCBRF_A :: UCBRF_5 } # [doc = "Checks if the value of the field is `UCBRF_6`"]
# [inline (always)]
pub fn is_ucbrf_6 (& self) -> bool { * self == UCBRF_A :: UCBRF_6 } # [doc = "Checks if the value of the field is `UCBRF_7`"]
# [inline (always)]
pub fn is_ucbrf_7 (& self) -> bool { * self == UCBRF_A :: UCBRF_7 } # [doc = "Checks if the value of the field is `UCBRF_8`"]
# [inline (always)]
pub fn is_ucbrf_8 (& self) -> bool { * self == UCBRF_A :: UCBRF_8 } # [doc = "Checks if the value of the field is `UCBRF_9`"]
# [inline (always)]
pub fn is_ucbrf_9 (& self) -> bool { * self == UCBRF_A :: UCBRF_9 } # [doc = "Checks if the value of the field is `UCBRF_10`"]
# [inline (always)]
pub fn is_ucbrf_10 (& self) -> bool { * self == UCBRF_A :: UCBRF_10 } # [doc = "Checks if the value of the field is `UCBRF_11`"]
# [inline (always)]
pub fn is_ucbrf_11 (& self) -> bool { * self == UCBRF_A :: UCBRF_11 } # [doc = "Checks if the value of the field is `UCBRF_12`"]
# [inline (always)]
pub fn is_ucbrf_12 (& self) -> bool { * self == UCBRF_A :: UCBRF_12 } # [doc = "Checks if the value of the field is `UCBRF_13`"]
# [inline (always)]
pub fn is_ucbrf_13 (& self) -> bool { * self == UCBRF_A :: UCBRF_13 } # [doc = "Checks if the value of the field is `UCBRF_14`"]
# [inline (always)]
pub fn is_ucbrf_14 (& self) -> bool { * self == UCBRF_A :: UCBRF_14 } # [doc = "Checks if the value of the field is `UCBRF_15`"]
# [inline (always)]
pub fn is_ucbrf_15 (& self) -> bool { * self == UCBRF_A :: UCBRF_15 } } # [doc = "Field `UCBRF` writer - USCI First Stage Modulation Select 3"]
pub type UCBRF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCA0MCTLW_SPEC , u8 , UCBRF_A , 4 , O > ; impl < 'a , const O : u8 > UCBRF_W < 'a , O > { # [doc = "USCI First Stage Modulation: 0"]
# [inline (always)]
pub fn ucbrf_0 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_0) } # [doc = "USCI First Stage Modulation: 1"]
# [inline (always)]
pub fn ucbrf_1 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_1) } # [doc = "USCI First Stage Modulation: 2"]
# [inline (always)]
pub fn ucbrf_2 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_2) } # [doc = "USCI First Stage Modulation: 3"]
# [inline (always)]
pub fn ucbrf_3 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_3) } # [doc = "USCI First Stage Modulation: 4"]
# [inline (always)]
pub fn ucbrf_4 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_4) } # [doc = "USCI First Stage Modulation: 5"]
# [inline (always)]
pub fn ucbrf_5 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_5) } # [doc = "USCI First Stage Modulation: 6"]
# [inline (always)]
pub fn ucbrf_6 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_6) } # [doc = "USCI First Stage Modulation: 7"]
# [inline (always)]
pub fn ucbrf_7 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_7) } # [doc = "USCI First Stage Modulation: 8"]
# [inline (always)]
pub fn ucbrf_8 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_8) } # [doc = "USCI First Stage Modulation: 9"]
# [inline (always)]
pub fn ucbrf_9 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_9) } # [doc = "USCI First Stage Modulation: A"]
# [inline (always)]
pub fn ucbrf_10 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_10) } # [doc = "USCI First Stage Modulation: B"]
# [inline (always)]
pub fn ucbrf_11 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_11) } # [doc = "USCI First Stage Modulation: C"]
# [inline (always)]
pub fn ucbrf_12 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_12) } # [doc = "USCI First Stage Modulation: D"]
# [inline (always)]
pub fn ucbrf_13 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_13) } # [doc = "USCI First Stage Modulation: E"]
# [inline (always)]
pub fn ucbrf_14 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_14) } # [doc = "USCI First Stage Modulation: F"]
# [inline (always)]
pub fn ucbrf_15 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_15) } } # [doc = "Field `UCBRS0` reader - USCI Second Stage Modulation Select 0"]
pub type UCBRS0_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS0` writer - USCI Second Stage Modulation Select 0"]
pub type UCBRS0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS1` reader - USCI Second Stage Modulation Select 1"]
pub type UCBRS1_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS1` writer - USCI Second Stage Modulation Select 1"]
pub type UCBRS1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS2` reader - USCI Second Stage Modulation Select 2"]
pub type UCBRS2_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS2` writer - USCI Second Stage Modulation Select 2"]
pub type UCBRS2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS3` reader - USCI Second Stage Modulation Select 3"]
pub type UCBRS3_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS3` writer - USCI Second Stage Modulation Select 3"]
pub type UCBRS3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS4` reader - USCI Second Stage Modulation Select 4"]
pub type UCBRS4_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS4` writer - USCI Second Stage Modulation Select 4"]
pub type UCBRS4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS5` reader - USCI Second Stage Modulation Select 5"]
pub type UCBRS5_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS5` writer - USCI Second Stage Modulation Select 5"]
pub type UCBRS5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS6` reader - USCI Second Stage Modulation Select 6"]
pub type UCBRS6_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS6` writer - USCI Second Stage Modulation Select 6"]
pub type UCBRS6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS7` reader - USCI Second Stage Modulation Select 7"]
pub type UCBRS7_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS7` writer - USCI Second Stage Modulation Select 7"]
pub type UCBRS7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA0MCTLW_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI 16-times Oversampling enable"]
# [inline (always)]
pub fn ucos16 (& self) -> UCOS16_R { UCOS16_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrf (& self) -> UCBRF_R { UCBRF_R :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bit 8 - USCI Second Stage Modulation Select 0"]
# [inline (always)]
pub fn ucbrs0 (& self) -> UCBRS0_R { UCBRS0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - USCI Second Stage Modulation Select 1"]
# [inline (always)]
pub fn ucbrs1 (& self) -> UCBRS1_R { UCBRS1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - USCI Second Stage Modulation Select 2"]
# [inline (always)]
pub fn ucbrs2 (& self) -> UCBRS2_R { UCBRS2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - USCI Second Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrs3 (& self) -> UCBRS3_R { UCBRS3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - USCI Second Stage Modulation Select 4"]
# [inline (always)]
pub fn ucbrs4 (& self) -> UCBRS4_R { UCBRS4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - USCI Second Stage Modulation Select 5"]
# [inline (always)]
pub fn ucbrs5 (& self) -> UCBRS5_R { UCBRS5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - USCI Second Stage Modulation Select 6"]
# [inline (always)]
pub fn ucbrs6 (& self) -> UCBRS6_R { UCBRS6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - USCI Second Stage Modulation Select 7"]
# [inline (always)]
pub fn ucbrs7 (& self) -> UCBRS7_R { UCBRS7_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI 16-times Oversampling enable"]
# [inline (always)]
pub fn ucos16 (& mut self) -> UCOS16_W < 0 > { UCOS16_W :: new (self) } # [doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrf (& mut self) -> UCBRF_W < 4 > { UCBRF_W :: new (self) } # [doc = "Bit 8 - USCI Second Stage Modulation Select 0"]
# [inline (always)]
pub fn ucbrs0 (& mut self) -> UCBRS0_W < 8 > { UCBRS0_W :: new (self) } # [doc = "Bit 9 - USCI Second Stage Modulation Select 1"]
# [inline (always)]
pub fn ucbrs1 (& mut self) -> UCBRS1_W < 9 > { UCBRS1_W :: new (self) } # [doc = "Bit 10 - USCI Second Stage Modulation Select 2"]
# [inline (always)]
pub fn ucbrs2 (& mut self) -> UCBRS2_W < 10 > { UCBRS2_W :: new (self) } # [doc = "Bit 11 - USCI Second Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrs3 (& mut self) -> UCBRS3_W < 11 > { UCBRS3_W :: new (self) } # [doc = "Bit 12 - USCI Second Stage Modulation Select 4"]
# [inline (always)]
pub fn ucbrs4 (& mut self) -> UCBRS4_W < 12 > { UCBRS4_W :: new (self) } # [doc = "Bit 13 - USCI Second Stage Modulation Select 5"]
# [inline (always)]
pub fn ucbrs5 (& mut self) -> UCBRS5_W < 13 > { UCBRS5_W :: new (self) } # [doc = "Bit 14 - USCI Second Stage Modulation Select 6"]
# [inline (always)]
pub fn ucbrs6 (& mut self) -> UCBRS6_W < 14 > { UCBRS6_W :: new (self) } # [doc = "Bit 15 - USCI Second Stage Modulation Select 7"]
# [inline (always)]
pub fn ucbrs7 (& mut self) -> UCBRS7_W < 15 > { UCBRS7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Modulation Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0mctlw](index.html) module"]
pub struct UCA0MCTLW_SPEC ; impl crate :: RegisterSpec for UCA0MCTLW_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0mctlw::R](R) reader structure"]
impl crate :: Readable for UCA0MCTLW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0mctlw::W](W) writer structure"]
impl crate :: Writable for UCA0MCTLW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0MCTLW to value 0"]
impl crate :: Resettable for UCA0MCTLW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0RXBUF register accessor: an alias for `Reg<UCA0RXBUF_SPEC>`"]
pub type UCA0RXBUF = crate :: Reg < uca0rxbuf :: UCA0RXBUF_SPEC > ; # [doc = "USCI A0 Receive Buffer"]
pub mod uca0rxbuf { # [doc = "Register `UCA0RXBUF` reader"]
pub struct R (crate :: R < UCA0RXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0RXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0RXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0RXBUF` writer"]
pub struct W (crate :: W < UCA0RXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0RXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0RXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf](index.html) module"]
pub struct UCA0RXBUF_SPEC ; impl crate :: RegisterSpec for UCA0RXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0rxbuf::R](R) reader structure"]
impl crate :: Readable for UCA0RXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0rxbuf::W](W) writer structure"]
impl crate :: Writable for UCA0RXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0RXBUF to value 0"]
impl crate :: Resettable for UCA0RXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0TXBUF register accessor: an alias for `Reg<UCA0TXBUF_SPEC>`"]
pub type UCA0TXBUF = crate :: Reg < uca0txbuf :: UCA0TXBUF_SPEC > ; # [doc = "USCI A0 Transmit Buffer"]
pub mod uca0txbuf { # [doc = "Register `UCA0TXBUF` reader"]
pub struct R (crate :: R < UCA0TXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0TXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0TXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0TXBUF` writer"]
pub struct W (crate :: W < UCA0TXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0TXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0TXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf](index.html) module"]
pub struct UCA0TXBUF_SPEC ; impl crate :: RegisterSpec for UCA0TXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0txbuf::R](R) reader structure"]
impl crate :: Readable for UCA0TXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0txbuf::W](W) writer structure"]
impl crate :: Writable for UCA0TXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0TXBUF to value 0"]
impl crate :: Resettable for UCA0TXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IV register accessor: an alias for `Reg<UCA0IV_SPEC>`"]
pub type UCA0IV = crate :: Reg < uca0iv :: UCA0IV_SPEC > ; # [doc = "USCI A0 Interrupt Vector Register"]
pub mod uca0iv { # [doc = "Register `UCA0IV` reader"]
pub struct R (crate :: R < UCA0IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IV` writer"]
pub struct W (crate :: W < UCA0IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv](index.html) module"]
pub struct UCA0IV_SPEC ; impl crate :: RegisterSpec for UCA0IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0iv::R](R) reader structure"]
impl crate :: Readable for UCA0IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0iv::W](W) writer structure"]
impl crate :: Writable for UCA0IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IV to value 0"]
impl crate :: Resettable for UCA0IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_A0 SPI Mode"]
pub struct USCI_A0_SPI_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_A0_SPI_MODE { } impl USCI_A0_SPI_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_a0_spi_mode :: RegisterBlock = 0x0500 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_a0_spi_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_A0_SPI_MODE { type Target = usci_a0_spi_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_A0_SPI_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_A0_SPI_MODE") . finish () } } # [doc = "USCI_A0 SPI Mode"]
pub mod usci_a0_spi_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI A0 Control Register 1"]
pub uca0ctl1_spi : crate :: Reg < uca0ctl1_spi :: UCA0CTL1_SPI_SPEC > , # [doc = "0x01 - USCI A0 Control Register 0"]
pub uca0ctl0_spi : crate :: Reg < uca0ctl0_spi :: UCA0CTL0_SPI_SPEC > , _reserved2 : [u8 ; 0x04]
, # [doc = "0x06 - USCI A0 Baud Rate 0"]
pub uca0br0_spi : crate :: Reg < uca0br0_spi :: UCA0BR0_SPI_SPEC > , # [doc = "0x07 - USCI A0 Baud Rate 1"]
pub uca0br1_spi : crate :: Reg < uca0br1_spi :: UCA0BR1_SPI_SPEC > , _reserved4 : [u8 ; 0x02]
, # [doc = "0x0a - USCI A0 Status Register"]
pub uca0statw_spi : crate :: Reg < uca0statw_spi :: UCA0STATW_SPI_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x0c - USCI A0 Receive Buffer"]
pub uca0rxbuf_spi : crate :: Reg < uca0rxbuf_spi :: UCA0RXBUF_SPI_SPEC > , # [doc = "0x0e - USCI A0 Transmit Buffer"]
pub uca0txbuf_spi : crate :: Reg < uca0txbuf_spi :: UCA0TXBUF_SPI_SPEC > , _reserved7 : [u8 ; 0x0a]
, # [doc = "0x1a - USCI A0 Interrupt Enable Register"]
pub uca0ie_spi : crate :: Reg < uca0ie_spi :: UCA0IE_SPI_SPEC > , _reserved8 : [u8 ; 0x01]
, # [doc = "0x1c - USCI A0 Interrupt Flags Register"]
pub uca0ifg_spi : crate :: Reg < uca0ifg_spi :: UCA0IFG_SPI_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x1e - USCI A0 Interrupt Vector Register"]
pub uca0iv_spi : crate :: Reg < uca0iv_spi :: UCA0IV_SPI_SPEC > , } # [doc = "UCA0CTL1_SPI register accessor: an alias for `Reg<UCA0CTL1_SPI_SPEC>`"]
pub type UCA0CTL1_SPI = crate :: Reg < uca0ctl1_spi :: UCA0CTL1_SPI_SPEC > ; # [doc = "USCI A0 Control Register 1"]
pub mod uca0ctl1_spi { # [doc = "Register `UCA0CTL1_SPI` reader"]
pub struct R (crate :: R < UCA0CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0CTL1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0CTL1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0CTL1_SPI` writer"]
pub struct W (crate :: W < UCA0CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0CTL1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0CTL1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctl1_spi](index.html) module"]
pub struct UCA0CTL1_SPI_SPEC ; impl crate :: RegisterSpec for UCA0CTL1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ctl1_spi::R](R) reader structure"]
impl crate :: Readable for UCA0CTL1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ctl1_spi::W](W) writer structure"]
impl crate :: Writable for UCA0CTL1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0CTL1_SPI to value 0"]
impl crate :: Resettable for UCA0CTL1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0CTL0_SPI register accessor: an alias for `Reg<UCA0CTL0_SPI_SPEC>`"]
pub type UCA0CTL0_SPI = crate :: Reg < uca0ctl0_spi :: UCA0CTL0_SPI_SPEC > ; # [doc = "USCI A0 Control Register 0"]
pub mod uca0ctl0_spi { # [doc = "Register `UCA0CTL0_SPI` reader"]
pub struct R (crate :: R < UCA0CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0CTL0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0CTL0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0CTL0_SPI` writer"]
pub struct W (crate :: W < UCA0CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0CTL0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0CTL0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ctl0_spi](index.html) module"]
pub struct UCA0CTL0_SPI_SPEC ; impl crate :: RegisterSpec for UCA0CTL0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ctl0_spi::R](R) reader structure"]
impl crate :: Readable for UCA0CTL0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ctl0_spi::W](W) writer structure"]
impl crate :: Writable for UCA0CTL0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0CTL0_SPI to value 0"]
impl crate :: Resettable for UCA0CTL0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0BR0_SPI register accessor: an alias for `Reg<UCA0BR0_SPI_SPEC>`"]
pub type UCA0BR0_SPI = crate :: Reg < uca0br0_spi :: UCA0BR0_SPI_SPEC > ; # [doc = "USCI A0 Baud Rate 0"]
pub mod uca0br0_spi { # [doc = "Register `UCA0BR0_SPI` reader"]
pub struct R (crate :: R < UCA0BR0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0BR0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0BR0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0BR0_SPI` writer"]
pub struct W (crate :: W < UCA0BR0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0BR0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0BR0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0br0_spi](index.html) module"]
pub struct UCA0BR0_SPI_SPEC ; impl crate :: RegisterSpec for UCA0BR0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0br0_spi::R](R) reader structure"]
impl crate :: Readable for UCA0BR0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0br0_spi::W](W) writer structure"]
impl crate :: Writable for UCA0BR0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0BR0_SPI to value 0"]
impl crate :: Resettable for UCA0BR0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0BR1_SPI register accessor: an alias for `Reg<UCA0BR1_SPI_SPEC>`"]
pub type UCA0BR1_SPI = crate :: Reg < uca0br1_spi :: UCA0BR1_SPI_SPEC > ; # [doc = "USCI A0 Baud Rate 1"]
pub mod uca0br1_spi { # [doc = "Register `UCA0BR1_SPI` reader"]
pub struct R (crate :: R < UCA0BR1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0BR1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0BR1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0BR1_SPI` writer"]
pub struct W (crate :: W < UCA0BR1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0BR1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0BR1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0br1_spi](index.html) module"]
pub struct UCA0BR1_SPI_SPEC ; impl crate :: RegisterSpec for UCA0BR1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0br1_spi::R](R) reader structure"]
impl crate :: Readable for UCA0BR1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0br1_spi::W](W) writer structure"]
impl crate :: Writable for UCA0BR1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0BR1_SPI to value 0"]
impl crate :: Resettable for UCA0BR1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0STATW_SPI register accessor: an alias for `Reg<UCA0STATW_SPI_SPEC>`"]
pub type UCA0STATW_SPI = crate :: Reg < uca0statw_spi :: UCA0STATW_SPI_SPEC > ; # [doc = "USCI A0 Status Register"]
pub mod uca0statw_spi { # [doc = "Register `UCA0STATW_SPI` reader"]
pub struct R (crate :: R < UCA0STATW_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0STATW_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0STATW_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0STATW_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0STATW_SPI` writer"]
pub struct W (crate :: W < UCA0STATW_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0STATW_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0STATW_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0STATW_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBUSY` reader - USCI Busy Flag"]
pub type UCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `UCBUSY` writer - USCI Busy Flag"]
pub type UCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCOE` reader - USCI Overrun Error Flag"]
pub type UCOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCOE` writer - USCI Overrun Error Flag"]
pub type UCOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCFE` reader - USCI Frame Error Flag"]
pub type UCFE_R = crate :: BitReader < bool > ; # [doc = "Field `UCFE` writer - USCI Frame Error Flag"]
pub type UCFE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCLISTEN` reader - USCI Listen mode"]
pub type UCLISTEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCLISTEN` writer - USCI Listen mode"]
pub type UCLISTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0STATW_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& self) -> UCBUSY_R { UCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& self) -> UCOE_R { UCOE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& self) -> UCFE_R { UCFE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& self) -> UCLISTEN_R { UCLISTEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& mut self) -> UCBUSY_W < 0 > { UCBUSY_W :: new (self) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& mut self) -> UCOE_W < 5 > { UCOE_W :: new (self) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& mut self) -> UCFE_W < 6 > { UCFE_W :: new (self) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& mut self) -> UCLISTEN_W < 7 > { UCLISTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0statw_spi](index.html) module"]
pub struct UCA0STATW_SPI_SPEC ; impl crate :: RegisterSpec for UCA0STATW_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0statw_spi::R](R) reader structure"]
impl crate :: Readable for UCA0STATW_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0statw_spi::W](W) writer structure"]
impl crate :: Writable for UCA0STATW_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0STATW_SPI to value 0"]
impl crate :: Resettable for UCA0STATW_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IE_SPI register accessor: an alias for `Reg<UCA0IE_SPI_SPEC>`"]
pub type UCA0IE_SPI = crate :: Reg < uca0ie_spi :: UCA0IE_SPI_SPEC > ; # [doc = "USCI A0 Interrupt Enable Register"]
pub mod uca0ie_spi { # [doc = "Register `UCA0IE_SPI` reader"]
pub struct R (crate :: R < UCA0IE_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IE_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IE_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IE_SPI` writer"]
pub struct W (crate :: W < UCA0IE_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IE_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IE_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIE` reader - USCI Receive Interrupt Enable"]
pub type UCRXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE` writer - USCI Receive Interrupt Enable"]
pub type UCRXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0IE_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIE` reader - USCI Transmit Interrupt Enable"]
pub type UCTXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE` writer - USCI Transmit Interrupt Enable"]
pub type UCTXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0IE_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& self) -> UCRXIE_R { UCRXIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& self) -> UCTXIE_R { UCTXIE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& mut self) -> UCRXIE_W < 0 > { UCRXIE_W :: new (self) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& mut self) -> UCTXIE_W < 1 > { UCTXIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ie_spi](index.html) module"]
pub struct UCA0IE_SPI_SPEC ; impl crate :: RegisterSpec for UCA0IE_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ie_spi::R](R) reader structure"]
impl crate :: Readable for UCA0IE_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ie_spi::W](W) writer structure"]
impl crate :: Writable for UCA0IE_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IE_SPI to value 0"]
impl crate :: Resettable for UCA0IE_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IFG_SPI register accessor: an alias for `Reg<UCA0IFG_SPI_SPEC>`"]
pub type UCA0IFG_SPI = crate :: Reg < uca0ifg_spi :: UCA0IFG_SPI_SPEC > ; # [doc = "USCI A0 Interrupt Flags Register"]
pub mod uca0ifg_spi { # [doc = "Register `UCA0IFG_SPI` reader"]
pub struct R (crate :: R < UCA0IFG_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IFG_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IFG_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IFG_SPI` writer"]
pub struct W (crate :: W < UCA0IFG_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IFG_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IFG_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIFG` reader - SPI Receive Interrupt Flag"]
pub type UCRXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG` writer - SPI Receive Interrupt Flag"]
pub type UCRXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0IFG_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIFG` reader - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG` writer - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA0IFG_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& self) -> UCRXIFG_R { UCRXIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& self) -> UCTXIFG_R { UCTXIFG_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& mut self) -> UCRXIFG_W < 0 > { UCRXIFG_W :: new (self) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& mut self) -> UCTXIFG_W < 1 > { UCTXIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Interrupt Flags Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0ifg_spi](index.html) module"]
pub struct UCA0IFG_SPI_SPEC ; impl crate :: RegisterSpec for UCA0IFG_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca0ifg_spi::R](R) reader structure"]
impl crate :: Readable for UCA0IFG_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0ifg_spi::W](W) writer structure"]
impl crate :: Writable for UCA0IFG_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IFG_SPI to value 0"]
impl crate :: Resettable for UCA0IFG_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0RXBUF_SPI register accessor: an alias for `Reg<UCA0RXBUF_SPI_SPEC>`"]
pub type UCA0RXBUF_SPI = crate :: Reg < uca0rxbuf_spi :: UCA0RXBUF_SPI_SPEC > ; # [doc = "USCI A0 Receive Buffer"]
pub mod uca0rxbuf_spi { # [doc = "Register `UCA0RXBUF_SPI` reader"]
pub struct R (crate :: R < UCA0RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0RXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0RXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0RXBUF_SPI` writer"]
pub struct W (crate :: W < UCA0RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0RXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0RXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0rxbuf_spi](index.html) module"]
pub struct UCA0RXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCA0RXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0rxbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCA0RXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0rxbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCA0RXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0RXBUF_SPI to value 0"]
impl crate :: Resettable for UCA0RXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0TXBUF_SPI register accessor: an alias for `Reg<UCA0TXBUF_SPI_SPEC>`"]
pub type UCA0TXBUF_SPI = crate :: Reg < uca0txbuf_spi :: UCA0TXBUF_SPI_SPEC > ; # [doc = "USCI A0 Transmit Buffer"]
pub mod uca0txbuf_spi { # [doc = "Register `UCA0TXBUF_SPI` reader"]
pub struct R (crate :: R < UCA0TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0TXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0TXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0TXBUF_SPI` writer"]
pub struct W (crate :: W < UCA0TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0TXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0TXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0txbuf_spi](index.html) module"]
pub struct UCA0TXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCA0TXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0txbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCA0TXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0txbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCA0TXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0TXBUF_SPI to value 0"]
impl crate :: Resettable for UCA0TXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA0IV_SPI register accessor: an alias for `Reg<UCA0IV_SPI_SPEC>`"]
pub type UCA0IV_SPI = crate :: Reg < uca0iv_spi :: UCA0IV_SPI_SPEC > ; # [doc = "USCI A0 Interrupt Vector Register"]
pub mod uca0iv_spi { # [doc = "Register `UCA0IV_SPI` reader"]
pub struct R (crate :: R < UCA0IV_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA0IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA0IV_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA0IV_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA0IV_SPI` writer"]
pub struct W (crate :: W < UCA0IV_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA0IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA0IV_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA0IV_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A0 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca0iv_spi](index.html) module"]
pub struct UCA0IV_SPI_SPEC ; impl crate :: RegisterSpec for UCA0IV_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca0iv_spi::R](R) reader structure"]
impl crate :: Readable for UCA0IV_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca0iv_spi::W](W) writer structure"]
impl crate :: Writable for UCA0IV_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA0IV_SPI to value 0"]
impl crate :: Resettable for UCA0IV_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_A1 UART Mode"]
pub struct USCI_A1_UART_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_A1_UART_MODE { } impl USCI_A1_UART_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_a1_uart_mode :: RegisterBlock = 0x0520 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_a1_uart_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_A1_UART_MODE { type Target = usci_a1_uart_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_A1_UART_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_A1_UART_MODE") . finish () } } # [doc = "USCI_A1 UART Mode"]
pub mod usci_a1_uart_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI A1 Control Register 1"]
pub uca1ctl1 : crate :: Reg < uca1ctl1 :: UCA1CTL1_SPEC > , # [doc = "0x01 - USCI A1 Control Register 0"]
pub uca1ctl0 : crate :: Reg < uca1ctl0 :: UCA1CTL0_SPEC > , # [doc = "0x02 - USCI A1 Control Word Register 1"]
pub uca1ctlw1 : crate :: Reg < uca1ctlw1 :: UCA1CTLW1_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x06 - USCI A1 Baud Rate 0"]
pub uca1br0 : crate :: Reg < uca1br0 :: UCA1BR0_SPEC > , # [doc = "0x07 - USCI A1 Baud Rate 1"]
pub uca1br1 : crate :: Reg < uca1br1 :: UCA1BR1_SPEC > , # [doc = "0x08 - USCI A1 Modulation Control"]
pub uca1mctlw : crate :: Reg < uca1mctlw :: UCA1MCTLW_SPEC > , # [doc = "0x0a - USCI A1 Status Register"]
pub uca1statw : crate :: Reg < uca1statw :: UCA1STATW_SPEC > , _reserved7 : [u8 ; 0x01]
, # [doc = "0x0c - USCI A1 Receive Buffer"]
pub uca1rxbuf : crate :: Reg < uca1rxbuf :: UCA1RXBUF_SPEC > , # [doc = "0x0e - USCI A1 Transmit Buffer"]
pub uca1txbuf : crate :: Reg < uca1txbuf :: UCA1TXBUF_SPEC > , # [doc = "0x10 - USCI A1 LIN Control"]
pub uca1abctl : crate :: Reg < uca1abctl :: UCA1ABCTL_SPEC > , _reserved10 : [u8 ; 0x01]
, # [doc = "0x12 - USCI A1 IrDA Transmit Control"]
pub uca1irtctl : crate :: Reg < uca1irtctl :: UCA1IRTCTL_SPEC > , # [doc = "0x13 - USCI A1 IrDA Receive Control"]
pub uca1irrctl : crate :: Reg < uca1irrctl :: UCA1IRRCTL_SPEC > , _reserved12 : [u8 ; 0x0a]
, # [doc = "0x1e - USCI A1 Interrupt Vector Register"]
pub uca1iv : crate :: Reg < uca1iv :: UCA1IV_SPEC > , } # [doc = "UCA1CTL1 register accessor: an alias for `Reg<UCA1CTL1_SPEC>`"]
pub type UCA1CTL1 = crate :: Reg < uca1ctl1 :: UCA1CTL1_SPEC > ; # [doc = "USCI A1 Control Register 1"]
pub mod uca1ctl1 { # [doc = "Register `UCA1CTL1` reader"]
pub struct R (crate :: R < UCA1CTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1CTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1CTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1CTL1` writer"]
pub struct W (crate :: W < UCA1CTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1CTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1CTL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctl1](index.html) module"]
pub struct UCA1CTL1_SPEC ; impl crate :: RegisterSpec for UCA1CTL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ctl1::R](R) reader structure"]
impl crate :: Readable for UCA1CTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ctl1::W](W) writer structure"]
impl crate :: Writable for UCA1CTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1CTL1 to value 0"]
impl crate :: Resettable for UCA1CTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1CTL0 register accessor: an alias for `Reg<UCA1CTL0_SPEC>`"]
pub type UCA1CTL0 = crate :: Reg < uca1ctl0 :: UCA1CTL0_SPEC > ; # [doc = "USCI A1 Control Register 0"]
pub mod uca1ctl0 { # [doc = "Register `UCA1CTL0` reader"]
pub struct R (crate :: R < UCA1CTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1CTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1CTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1CTL0` writer"]
pub struct W (crate :: W < UCA1CTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1CTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1CTL0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctl0](index.html) module"]
pub struct UCA1CTL0_SPEC ; impl crate :: RegisterSpec for UCA1CTL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ctl0::R](R) reader structure"]
impl crate :: Readable for UCA1CTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ctl0::W](W) writer structure"]
impl crate :: Writable for UCA1CTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1CTL0 to value 0"]
impl crate :: Resettable for UCA1CTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1BR0 register accessor: an alias for `Reg<UCA1BR0_SPEC>`"]
pub type UCA1BR0 = crate :: Reg < uca1br0 :: UCA1BR0_SPEC > ; # [doc = "USCI A1 Baud Rate 0"]
pub mod uca1br0 { # [doc = "Register `UCA1BR0` reader"]
pub struct R (crate :: R < UCA1BR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1BR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1BR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1BR0` writer"]
pub struct W (crate :: W < UCA1BR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1BR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1BR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1br0](index.html) module"]
pub struct UCA1BR0_SPEC ; impl crate :: RegisterSpec for UCA1BR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1br0::R](R) reader structure"]
impl crate :: Readable for UCA1BR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1br0::W](W) writer structure"]
impl crate :: Writable for UCA1BR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1BR0 to value 0"]
impl crate :: Resettable for UCA1BR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1BR1 register accessor: an alias for `Reg<UCA1BR1_SPEC>`"]
pub type UCA1BR1 = crate :: Reg < uca1br1 :: UCA1BR1_SPEC > ; # [doc = "USCI A1 Baud Rate 1"]
pub mod uca1br1 { # [doc = "Register `UCA1BR1` reader"]
pub struct R (crate :: R < UCA1BR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1BR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1BR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1BR1` writer"]
pub struct W (crate :: W < UCA1BR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1BR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1BR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1br1](index.html) module"]
pub struct UCA1BR1_SPEC ; impl crate :: RegisterSpec for UCA1BR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1br1::R](R) reader structure"]
impl crate :: Readable for UCA1BR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1br1::W](W) writer structure"]
impl crate :: Writable for UCA1BR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1BR1 to value 0"]
impl crate :: Resettable for UCA1BR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1STATW register accessor: an alias for `Reg<UCA1STATW_SPEC>`"]
pub type UCA1STATW = crate :: Reg < uca1statw :: UCA1STATW_SPEC > ; # [doc = "USCI A1 Status Register"]
pub mod uca1statw { # [doc = "Register `UCA1STATW` reader"]
pub struct R (crate :: R < UCA1STATW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1STATW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1STATW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1STATW_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1STATW` writer"]
pub struct W (crate :: W < UCA1STATW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1STATW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1STATW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1STATW_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBUSY` reader - USCI Busy Flag"]
pub type UCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `UCBUSY` writer - USCI Busy Flag"]
pub type UCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCADDR` reader - USCI Address received Flag"]
pub type UCADDR_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDR` writer - USCI Address received Flag"]
pub type UCADDR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCRXERR` reader - USCI RX Error Flag"]
pub type UCRXERR_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXERR` writer - USCI RX Error Flag"]
pub type UCRXERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCBRK` reader - USCI Break received"]
pub type UCBRK_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRK` writer - USCI Break received"]
pub type UCBRK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCPE` reader - USCI Parity Error Flag"]
pub type UCPE_R = crate :: BitReader < bool > ; # [doc = "Field `UCPE` writer - USCI Parity Error Flag"]
pub type UCPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCOE` reader - USCI Overrun Error Flag"]
pub type UCOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCOE` writer - USCI Overrun Error Flag"]
pub type UCOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCFE` reader - USCI Frame Error Flag"]
pub type UCFE_R = crate :: BitReader < bool > ; # [doc = "Field `UCFE` writer - USCI Frame Error Flag"]
pub type UCFE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; # [doc = "Field `UCLISTEN` reader - USCI Listen mode"]
pub type UCLISTEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCLISTEN` writer - USCI Listen mode"]
pub type UCLISTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& self) -> UCBUSY_R { UCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Address received Flag"]
# [inline (always)]
pub fn ucaddr (& self) -> UCADDR_R { UCADDR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - USCI RX Error Flag"]
# [inline (always)]
pub fn ucrxerr (& self) -> UCRXERR_R { UCRXERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - USCI Break received"]
# [inline (always)]
pub fn ucbrk (& self) -> UCBRK_R { UCBRK_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - USCI Parity Error Flag"]
# [inline (always)]
pub fn ucpe (& self) -> UCPE_R { UCPE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& self) -> UCOE_R { UCOE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& self) -> UCFE_R { UCFE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& self) -> UCLISTEN_R { UCLISTEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& mut self) -> UCBUSY_W < 0 > { UCBUSY_W :: new (self) } # [doc = "Bit 1 - USCI Address received Flag"]
# [inline (always)]
pub fn ucaddr (& mut self) -> UCADDR_W < 1 > { UCADDR_W :: new (self) } # [doc = "Bit 2 - USCI RX Error Flag"]
# [inline (always)]
pub fn ucrxerr (& mut self) -> UCRXERR_W < 2 > { UCRXERR_W :: new (self) } # [doc = "Bit 3 - USCI Break received"]
# [inline (always)]
pub fn ucbrk (& mut self) -> UCBRK_W < 3 > { UCBRK_W :: new (self) } # [doc = "Bit 4 - USCI Parity Error Flag"]
# [inline (always)]
pub fn ucpe (& mut self) -> UCPE_W < 4 > { UCPE_W :: new (self) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& mut self) -> UCOE_W < 5 > { UCOE_W :: new (self) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& mut self) -> UCFE_W < 6 > { UCFE_W :: new (self) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& mut self) -> UCLISTEN_W < 7 > { UCLISTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw](index.html) module"]
pub struct UCA1STATW_SPEC ; impl crate :: RegisterSpec for UCA1STATW_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1statw::R](R) reader structure"]
impl crate :: Readable for UCA1STATW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1statw::W](W) writer structure"]
impl crate :: Writable for UCA1STATW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1STATW to value 0"]
impl crate :: Resettable for UCA1STATW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1ABCTL register accessor: an alias for `Reg<UCA1ABCTL_SPEC>`"]
pub type UCA1ABCTL = crate :: Reg < uca1abctl :: UCA1ABCTL_SPEC > ; # [doc = "USCI A1 LIN Control"]
pub mod uca1abctl { # [doc = "Register `UCA1ABCTL` reader"]
pub struct R (crate :: R < UCA1ABCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1ABCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1ABCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1ABCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1ABCTL` writer"]
pub struct W (crate :: W < UCA1ABCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1ABCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1ABCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1ABCTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCABDEN` reader - Auto Baud Rate detect enable"]
pub type UCABDEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCABDEN` writer - Auto Baud Rate detect enable"]
pub type UCABDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1ABCTL_SPEC , bool , O > ; # [doc = "Field `UCBTOE` reader - Break Timeout error"]
pub type UCBTOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCBTOE` writer - Break Timeout error"]
pub type UCBTOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1ABCTL_SPEC , bool , O > ; # [doc = "Field `UCSTOE` reader - Sync-Field Timeout error"]
pub type UCSTOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTOE` writer - Sync-Field Timeout error"]
pub type UCSTOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1ABCTL_SPEC , bool , O > ; # [doc = "Field `UCDELIM0` reader - Break Sync Delimiter 0"]
pub type UCDELIM0_R = crate :: BitReader < bool > ; # [doc = "Field `UCDELIM0` writer - Break Sync Delimiter 0"]
pub type UCDELIM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1ABCTL_SPEC , bool , O > ; # [doc = "Field `UCDELIM1` reader - Break Sync Delimiter 1"]
pub type UCDELIM1_R = crate :: BitReader < bool > ; # [doc = "Field `UCDELIM1` writer - Break Sync Delimiter 1"]
pub type UCDELIM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1ABCTL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Auto Baud Rate detect enable"]
# [inline (always)]
pub fn ucabden (& self) -> UCABDEN_R { UCABDEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Break Timeout error"]
# [inline (always)]
pub fn ucbtoe (& self) -> UCBTOE_R { UCBTOE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Sync-Field Timeout error"]
# [inline (always)]
pub fn ucstoe (& self) -> UCSTOE_R { UCSTOE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Break Sync Delimiter 0"]
# [inline (always)]
pub fn ucdelim0 (& self) -> UCDELIM0_R { UCDELIM0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Break Sync Delimiter 1"]
# [inline (always)]
pub fn ucdelim1 (& self) -> UCDELIM1_R { UCDELIM1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Auto Baud Rate detect enable"]
# [inline (always)]
pub fn ucabden (& mut self) -> UCABDEN_W < 0 > { UCABDEN_W :: new (self) } # [doc = "Bit 2 - Break Timeout error"]
# [inline (always)]
pub fn ucbtoe (& mut self) -> UCBTOE_W < 2 > { UCBTOE_W :: new (self) } # [doc = "Bit 3 - Sync-Field Timeout error"]
# [inline (always)]
pub fn ucstoe (& mut self) -> UCSTOE_W < 3 > { UCSTOE_W :: new (self) } # [doc = "Bit 4 - Break Sync Delimiter 0"]
# [inline (always)]
pub fn ucdelim0 (& mut self) -> UCDELIM0_W < 4 > { UCDELIM0_W :: new (self) } # [doc = "Bit 5 - Break Sync Delimiter 1"]
# [inline (always)]
pub fn ucdelim1 (& mut self) -> UCDELIM1_W < 5 > { UCDELIM1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 LIN Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1abctl](index.html) module"]
pub struct UCA1ABCTL_SPEC ; impl crate :: RegisterSpec for UCA1ABCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1abctl::R](R) reader structure"]
impl crate :: Readable for UCA1ABCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1abctl::W](W) writer structure"]
impl crate :: Writable for UCA1ABCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1ABCTL to value 0"]
impl crate :: Resettable for UCA1ABCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IRTCTL register accessor: an alias for `Reg<UCA1IRTCTL_SPEC>`"]
pub type UCA1IRTCTL = crate :: Reg < uca1irtctl :: UCA1IRTCTL_SPEC > ; # [doc = "USCI A1 IrDA Transmit Control"]
pub mod uca1irtctl { # [doc = "Register `UCA1IRTCTL` reader"]
pub struct R (crate :: R < UCA1IRTCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IRTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IRTCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IRTCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IRTCTL` writer"]
pub struct W (crate :: W < UCA1IRTCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IRTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IRTCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IRTCTL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 IrDA Transmit Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1irtctl](index.html) module"]
pub struct UCA1IRTCTL_SPEC ; impl crate :: RegisterSpec for UCA1IRTCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1irtctl::R](R) reader structure"]
impl crate :: Readable for UCA1IRTCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1irtctl::W](W) writer structure"]
impl crate :: Writable for UCA1IRTCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IRTCTL to value 0"]
impl crate :: Resettable for UCA1IRTCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IRRCTL register accessor: an alias for `Reg<UCA1IRRCTL_SPEC>`"]
pub type UCA1IRRCTL = crate :: Reg < uca1irrctl :: UCA1IRRCTL_SPEC > ; # [doc = "USCI A1 IrDA Receive Control"]
pub mod uca1irrctl { # [doc = "Register `UCA1IRRCTL` reader"]
pub struct R (crate :: R < UCA1IRRCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IRRCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IRRCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IRRCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IRRCTL` writer"]
pub struct W (crate :: W < UCA1IRRCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IRRCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IRRCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IRRCTL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 IrDA Receive Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1irrctl](index.html) module"]
pub struct UCA1IRRCTL_SPEC ; impl crate :: RegisterSpec for UCA1IRRCTL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1irrctl::R](R) reader structure"]
impl crate :: Readable for UCA1IRRCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1irrctl::W](W) writer structure"]
impl crate :: Writable for UCA1IRRCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IRRCTL to value 0"]
impl crate :: Resettable for UCA1IRRCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1CTLW1 register accessor: an alias for `Reg<UCA1CTLW1_SPEC>`"]
pub type UCA1CTLW1 = crate :: Reg < uca1ctlw1 :: UCA1CTLW1_SPEC > ; # [doc = "USCI A1 Control Word Register 1"]
pub mod uca1ctlw1 { # [doc = "Register `UCA1CTLW1` reader"]
pub struct R (crate :: R < UCA1CTLW1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1CTLW1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1CTLW1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1CTLW1` writer"]
pub struct W (crate :: W < UCA1CTLW1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1CTLW1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1CTLW1_SPEC >) -> Self { W (writer) } } # [doc = "USCI Deglitch Time Bit 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCGLIT_A { # [doc = "0: USCI Deglitch time: 0"]
UCGLIT_0 = 0 , # [doc = "1: USCI Deglitch time: 1"]
UCGLIT_1 = 1 , # [doc = "2: USCI Deglitch time: 2"]
UCGLIT_2 = 2 , # [doc = "3: USCI Deglitch time: 3"]
UCGLIT_3 = 3 , } impl From < UCGLIT_A > for u8 { # [inline (always)]
fn from (variant : UCGLIT_A) -> Self { variant as _ } } # [doc = "Field `UCGLIT` reader - USCI Deglitch Time Bit 1"]
pub type UCGLIT_R = crate :: FieldReader < u8 , UCGLIT_A > ; impl UCGLIT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCGLIT_0`"]
# [inline (always)]
pub fn is_ucglit_0 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [doc = "Checks if the value of the field is `UCGLIT_1`"]
# [inline (always)]
pub fn is_ucglit_1 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [doc = "Checks if the value of the field is `UCGLIT_2`"]
# [inline (always)]
pub fn is_ucglit_2 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [doc = "Checks if the value of the field is `UCGLIT_3`"]
# [inline (always)]
pub fn is_ucglit_3 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_3 } } # [doc = "Field `UCGLIT` writer - USCI Deglitch Time Bit 1"]
pub type UCGLIT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCA1CTLW1_SPEC , u8 , UCGLIT_A , 2 , O > ; impl < 'a , const O : u8 > UCGLIT_W < 'a , O > { # [doc = "USCI Deglitch time: 0"]
# [inline (always)]
pub fn ucglit_0 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_0) } # [doc = "USCI Deglitch time: 1"]
# [inline (always)]
pub fn ucglit_1 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_1) } # [doc = "USCI Deglitch time: 2"]
# [inline (always)]
pub fn ucglit_2 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_2) } # [doc = "USCI Deglitch time: 3"]
# [inline (always)]
pub fn ucglit_3 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_3) } } impl R { # [doc = "Bits 0:1 - USCI Deglitch Time Bit 1"]
# [inline (always)]
pub fn ucglit (& self) -> UCGLIT_R { UCGLIT_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1 - USCI Deglitch Time Bit 1"]
# [inline (always)]
pub fn ucglit (& mut self) -> UCGLIT_W < 0 > { UCGLIT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctlw1](index.html) module"]
pub struct UCA1CTLW1_SPEC ; impl crate :: RegisterSpec for UCA1CTLW1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1ctlw1::R](R) reader structure"]
impl crate :: Readable for UCA1CTLW1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ctlw1::W](W) writer structure"]
impl crate :: Writable for UCA1CTLW1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1CTLW1 to value 0"]
impl crate :: Resettable for UCA1CTLW1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1MCTLW register accessor: an alias for `Reg<UCA1MCTLW_SPEC>`"]
pub type UCA1MCTLW = crate :: Reg < uca1mctlw :: UCA1MCTLW_SPEC > ; # [doc = "USCI A1 Modulation Control"]
pub mod uca1mctlw { # [doc = "Register `UCA1MCTLW` reader"]
pub struct R (crate :: R < UCA1MCTLW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1MCTLW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1MCTLW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1MCTLW_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1MCTLW` writer"]
pub struct W (crate :: W < UCA1MCTLW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1MCTLW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1MCTLW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1MCTLW_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOS16` reader - USCI 16-times Oversampling enable"]
pub type UCOS16_R = crate :: BitReader < bool > ; # [doc = "Field `UCOS16` writer - USCI 16-times Oversampling enable"]
pub type UCOS16_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "USCI First Stage Modulation Select 3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCBRF_A { # [doc = "0: USCI First Stage Modulation: 0"]
UCBRF_0 = 0 , # [doc = "1: USCI First Stage Modulation: 1"]
UCBRF_1 = 1 , # [doc = "2: USCI First Stage Modulation: 2"]
UCBRF_2 = 2 , # [doc = "3: USCI First Stage Modulation: 3"]
UCBRF_3 = 3 , # [doc = "4: USCI First Stage Modulation: 4"]
UCBRF_4 = 4 , # [doc = "5: USCI First Stage Modulation: 5"]
UCBRF_5 = 5 , # [doc = "6: USCI First Stage Modulation: 6"]
UCBRF_6 = 6 , # [doc = "7: USCI First Stage Modulation: 7"]
UCBRF_7 = 7 , # [doc = "8: USCI First Stage Modulation: 8"]
UCBRF_8 = 8 , # [doc = "9: USCI First Stage Modulation: 9"]
UCBRF_9 = 9 , # [doc = "10: USCI First Stage Modulation: A"]
UCBRF_10 = 10 , # [doc = "11: USCI First Stage Modulation: B"]
UCBRF_11 = 11 , # [doc = "12: USCI First Stage Modulation: C"]
UCBRF_12 = 12 , # [doc = "13: USCI First Stage Modulation: D"]
UCBRF_13 = 13 , # [doc = "14: USCI First Stage Modulation: E"]
UCBRF_14 = 14 , # [doc = "15: USCI First Stage Modulation: F"]
UCBRF_15 = 15 , } impl From < UCBRF_A > for u8 { # [inline (always)]
fn from (variant : UCBRF_A) -> Self { variant as _ } } # [doc = "Field `UCBRF` reader - USCI First Stage Modulation Select 3"]
pub type UCBRF_R = crate :: FieldReader < u8 , UCBRF_A > ; impl UCBRF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCBRF_A { match self . bits { 0 => UCBRF_A :: UCBRF_0 , 1 => UCBRF_A :: UCBRF_1 , 2 => UCBRF_A :: UCBRF_2 , 3 => UCBRF_A :: UCBRF_3 , 4 => UCBRF_A :: UCBRF_4 , 5 => UCBRF_A :: UCBRF_5 , 6 => UCBRF_A :: UCBRF_6 , 7 => UCBRF_A :: UCBRF_7 , 8 => UCBRF_A :: UCBRF_8 , 9 => UCBRF_A :: UCBRF_9 , 10 => UCBRF_A :: UCBRF_10 , 11 => UCBRF_A :: UCBRF_11 , 12 => UCBRF_A :: UCBRF_12 , 13 => UCBRF_A :: UCBRF_13 , 14 => UCBRF_A :: UCBRF_14 , 15 => UCBRF_A :: UCBRF_15 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCBRF_0`"]
# [inline (always)]
pub fn is_ucbrf_0 (& self) -> bool { * self == UCBRF_A :: UCBRF_0 } # [doc = "Checks if the value of the field is `UCBRF_1`"]
# [inline (always)]
pub fn is_ucbrf_1 (& self) -> bool { * self == UCBRF_A :: UCBRF_1 } # [doc = "Checks if the value of the field is `UCBRF_2`"]
# [inline (always)]
pub fn is_ucbrf_2 (& self) -> bool { * self == UCBRF_A :: UCBRF_2 } # [doc = "Checks if the value of the field is `UCBRF_3`"]
# [inline (always)]
pub fn is_ucbrf_3 (& self) -> bool { * self == UCBRF_A :: UCBRF_3 } # [doc = "Checks if the value of the field is `UCBRF_4`"]
# [inline (always)]
pub fn is_ucbrf_4 (& self) -> bool { * self == UCBRF_A :: UCBRF_4 } # [doc = "Checks if the value of the field is `UCBRF_5`"]
# [inline (always)]
pub fn is_ucbrf_5 (& self) -> bool { * self == UCBRF_A :: UCBRF_5 } # [doc = "Checks if the value of the field is `UCBRF_6`"]
# [inline (always)]
pub fn is_ucbrf_6 (& self) -> bool { * self == UCBRF_A :: UCBRF_6 } # [doc = "Checks if the value of the field is `UCBRF_7`"]
# [inline (always)]
pub fn is_ucbrf_7 (& self) -> bool { * self == UCBRF_A :: UCBRF_7 } # [doc = "Checks if the value of the field is `UCBRF_8`"]
# [inline (always)]
pub fn is_ucbrf_8 (& self) -> bool { * self == UCBRF_A :: UCBRF_8 } # [doc = "Checks if the value of the field is `UCBRF_9`"]
# [inline (always)]
pub fn is_ucbrf_9 (& self) -> bool { * self == UCBRF_A :: UCBRF_9 } # [doc = "Checks if the value of the field is `UCBRF_10`"]
# [inline (always)]
pub fn is_ucbrf_10 (& self) -> bool { * self == UCBRF_A :: UCBRF_10 } # [doc = "Checks if the value of the field is `UCBRF_11`"]
# [inline (always)]
pub fn is_ucbrf_11 (& self) -> bool { * self == UCBRF_A :: UCBRF_11 } # [doc = "Checks if the value of the field is `UCBRF_12`"]
# [inline (always)]
pub fn is_ucbrf_12 (& self) -> bool { * self == UCBRF_A :: UCBRF_12 } # [doc = "Checks if the value of the field is `UCBRF_13`"]
# [inline (always)]
pub fn is_ucbrf_13 (& self) -> bool { * self == UCBRF_A :: UCBRF_13 } # [doc = "Checks if the value of the field is `UCBRF_14`"]
# [inline (always)]
pub fn is_ucbrf_14 (& self) -> bool { * self == UCBRF_A :: UCBRF_14 } # [doc = "Checks if the value of the field is `UCBRF_15`"]
# [inline (always)]
pub fn is_ucbrf_15 (& self) -> bool { * self == UCBRF_A :: UCBRF_15 } } # [doc = "Field `UCBRF` writer - USCI First Stage Modulation Select 3"]
pub type UCBRF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCA1MCTLW_SPEC , u8 , UCBRF_A , 4 , O > ; impl < 'a , const O : u8 > UCBRF_W < 'a , O > { # [doc = "USCI First Stage Modulation: 0"]
# [inline (always)]
pub fn ucbrf_0 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_0) } # [doc = "USCI First Stage Modulation: 1"]
# [inline (always)]
pub fn ucbrf_1 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_1) } # [doc = "USCI First Stage Modulation: 2"]
# [inline (always)]
pub fn ucbrf_2 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_2) } # [doc = "USCI First Stage Modulation: 3"]
# [inline (always)]
pub fn ucbrf_3 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_3) } # [doc = "USCI First Stage Modulation: 4"]
# [inline (always)]
pub fn ucbrf_4 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_4) } # [doc = "USCI First Stage Modulation: 5"]
# [inline (always)]
pub fn ucbrf_5 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_5) } # [doc = "USCI First Stage Modulation: 6"]
# [inline (always)]
pub fn ucbrf_6 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_6) } # [doc = "USCI First Stage Modulation: 7"]
# [inline (always)]
pub fn ucbrf_7 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_7) } # [doc = "USCI First Stage Modulation: 8"]
# [inline (always)]
pub fn ucbrf_8 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_8) } # [doc = "USCI First Stage Modulation: 9"]
# [inline (always)]
pub fn ucbrf_9 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_9) } # [doc = "USCI First Stage Modulation: A"]
# [inline (always)]
pub fn ucbrf_10 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_10) } # [doc = "USCI First Stage Modulation: B"]
# [inline (always)]
pub fn ucbrf_11 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_11) } # [doc = "USCI First Stage Modulation: C"]
# [inline (always)]
pub fn ucbrf_12 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_12) } # [doc = "USCI First Stage Modulation: D"]
# [inline (always)]
pub fn ucbrf_13 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_13) } # [doc = "USCI First Stage Modulation: E"]
# [inline (always)]
pub fn ucbrf_14 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_14) } # [doc = "USCI First Stage Modulation: F"]
# [inline (always)]
pub fn ucbrf_15 (self) -> & 'a mut W { self . variant (UCBRF_A :: UCBRF_15) } } # [doc = "Field `UCBRS0` reader - USCI Second Stage Modulation Select 0"]
pub type UCBRS0_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS0` writer - USCI Second Stage Modulation Select 0"]
pub type UCBRS0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS1` reader - USCI Second Stage Modulation Select 1"]
pub type UCBRS1_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS1` writer - USCI Second Stage Modulation Select 1"]
pub type UCBRS1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS2` reader - USCI Second Stage Modulation Select 2"]
pub type UCBRS2_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS2` writer - USCI Second Stage Modulation Select 2"]
pub type UCBRS2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS3` reader - USCI Second Stage Modulation Select 3"]
pub type UCBRS3_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS3` writer - USCI Second Stage Modulation Select 3"]
pub type UCBRS3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS4` reader - USCI Second Stage Modulation Select 4"]
pub type UCBRS4_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS4` writer - USCI Second Stage Modulation Select 4"]
pub type UCBRS4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS5` reader - USCI Second Stage Modulation Select 5"]
pub type UCBRS5_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS5` writer - USCI Second Stage Modulation Select 5"]
pub type UCBRS5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS6` reader - USCI Second Stage Modulation Select 6"]
pub type UCBRS6_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS6` writer - USCI Second Stage Modulation Select 6"]
pub type UCBRS6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; # [doc = "Field `UCBRS7` reader - USCI Second Stage Modulation Select 7"]
pub type UCBRS7_R = crate :: BitReader < bool > ; # [doc = "Field `UCBRS7` writer - USCI Second Stage Modulation Select 7"]
pub type UCBRS7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCA1MCTLW_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI 16-times Oversampling enable"]
# [inline (always)]
pub fn ucos16 (& self) -> UCOS16_R { UCOS16_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrf (& self) -> UCBRF_R { UCBRF_R :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bit 8 - USCI Second Stage Modulation Select 0"]
# [inline (always)]
pub fn ucbrs0 (& self) -> UCBRS0_R { UCBRS0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - USCI Second Stage Modulation Select 1"]
# [inline (always)]
pub fn ucbrs1 (& self) -> UCBRS1_R { UCBRS1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - USCI Second Stage Modulation Select 2"]
# [inline (always)]
pub fn ucbrs2 (& self) -> UCBRS2_R { UCBRS2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - USCI Second Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrs3 (& self) -> UCBRS3_R { UCBRS3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - USCI Second Stage Modulation Select 4"]
# [inline (always)]
pub fn ucbrs4 (& self) -> UCBRS4_R { UCBRS4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - USCI Second Stage Modulation Select 5"]
# [inline (always)]
pub fn ucbrs5 (& self) -> UCBRS5_R { UCBRS5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - USCI Second Stage Modulation Select 6"]
# [inline (always)]
pub fn ucbrs6 (& self) -> UCBRS6_R { UCBRS6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - USCI Second Stage Modulation Select 7"]
# [inline (always)]
pub fn ucbrs7 (& self) -> UCBRS7_R { UCBRS7_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI 16-times Oversampling enable"]
# [inline (always)]
pub fn ucos16 (& mut self) -> UCOS16_W < 0 > { UCOS16_W :: new (self) } # [doc = "Bits 4:7 - USCI First Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrf (& mut self) -> UCBRF_W < 4 > { UCBRF_W :: new (self) } # [doc = "Bit 8 - USCI Second Stage Modulation Select 0"]
# [inline (always)]
pub fn ucbrs0 (& mut self) -> UCBRS0_W < 8 > { UCBRS0_W :: new (self) } # [doc = "Bit 9 - USCI Second Stage Modulation Select 1"]
# [inline (always)]
pub fn ucbrs1 (& mut self) -> UCBRS1_W < 9 > { UCBRS1_W :: new (self) } # [doc = "Bit 10 - USCI Second Stage Modulation Select 2"]
# [inline (always)]
pub fn ucbrs2 (& mut self) -> UCBRS2_W < 10 > { UCBRS2_W :: new (self) } # [doc = "Bit 11 - USCI Second Stage Modulation Select 3"]
# [inline (always)]
pub fn ucbrs3 (& mut self) -> UCBRS3_W < 11 > { UCBRS3_W :: new (self) } # [doc = "Bit 12 - USCI Second Stage Modulation Select 4"]
# [inline (always)]
pub fn ucbrs4 (& mut self) -> UCBRS4_W < 12 > { UCBRS4_W :: new (self) } # [doc = "Bit 13 - USCI Second Stage Modulation Select 5"]
# [inline (always)]
pub fn ucbrs5 (& mut self) -> UCBRS5_W < 13 > { UCBRS5_W :: new (self) } # [doc = "Bit 14 - USCI Second Stage Modulation Select 6"]
# [inline (always)]
pub fn ucbrs6 (& mut self) -> UCBRS6_W < 14 > { UCBRS6_W :: new (self) } # [doc = "Bit 15 - USCI Second Stage Modulation Select 7"]
# [inline (always)]
pub fn ucbrs7 (& mut self) -> UCBRS7_W < 15 > { UCBRS7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Modulation Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1mctlw](index.html) module"]
pub struct UCA1MCTLW_SPEC ; impl crate :: RegisterSpec for UCA1MCTLW_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1mctlw::R](R) reader structure"]
impl crate :: Readable for UCA1MCTLW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1mctlw::W](W) writer structure"]
impl crate :: Writable for UCA1MCTLW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1MCTLW to value 0"]
impl crate :: Resettable for UCA1MCTLW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1RXBUF register accessor: an alias for `Reg<UCA1RXBUF_SPEC>`"]
pub type UCA1RXBUF = crate :: Reg < uca1rxbuf :: UCA1RXBUF_SPEC > ; # [doc = "USCI A1 Receive Buffer"]
pub mod uca1rxbuf { # [doc = "Register `UCA1RXBUF` reader"]
pub struct R (crate :: R < UCA1RXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1RXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1RXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1RXBUF` writer"]
pub struct W (crate :: W < UCA1RXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1RXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1RXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf](index.html) module"]
pub struct UCA1RXBUF_SPEC ; impl crate :: RegisterSpec for UCA1RXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1rxbuf::R](R) reader structure"]
impl crate :: Readable for UCA1RXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1rxbuf::W](W) writer structure"]
impl crate :: Writable for UCA1RXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1RXBUF to value 0"]
impl crate :: Resettable for UCA1RXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1TXBUF register accessor: an alias for `Reg<UCA1TXBUF_SPEC>`"]
pub type UCA1TXBUF = crate :: Reg < uca1txbuf :: UCA1TXBUF_SPEC > ; # [doc = "USCI A1 Transmit Buffer"]
pub mod uca1txbuf { # [doc = "Register `UCA1TXBUF` reader"]
pub struct R (crate :: R < UCA1TXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1TXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1TXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1TXBUF` writer"]
pub struct W (crate :: W < UCA1TXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1TXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1TXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf](index.html) module"]
pub struct UCA1TXBUF_SPEC ; impl crate :: RegisterSpec for UCA1TXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1txbuf::R](R) reader structure"]
impl crate :: Readable for UCA1TXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1txbuf::W](W) writer structure"]
impl crate :: Writable for UCA1TXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1TXBUF to value 0"]
impl crate :: Resettable for UCA1TXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IV register accessor: an alias for `Reg<UCA1IV_SPEC>`"]
pub type UCA1IV = crate :: Reg < uca1iv :: UCA1IV_SPEC > ; # [doc = "USCI A1 Interrupt Vector Register"]
pub mod uca1iv { # [doc = "Register `UCA1IV` reader"]
pub struct R (crate :: R < UCA1IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IV` writer"]
pub struct W (crate :: W < UCA1IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv](index.html) module"]
pub struct UCA1IV_SPEC ; impl crate :: RegisterSpec for UCA1IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1iv::R](R) reader structure"]
impl crate :: Readable for UCA1IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1iv::W](W) writer structure"]
impl crate :: Writable for UCA1IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IV to value 0"]
impl crate :: Resettable for UCA1IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_A1 SPI Mode"]
pub struct USCI_A1_SPI_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_A1_SPI_MODE { } impl USCI_A1_SPI_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_a1_spi_mode :: RegisterBlock = 0x0520 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_a1_spi_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_A1_SPI_MODE { type Target = usci_a1_spi_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_A1_SPI_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_A1_SPI_MODE") . finish () } } # [doc = "USCI_A1 SPI Mode"]
pub mod usci_a1_spi_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI A1 Control Register 1"]
pub uca1ctl1_spi : crate :: Reg < uca1ctl1_spi :: UCA1CTL1_SPI_SPEC > , # [doc = "0x01 - USCI A1 Control Register 0"]
pub uca1ctl0_spi : crate :: Reg < uca1ctl0_spi :: UCA1CTL0_SPI_SPEC > , _reserved2 : [u8 ; 0x04]
, # [doc = "0x06 - USCI A1 Baud Rate 0"]
pub uca1br0_spi : crate :: Reg < uca1br0_spi :: UCA1BR0_SPI_SPEC > , # [doc = "0x07 - USCI A1 Baud Rate 1"]
pub uca1br1_spi : crate :: Reg < uca1br1_spi :: UCA1BR1_SPI_SPEC > , _reserved4 : [u8 ; 0x02]
, # [doc = "0x0a - USCI A1 Status Register"]
pub uca1statw_spi : crate :: Reg < uca1statw_spi :: UCA1STATW_SPI_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x0c - USCI A1 Receive Buffer"]
pub uca1rxbuf_spi : crate :: Reg < uca1rxbuf_spi :: UCA1RXBUF_SPI_SPEC > , # [doc = "0x0e - USCI A1 Transmit Buffer"]
pub uca1txbuf_spi : crate :: Reg < uca1txbuf_spi :: UCA1TXBUF_SPI_SPEC > , _reserved7 : [u8 ; 0x0a]
, # [doc = "0x1a - USCI A1 Interrupt Enable Register"]
pub uca1ie_spi : crate :: Reg < uca1ie_spi :: UCA1IE_SPI_SPEC > , _reserved8 : [u8 ; 0x01]
, # [doc = "0x1c - USCI A1 Interrupt Flags Register"]
pub uca1ifg_spi : crate :: Reg < uca1ifg_spi :: UCA1IFG_SPI_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x1e - USCI A1 Interrupt Vector Register"]
pub uca1iv_spi : crate :: Reg < uca1iv_spi :: UCA1IV_SPI_SPEC > , } # [doc = "UCA1CTL1_SPI register accessor: an alias for `Reg<UCA1CTL1_SPI_SPEC>`"]
pub type UCA1CTL1_SPI = crate :: Reg < uca1ctl1_spi :: UCA1CTL1_SPI_SPEC > ; # [doc = "USCI A1 Control Register 1"]
pub mod uca1ctl1_spi { # [doc = "Register `UCA1CTL1_SPI` reader"]
pub struct R (crate :: R < UCA1CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1CTL1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1CTL1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1CTL1_SPI` writer"]
pub struct W (crate :: W < UCA1CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1CTL1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1CTL1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctl1_spi](index.html) module"]
pub struct UCA1CTL1_SPI_SPEC ; impl crate :: RegisterSpec for UCA1CTL1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ctl1_spi::R](R) reader structure"]
impl crate :: Readable for UCA1CTL1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ctl1_spi::W](W) writer structure"]
impl crate :: Writable for UCA1CTL1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1CTL1_SPI to value 0"]
impl crate :: Resettable for UCA1CTL1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1CTL0_SPI register accessor: an alias for `Reg<UCA1CTL0_SPI_SPEC>`"]
pub type UCA1CTL0_SPI = crate :: Reg < uca1ctl0_spi :: UCA1CTL0_SPI_SPEC > ; # [doc = "USCI A1 Control Register 0"]
pub mod uca1ctl0_spi { # [doc = "Register `UCA1CTL0_SPI` reader"]
pub struct R (crate :: R < UCA1CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1CTL0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1CTL0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1CTL0_SPI` writer"]
pub struct W (crate :: W < UCA1CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1CTL0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1CTL0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ctl0_spi](index.html) module"]
pub struct UCA1CTL0_SPI_SPEC ; impl crate :: RegisterSpec for UCA1CTL0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ctl0_spi::R](R) reader structure"]
impl crate :: Readable for UCA1CTL0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ctl0_spi::W](W) writer structure"]
impl crate :: Writable for UCA1CTL0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1CTL0_SPI to value 0"]
impl crate :: Resettable for UCA1CTL0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1BR0_SPI register accessor: an alias for `Reg<UCA1BR0_SPI_SPEC>`"]
pub type UCA1BR0_SPI = crate :: Reg < uca1br0_spi :: UCA1BR0_SPI_SPEC > ; # [doc = "USCI A1 Baud Rate 0"]
pub mod uca1br0_spi { # [doc = "Register `UCA1BR0_SPI` reader"]
pub struct R (crate :: R < UCA1BR0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1BR0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1BR0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1BR0_SPI` writer"]
pub struct W (crate :: W < UCA1BR0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1BR0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1BR0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1br0_spi](index.html) module"]
pub struct UCA1BR0_SPI_SPEC ; impl crate :: RegisterSpec for UCA1BR0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1br0_spi::R](R) reader structure"]
impl crate :: Readable for UCA1BR0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1br0_spi::W](W) writer structure"]
impl crate :: Writable for UCA1BR0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1BR0_SPI to value 0"]
impl crate :: Resettable for UCA1BR0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1BR1_SPI register accessor: an alias for `Reg<UCA1BR1_SPI_SPEC>`"]
pub type UCA1BR1_SPI = crate :: Reg < uca1br1_spi :: UCA1BR1_SPI_SPEC > ; # [doc = "USCI A1 Baud Rate 1"]
pub mod uca1br1_spi { # [doc = "Register `UCA1BR1_SPI` reader"]
pub struct R (crate :: R < UCA1BR1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1BR1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1BR1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1BR1_SPI` writer"]
pub struct W (crate :: W < UCA1BR1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1BR1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1BR1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1br1_spi](index.html) module"]
pub struct UCA1BR1_SPI_SPEC ; impl crate :: RegisterSpec for UCA1BR1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1br1_spi::R](R) reader structure"]
impl crate :: Readable for UCA1BR1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1br1_spi::W](W) writer structure"]
impl crate :: Writable for UCA1BR1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1BR1_SPI to value 0"]
impl crate :: Resettable for UCA1BR1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1STATW_SPI register accessor: an alias for `Reg<UCA1STATW_SPI_SPEC>`"]
pub type UCA1STATW_SPI = crate :: Reg < uca1statw_spi :: UCA1STATW_SPI_SPEC > ; # [doc = "USCI A1 Status Register"]
pub mod uca1statw_spi { # [doc = "Register `UCA1STATW_SPI` reader"]
pub struct R (crate :: R < UCA1STATW_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1STATW_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1STATW_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1STATW_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1STATW_SPI` writer"]
pub struct W (crate :: W < UCA1STATW_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1STATW_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1STATW_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1STATW_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBUSY` reader - USCI Busy Flag"]
pub type UCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `UCBUSY` writer - USCI Busy Flag"]
pub type UCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCOE` reader - USCI Overrun Error Flag"]
pub type UCOE_R = crate :: BitReader < bool > ; # [doc = "Field `UCOE` writer - USCI Overrun Error Flag"]
pub type UCOE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCFE` reader - USCI Frame Error Flag"]
pub type UCFE_R = crate :: BitReader < bool > ; # [doc = "Field `UCFE` writer - USCI Frame Error Flag"]
pub type UCFE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPI_SPEC , bool , O > ; # [doc = "Field `UCLISTEN` reader - USCI Listen mode"]
pub type UCLISTEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCLISTEN` writer - USCI Listen mode"]
pub type UCLISTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1STATW_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& self) -> UCBUSY_R { UCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& self) -> UCOE_R { UCOE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& self) -> UCFE_R { UCFE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& self) -> UCLISTEN_R { UCLISTEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Busy Flag"]
# [inline (always)]
pub fn ucbusy (& mut self) -> UCBUSY_W < 0 > { UCBUSY_W :: new (self) } # [doc = "Bit 5 - USCI Overrun Error Flag"]
# [inline (always)]
pub fn ucoe (& mut self) -> UCOE_W < 5 > { UCOE_W :: new (self) } # [doc = "Bit 6 - USCI Frame Error Flag"]
# [inline (always)]
pub fn ucfe (& mut self) -> UCFE_W < 6 > { UCFE_W :: new (self) } # [doc = "Bit 7 - USCI Listen mode"]
# [inline (always)]
pub fn uclisten (& mut self) -> UCLISTEN_W < 7 > { UCLISTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1statw_spi](index.html) module"]
pub struct UCA1STATW_SPI_SPEC ; impl crate :: RegisterSpec for UCA1STATW_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1statw_spi::R](R) reader structure"]
impl crate :: Readable for UCA1STATW_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1statw_spi::W](W) writer structure"]
impl crate :: Writable for UCA1STATW_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1STATW_SPI to value 0"]
impl crate :: Resettable for UCA1STATW_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IE_SPI register accessor: an alias for `Reg<UCA1IE_SPI_SPEC>`"]
pub type UCA1IE_SPI = crate :: Reg < uca1ie_spi :: UCA1IE_SPI_SPEC > ; # [doc = "USCI A1 Interrupt Enable Register"]
pub mod uca1ie_spi { # [doc = "Register `UCA1IE_SPI` reader"]
pub struct R (crate :: R < UCA1IE_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IE_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IE_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IE_SPI` writer"]
pub struct W (crate :: W < UCA1IE_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IE_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IE_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIE` reader - USCI Receive Interrupt Enable"]
pub type UCRXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE` writer - USCI Receive Interrupt Enable"]
pub type UCRXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1IE_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIE` reader - USCI Transmit Interrupt Enable"]
pub type UCTXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE` writer - USCI Transmit Interrupt Enable"]
pub type UCTXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1IE_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& self) -> UCRXIE_R { UCRXIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& self) -> UCTXIE_R { UCTXIE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& mut self) -> UCRXIE_W < 0 > { UCRXIE_W :: new (self) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& mut self) -> UCTXIE_W < 1 > { UCTXIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ie_spi](index.html) module"]
pub struct UCA1IE_SPI_SPEC ; impl crate :: RegisterSpec for UCA1IE_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ie_spi::R](R) reader structure"]
impl crate :: Readable for UCA1IE_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ie_spi::W](W) writer structure"]
impl crate :: Writable for UCA1IE_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IE_SPI to value 0"]
impl crate :: Resettable for UCA1IE_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IFG_SPI register accessor: an alias for `Reg<UCA1IFG_SPI_SPEC>`"]
pub type UCA1IFG_SPI = crate :: Reg < uca1ifg_spi :: UCA1IFG_SPI_SPEC > ; # [doc = "USCI A1 Interrupt Flags Register"]
pub mod uca1ifg_spi { # [doc = "Register `UCA1IFG_SPI` reader"]
pub struct R (crate :: R < UCA1IFG_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IFG_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IFG_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IFG_SPI` writer"]
pub struct W (crate :: W < UCA1IFG_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IFG_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IFG_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIFG` reader - SPI Receive Interrupt Flag"]
pub type UCRXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG` writer - SPI Receive Interrupt Flag"]
pub type UCRXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1IFG_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIFG` reader - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG` writer - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCA1IFG_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& self) -> UCRXIFG_R { UCRXIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& self) -> UCTXIFG_R { UCTXIFG_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& mut self) -> UCRXIFG_W < 0 > { UCRXIFG_W :: new (self) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& mut self) -> UCTXIFG_W < 1 > { UCTXIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Interrupt Flags Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1ifg_spi](index.html) module"]
pub struct UCA1IFG_SPI_SPEC ; impl crate :: RegisterSpec for UCA1IFG_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [uca1ifg_spi::R](R) reader structure"]
impl crate :: Readable for UCA1IFG_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1ifg_spi::W](W) writer structure"]
impl crate :: Writable for UCA1IFG_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IFG_SPI to value 0"]
impl crate :: Resettable for UCA1IFG_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1RXBUF_SPI register accessor: an alias for `Reg<UCA1RXBUF_SPI_SPEC>`"]
pub type UCA1RXBUF_SPI = crate :: Reg < uca1rxbuf_spi :: UCA1RXBUF_SPI_SPEC > ; # [doc = "USCI A1 Receive Buffer"]
pub mod uca1rxbuf_spi { # [doc = "Register `UCA1RXBUF_SPI` reader"]
pub struct R (crate :: R < UCA1RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1RXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1RXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1RXBUF_SPI` writer"]
pub struct W (crate :: W < UCA1RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1RXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1RXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1rxbuf_spi](index.html) module"]
pub struct UCA1RXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCA1RXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1rxbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCA1RXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1rxbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCA1RXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1RXBUF_SPI to value 0"]
impl crate :: Resettable for UCA1RXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1TXBUF_SPI register accessor: an alias for `Reg<UCA1TXBUF_SPI_SPEC>`"]
pub type UCA1TXBUF_SPI = crate :: Reg < uca1txbuf_spi :: UCA1TXBUF_SPI_SPEC > ; # [doc = "USCI A1 Transmit Buffer"]
pub mod uca1txbuf_spi { # [doc = "Register `UCA1TXBUF_SPI` reader"]
pub struct R (crate :: R < UCA1TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1TXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1TXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1TXBUF_SPI` writer"]
pub struct W (crate :: W < UCA1TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1TXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1TXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1txbuf_spi](index.html) module"]
pub struct UCA1TXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCA1TXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1txbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCA1TXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1txbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCA1TXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1TXBUF_SPI to value 0"]
impl crate :: Resettable for UCA1TXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCA1IV_SPI register accessor: an alias for `Reg<UCA1IV_SPI_SPEC>`"]
pub type UCA1IV_SPI = crate :: Reg < uca1iv_spi :: UCA1IV_SPI_SPEC > ; # [doc = "USCI A1 Interrupt Vector Register"]
pub mod uca1iv_spi { # [doc = "Register `UCA1IV_SPI` reader"]
pub struct R (crate :: R < UCA1IV_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCA1IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCA1IV_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCA1IV_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCA1IV_SPI` writer"]
pub struct W (crate :: W < UCA1IV_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCA1IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCA1IV_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCA1IV_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI A1 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [uca1iv_spi](index.html) module"]
pub struct UCA1IV_SPI_SPEC ; impl crate :: RegisterSpec for UCA1IV_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [uca1iv_spi::R](R) reader structure"]
impl crate :: Readable for UCA1IV_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [uca1iv_spi::W](W) writer structure"]
impl crate :: Writable for UCA1IV_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCA1IV_SPI to value 0"]
impl crate :: Resettable for UCA1IV_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_B0 I2C Mode"]
pub struct USCI_B0_I2C_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_B0_I2C_MODE { } impl USCI_B0_I2C_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_b0_i2c_mode :: RegisterBlock = 0x0540 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_b0_i2c_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_B0_I2C_MODE { type Target = usci_b0_i2c_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_B0_I2C_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_B0_I2C_MODE") . finish () } } # [doc = "USCI_B0 I2C Mode"]
pub mod usci_b0_i2c_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI B0 Control Register 1"]
pub ucb0ctl1 : crate :: Reg < ucb0ctl1 :: UCB0CTL1_SPEC > , # [doc = "0x01 - USCI B0 Control Register 0"]
pub ucb0ctl0 : crate :: Reg < ucb0ctl0 :: UCB0CTL0_SPEC > , # [doc = "0x02 - USCI B0 Control Word Register 1"]
pub ucb0ctlw1 : crate :: Reg < ucb0ctlw1 :: UCB0CTLW1_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x06 - USCI B0 Baud Rate 0"]
pub ucb0br0 : crate :: Reg < ucb0br0 :: UCB0BR0_SPEC > , # [doc = "0x07 - USCI B0 Baud Rate 1"]
pub ucb0br1 : crate :: Reg < ucb0br1 :: UCB0BR1_SPEC > , # [doc = "0x08 - USCI B0 Status Register"]
pub ucb0stat_i2c : crate :: Reg < ucb0stat_i2c :: UCB0STAT_I2C_SPEC > , # [doc = "0x09 - USCI B0 Byte Counter Register"]
pub ucb0bcnt_i2c : crate :: Reg < ucb0bcnt_i2c :: UCB0BCNT_I2C_SPEC > , # [doc = "0x0a - USCI B0 Byte Counter Threshold Register"]
pub ucb0tbcnt : crate :: Reg < ucb0tbcnt :: UCB0TBCNT_SPEC > , # [doc = "0x0c - USCI B0 Receive Buffer"]
pub ucb0rxbuf : crate :: Reg < ucb0rxbuf :: UCB0RXBUF_SPEC > , # [doc = "0x0e - USCI B0 Transmit Buffer"]
pub ucb0txbuf : crate :: Reg < ucb0txbuf :: UCB0TXBUF_SPEC > , _reserved10 : [u8 ; 0x04]
, # [doc = "0x14 - USCI B0 I2C Own Address 0"]
pub ucb0i2coa0 : crate :: Reg < ucb0i2coa0 :: UCB0I2COA0_SPEC > , # [doc = "0x16 - USCI B0 I2C Own Address 1"]
pub ucb0i2coa1 : crate :: Reg < ucb0i2coa1 :: UCB0I2COA1_SPEC > , # [doc = "0x18 - USCI B0 I2C Own Address 2"]
pub ucb0i2coa2 : crate :: Reg < ucb0i2coa2 :: UCB0I2COA2_SPEC > , # [doc = "0x1a - USCI B0 I2C Own Address 3"]
pub ucb0i2coa3 : crate :: Reg < ucb0i2coa3 :: UCB0I2COA3_SPEC > , # [doc = "0x1c - USCI B0 Received Address Register"]
pub ucb0addrx : crate :: Reg < ucb0addrx :: UCB0ADDRX_SPEC > , # [doc = "0x1e - USCI B0 Address Mask Register"]
pub ucb0addmask : crate :: Reg < ucb0addmask :: UCB0ADDMASK_SPEC > , # [doc = "0x20 - USCI B0 I2C Slave Address"]
pub ucb0i2csa : crate :: Reg < ucb0i2csa :: UCB0I2CSA_SPEC > , _reserved17 : [u8 ; 0x08]
, _reserved_17_ucb0 : [u8 ; 0x02]
, _reserved_18_ucb0 : [u8 ; 0x02]
, # [doc = "0x2e - USCI B0 Interrupt Vector Register"]
pub ucb0iv : crate :: Reg < ucb0iv :: UCB0IV_SPEC > , } impl RegisterBlock { # [doc = "0x2a - USCI B0 Interrupt Enable Register"]
# [inline (always)]
pub fn ucb0ie_i2c (& self) -> & crate :: Reg < ucb0ie_i2c :: UCB0IE_I2C_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (42usize) as * const crate :: Reg < ucb0ie_i2c :: UCB0IE_I2C_SPEC >) } } # [doc = "0x2a - USCI B0 Interrupt Enable Register"]
# [inline (always)]
pub fn ucb0ie (& self) -> & crate :: Reg < ucb0ie :: UCB0IE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (42usize) as * const crate :: Reg < ucb0ie :: UCB0IE_SPEC >) } } # [doc = "0x2c - USCI B0 Interrupt Flags Register"]
# [inline (always)]
pub fn ucb0ifg_i2c (& self) -> & crate :: Reg < ucb0ifg_i2c :: UCB0IFG_I2C_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (44usize) as * const crate :: Reg < ucb0ifg_i2c :: UCB0IFG_I2C_SPEC >) } } # [doc = "0x2c - USCI B0 Interrupt Flags Register"]
# [inline (always)]
pub fn ucb0ifg (& self) -> & crate :: Reg < ucb0ifg :: UCB0IFG_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (44usize) as * const crate :: Reg < ucb0ifg :: UCB0IFG_SPEC >) } } } # [doc = "UCB0CTL1 register accessor: an alias for `Reg<UCB0CTL1_SPEC>`"]
pub type UCB0CTL1 = crate :: Reg < ucb0ctl1 :: UCB0CTL1_SPEC > ; # [doc = "USCI B0 Control Register 1"]
pub mod ucb0ctl1 { # [doc = "Register `UCB0CTL1` reader"]
pub struct R (crate :: R < UCB0CTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0CTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0CTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0CTL1` writer"]
pub struct W (crate :: W < UCB0CTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0CTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0CTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0CTL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctl1](index.html) module"]
pub struct UCB0CTL1_SPEC ; impl crate :: RegisterSpec for UCB0CTL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0ctl1::R](R) reader structure"]
impl crate :: Readable for UCB0CTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ctl1::W](W) writer structure"]
impl crate :: Writable for UCB0CTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0CTL1 to value 0"]
impl crate :: Resettable for UCB0CTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0CTL0 register accessor: an alias for `Reg<UCB0CTL0_SPEC>`"]
pub type UCB0CTL0 = crate :: Reg < ucb0ctl0 :: UCB0CTL0_SPEC > ; # [doc = "USCI B0 Control Register 0"]
pub mod ucb0ctl0 { # [doc = "Register `UCB0CTL0` reader"]
pub struct R (crate :: R < UCB0CTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0CTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0CTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0CTL0` writer"]
pub struct W (crate :: W < UCB0CTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0CTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0CTL0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctl0](index.html) module"]
pub struct UCB0CTL0_SPEC ; impl crate :: RegisterSpec for UCB0CTL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0ctl0::R](R) reader structure"]
impl crate :: Readable for UCB0CTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ctl0::W](W) writer structure"]
impl crate :: Writable for UCB0CTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0CTL0 to value 0"]
impl crate :: Resettable for UCB0CTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0BR0 register accessor: an alias for `Reg<UCB0BR0_SPEC>`"]
pub type UCB0BR0 = crate :: Reg < ucb0br0 :: UCB0BR0_SPEC > ; # [doc = "USCI B0 Baud Rate 0"]
pub mod ucb0br0 { # [doc = "Register `UCB0BR0` reader"]
pub struct R (crate :: R < UCB0BR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0BR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0BR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0BR0` writer"]
pub struct W (crate :: W < UCB0BR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0BR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0BR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0BR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0br0](index.html) module"]
pub struct UCB0BR0_SPEC ; impl crate :: RegisterSpec for UCB0BR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0br0::R](R) reader structure"]
impl crate :: Readable for UCB0BR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0br0::W](W) writer structure"]
impl crate :: Writable for UCB0BR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0BR0 to value 0"]
impl crate :: Resettable for UCB0BR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0BR1 register accessor: an alias for `Reg<UCB0BR1_SPEC>`"]
pub type UCB0BR1 = crate :: Reg < ucb0br1 :: UCB0BR1_SPEC > ; # [doc = "USCI B0 Baud Rate 1"]
pub mod ucb0br1 { # [doc = "Register `UCB0BR1` reader"]
pub struct R (crate :: R < UCB0BR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0BR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0BR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0BR1` writer"]
pub struct W (crate :: W < UCB0BR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0BR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0BR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0BR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0br1](index.html) module"]
pub struct UCB0BR1_SPEC ; impl crate :: RegisterSpec for UCB0BR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0br1::R](R) reader structure"]
impl crate :: Readable for UCB0BR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0br1::W](W) writer structure"]
impl crate :: Writable for UCB0BR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0BR1 to value 0"]
impl crate :: Resettable for UCB0BR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0STAT_I2C register accessor: an alias for `Reg<UCB0STAT_I2C_SPEC>`"]
pub type UCB0STAT_I2C = crate :: Reg < ucb0stat_i2c :: UCB0STAT_I2C_SPEC > ; # [doc = "USCI B0 Status Register"]
pub mod ucb0stat_i2c { # [doc = "Register `UCB0STAT_I2C` reader"]
pub struct R (crate :: R < UCB0STAT_I2C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0STAT_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0STAT_I2C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0STAT_I2C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0STAT_I2C` writer"]
pub struct W (crate :: W < UCB0STAT_I2C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0STAT_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0STAT_I2C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0STAT_I2C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBBUSY` reader - Bus Busy Flag"]
pub type UCBBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `UCBBUSY` writer - Bus Busy Flag"]
pub type UCBBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0STAT_I2C_SPEC , bool , O > ; # [doc = "Field `UCGC` reader - General Call address received Flag"]
pub type UCGC_R = crate :: BitReader < bool > ; # [doc = "Field `UCGC` writer - General Call address received Flag"]
pub type UCGC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0STAT_I2C_SPEC , bool , O > ; # [doc = "Field `UCSCLLOW` reader - SCL low"]
pub type UCSCLLOW_R = crate :: BitReader < bool > ; # [doc = "Field `UCSCLLOW` writer - SCL low"]
pub type UCSCLLOW_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0STAT_I2C_SPEC , bool , O > ; impl R { # [doc = "Bit 4 - Bus Busy Flag"]
# [inline (always)]
pub fn ucbbusy (& self) -> UCBBUSY_R { UCBBUSY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - General Call address received Flag"]
# [inline (always)]
pub fn ucgc (& self) -> UCGC_R { UCGC_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - SCL low"]
# [inline (always)]
pub fn ucscllow (& self) -> UCSCLLOW_R { UCSCLLOW_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 4 - Bus Busy Flag"]
# [inline (always)]
pub fn ucbbusy (& mut self) -> UCBBUSY_W < 4 > { UCBBUSY_W :: new (self) } # [doc = "Bit 5 - General Call address received Flag"]
# [inline (always)]
pub fn ucgc (& mut self) -> UCGC_W < 5 > { UCGC_W :: new (self) } # [doc = "Bit 6 - SCL low"]
# [inline (always)]
pub fn ucscllow (& mut self) -> UCSCLLOW_W < 6 > { UCSCLLOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0stat_i2c](index.html) module"]
pub struct UCB0STAT_I2C_SPEC ; impl crate :: RegisterSpec for UCB0STAT_I2C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0stat_i2c::R](R) reader structure"]
impl crate :: Readable for UCB0STAT_I2C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0stat_i2c::W](W) writer structure"]
impl crate :: Writable for UCB0STAT_I2C_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0STAT_I2C to value 0"]
impl crate :: Resettable for UCB0STAT_I2C_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0BCNT_I2C register accessor: an alias for `Reg<UCB0BCNT_I2C_SPEC>`"]
pub type UCB0BCNT_I2C = crate :: Reg < ucb0bcnt_i2c :: UCB0BCNT_I2C_SPEC > ; # [doc = "USCI B0 Byte Counter Register"]
pub mod ucb0bcnt_i2c { # [doc = "Register `UCB0BCNT_I2C` reader"]
pub struct R (crate :: R < UCB0BCNT_I2C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0BCNT_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0BCNT_I2C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0BCNT_I2C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0BCNT_I2C` writer"]
pub struct W (crate :: W < UCB0BCNT_I2C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0BCNT_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0BCNT_I2C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0BCNT_I2C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCBCNT0` reader - USCI Byte Counter Bit 0"]
pub type UCBCNT0_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT0` writer - USCI Byte Counter Bit 0"]
pub type UCBCNT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT1` reader - USCI Byte Counter Bit 1"]
pub type UCBCNT1_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT1` writer - USCI Byte Counter Bit 1"]
pub type UCBCNT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT2` reader - USCI Byte Counter Bit 2"]
pub type UCBCNT2_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT2` writer - USCI Byte Counter Bit 2"]
pub type UCBCNT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT3` reader - USCI Byte Counter Bit 3"]
pub type UCBCNT3_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT3` writer - USCI Byte Counter Bit 3"]
pub type UCBCNT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT4` reader - USCI Byte Counter Bit 4"]
pub type UCBCNT4_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT4` writer - USCI Byte Counter Bit 4"]
pub type UCBCNT4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT5` reader - USCI Byte Counter Bit 5"]
pub type UCBCNT5_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT5` writer - USCI Byte Counter Bit 5"]
pub type UCBCNT5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT6` reader - USCI Byte Counter Bit 6"]
pub type UCBCNT6_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT6` writer - USCI Byte Counter Bit 6"]
pub type UCBCNT6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNT7` reader - USCI Byte Counter Bit 7"]
pub type UCBCNT7_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNT7` writer - USCI Byte Counter Bit 7"]
pub type UCBCNT7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCB0BCNT_I2C_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Byte Counter Bit 0"]
# [inline (always)]
pub fn ucbcnt0 (& self) -> UCBCNT0_R { UCBCNT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Byte Counter Bit 1"]
# [inline (always)]
pub fn ucbcnt1 (& self) -> UCBCNT1_R { UCBCNT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - USCI Byte Counter Bit 2"]
# [inline (always)]
pub fn ucbcnt2 (& self) -> UCBCNT2_R { UCBCNT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - USCI Byte Counter Bit 3"]
# [inline (always)]
pub fn ucbcnt3 (& self) -> UCBCNT3_R { UCBCNT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - USCI Byte Counter Bit 4"]
# [inline (always)]
pub fn ucbcnt4 (& self) -> UCBCNT4_R { UCBCNT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USCI Byte Counter Bit 5"]
# [inline (always)]
pub fn ucbcnt5 (& self) -> UCBCNT5_R { UCBCNT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USCI Byte Counter Bit 6"]
# [inline (always)]
pub fn ucbcnt6 (& self) -> UCBCNT6_R { UCBCNT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USCI Byte Counter Bit 7"]
# [inline (always)]
pub fn ucbcnt7 (& self) -> UCBCNT7_R { UCBCNT7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Byte Counter Bit 0"]
# [inline (always)]
pub fn ucbcnt0 (& mut self) -> UCBCNT0_W < 0 > { UCBCNT0_W :: new (self) } # [doc = "Bit 1 - USCI Byte Counter Bit 1"]
# [inline (always)]
pub fn ucbcnt1 (& mut self) -> UCBCNT1_W < 1 > { UCBCNT1_W :: new (self) } # [doc = "Bit 2 - USCI Byte Counter Bit 2"]
# [inline (always)]
pub fn ucbcnt2 (& mut self) -> UCBCNT2_W < 2 > { UCBCNT2_W :: new (self) } # [doc = "Bit 3 - USCI Byte Counter Bit 3"]
# [inline (always)]
pub fn ucbcnt3 (& mut self) -> UCBCNT3_W < 3 > { UCBCNT3_W :: new (self) } # [doc = "Bit 4 - USCI Byte Counter Bit 4"]
# [inline (always)]
pub fn ucbcnt4 (& mut self) -> UCBCNT4_W < 4 > { UCBCNT4_W :: new (self) } # [doc = "Bit 5 - USCI Byte Counter Bit 5"]
# [inline (always)]
pub fn ucbcnt5 (& mut self) -> UCBCNT5_W < 5 > { UCBCNT5_W :: new (self) } # [doc = "Bit 6 - USCI Byte Counter Bit 6"]
# [inline (always)]
pub fn ucbcnt6 (& mut self) -> UCBCNT6_W < 6 > { UCBCNT6_W :: new (self) } # [doc = "Bit 7 - USCI Byte Counter Bit 7"]
# [inline (always)]
pub fn ucbcnt7 (& mut self) -> UCBCNT7_W < 7 > { UCBCNT7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Byte Counter Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0bcnt_i2c](index.html) module"]
pub struct UCB0BCNT_I2C_SPEC ; impl crate :: RegisterSpec for UCB0BCNT_I2C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0bcnt_i2c::R](R) reader structure"]
impl crate :: Readable for UCB0BCNT_I2C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0bcnt_i2c::W](W) writer structure"]
impl crate :: Writable for UCB0BCNT_I2C_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0BCNT_I2C to value 0"]
impl crate :: Resettable for UCB0BCNT_I2C_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0CTLW1 register accessor: an alias for `Reg<UCB0CTLW1_SPEC>`"]
pub type UCB0CTLW1 = crate :: Reg < ucb0ctlw1 :: UCB0CTLW1_SPEC > ; # [doc = "USCI B0 Control Word Register 1"]
pub mod ucb0ctlw1 { # [doc = "Register `UCB0CTLW1` reader"]
pub struct R (crate :: R < UCB0CTLW1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0CTLW1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0CTLW1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0CTLW1` writer"]
pub struct W (crate :: W < UCB0CTLW1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0CTLW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0CTLW1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0CTLW1_SPEC >) -> Self { W (writer) } } # [doc = "USCI Deglitch time Bit: 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCGLIT_A { # [doc = "0: USCI Deglitch time: 0"]
UCGLIT_0 = 0 , # [doc = "1: USCI Deglitch time: 1"]
UCGLIT_1 = 1 , # [doc = "2: USCI Deglitch time: 2"]
UCGLIT_2 = 2 , # [doc = "3: USCI Deglitch time: 3"]
UCGLIT_3 = 3 , } impl From < UCGLIT_A > for u8 { # [inline (always)]
fn from (variant : UCGLIT_A) -> Self { variant as _ } } # [doc = "Field `UCGLIT` reader - USCI Deglitch time Bit: 1"]
pub type UCGLIT_R = crate :: FieldReader < u8 , UCGLIT_A > ; impl UCGLIT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCGLIT_A { match self . bits { 0 => UCGLIT_A :: UCGLIT_0 , 1 => UCGLIT_A :: UCGLIT_1 , 2 => UCGLIT_A :: UCGLIT_2 , 3 => UCGLIT_A :: UCGLIT_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCGLIT_0`"]
# [inline (always)]
pub fn is_ucglit_0 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_0 } # [doc = "Checks if the value of the field is `UCGLIT_1`"]
# [inline (always)]
pub fn is_ucglit_1 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_1 } # [doc = "Checks if the value of the field is `UCGLIT_2`"]
# [inline (always)]
pub fn is_ucglit_2 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_2 } # [doc = "Checks if the value of the field is `UCGLIT_3`"]
# [inline (always)]
pub fn is_ucglit_3 (& self) -> bool { * self == UCGLIT_A :: UCGLIT_3 } } # [doc = "Field `UCGLIT` writer - USCI Deglitch time Bit: 1"]
pub type UCGLIT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCB0CTLW1_SPEC , u8 , UCGLIT_A , 2 , O > ; impl < 'a , const O : u8 > UCGLIT_W < 'a , O > { # [doc = "USCI Deglitch time: 0"]
# [inline (always)]
pub fn ucglit_0 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_0) } # [doc = "USCI Deglitch time: 1"]
# [inline (always)]
pub fn ucglit_1 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_1) } # [doc = "USCI Deglitch time: 2"]
# [inline (always)]
pub fn ucglit_2 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_2) } # [doc = "USCI Deglitch time: 3"]
# [inline (always)]
pub fn ucglit_3 (self) -> & 'a mut W { self . variant (UCGLIT_A :: UCGLIT_3) } } # [doc = "USCI Automatic Stop condition generation Bit: 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCASTP_A { # [doc = "0: USCI Automatic Stop condition generation: 0"]
UCASTP_0 = 0 , # [doc = "1: USCI Automatic Stop condition generation: 1"]
UCASTP_1 = 1 , # [doc = "2: USCI Automatic Stop condition generation: 2"]
UCASTP_2 = 2 , # [doc = "3: USCI Automatic Stop condition generation: 3"]
UCASTP_3 = 3 , } impl From < UCASTP_A > for u8 { # [inline (always)]
fn from (variant : UCASTP_A) -> Self { variant as _ } } # [doc = "Field `UCASTP` reader - USCI Automatic Stop condition generation Bit: 1"]
pub type UCASTP_R = crate :: FieldReader < u8 , UCASTP_A > ; impl UCASTP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCASTP_A { match self . bits { 0 => UCASTP_A :: UCASTP_0 , 1 => UCASTP_A :: UCASTP_1 , 2 => UCASTP_A :: UCASTP_2 , 3 => UCASTP_A :: UCASTP_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCASTP_0`"]
# [inline (always)]
pub fn is_ucastp_0 (& self) -> bool { * self == UCASTP_A :: UCASTP_0 } # [doc = "Checks if the value of the field is `UCASTP_1`"]
# [inline (always)]
pub fn is_ucastp_1 (& self) -> bool { * self == UCASTP_A :: UCASTP_1 } # [doc = "Checks if the value of the field is `UCASTP_2`"]
# [inline (always)]
pub fn is_ucastp_2 (& self) -> bool { * self == UCASTP_A :: UCASTP_2 } # [doc = "Checks if the value of the field is `UCASTP_3`"]
# [inline (always)]
pub fn is_ucastp_3 (& self) -> bool { * self == UCASTP_A :: UCASTP_3 } } # [doc = "Field `UCASTP` writer - USCI Automatic Stop condition generation Bit: 1"]
pub type UCASTP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCB0CTLW1_SPEC , u8 , UCASTP_A , 2 , O > ; impl < 'a , const O : u8 > UCASTP_W < 'a , O > { # [doc = "USCI Automatic Stop condition generation: 0"]
# [inline (always)]
pub fn ucastp_0 (self) -> & 'a mut W { self . variant (UCASTP_A :: UCASTP_0) } # [doc = "USCI Automatic Stop condition generation: 1"]
# [inline (always)]
pub fn ucastp_1 (self) -> & 'a mut W { self . variant (UCASTP_A :: UCASTP_1) } # [doc = "USCI Automatic Stop condition generation: 2"]
# [inline (always)]
pub fn ucastp_2 (self) -> & 'a mut W { self . variant (UCASTP_A :: UCASTP_2) } # [doc = "USCI Automatic Stop condition generation: 3"]
# [inline (always)]
pub fn ucastp_3 (self) -> & 'a mut W { self . variant (UCASTP_A :: UCASTP_3) } } # [doc = "Field `UCSWACK` reader - USCI Software controlled ACK"]
pub type UCSWACK_R = crate :: BitReader < bool > ; # [doc = "Field `UCSWACK` writer - USCI Software controlled ACK"]
pub type UCSWACK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0CTLW1_SPEC , bool , O > ; # [doc = "Field `UCSTPNACK` reader - USCI Acknowledge Stop last byte"]
pub type UCSTPNACK_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTPNACK` writer - USCI Acknowledge Stop last byte"]
pub type UCSTPNACK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0CTLW1_SPEC , bool , O > ; # [doc = "USCI Clock low timeout Bit: 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum UCCLTO_A { # [doc = "0: USCI Clock low timeout: 0"]
UCCLTO_0 = 0 , # [doc = "1: USCI Clock low timeout: 1"]
UCCLTO_1 = 1 , # [doc = "2: USCI Clock low timeout: 2"]
UCCLTO_2 = 2 , # [doc = "3: USCI Clock low timeout: 3"]
UCCLTO_3 = 3 , } impl From < UCCLTO_A > for u8 { # [inline (always)]
fn from (variant : UCCLTO_A) -> Self { variant as _ } } # [doc = "Field `UCCLTO` reader - USCI Clock low timeout Bit: 1"]
pub type UCCLTO_R = crate :: FieldReader < u8 , UCCLTO_A > ; impl UCCLTO_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCCLTO_A { match self . bits { 0 => UCCLTO_A :: UCCLTO_0 , 1 => UCCLTO_A :: UCCLTO_1 , 2 => UCCLTO_A :: UCCLTO_2 , 3 => UCCLTO_A :: UCCLTO_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UCCLTO_0`"]
# [inline (always)]
pub fn is_ucclto_0 (& self) -> bool { * self == UCCLTO_A :: UCCLTO_0 } # [doc = "Checks if the value of the field is `UCCLTO_1`"]
# [inline (always)]
pub fn is_ucclto_1 (& self) -> bool { * self == UCCLTO_A :: UCCLTO_1 } # [doc = "Checks if the value of the field is `UCCLTO_2`"]
# [inline (always)]
pub fn is_ucclto_2 (& self) -> bool { * self == UCCLTO_A :: UCCLTO_2 } # [doc = "Checks if the value of the field is `UCCLTO_3`"]
# [inline (always)]
pub fn is_ucclto_3 (& self) -> bool { * self == UCCLTO_A :: UCCLTO_3 } } # [doc = "Field `UCCLTO` writer - USCI Clock low timeout Bit: 1"]
pub type UCCLTO_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , UCB0CTLW1_SPEC , u8 , UCCLTO_A , 2 , O > ; impl < 'a , const O : u8 > UCCLTO_W < 'a , O > { # [doc = "USCI Clock low timeout: 0"]
# [inline (always)]
pub fn ucclto_0 (self) -> & 'a mut W { self . variant (UCCLTO_A :: UCCLTO_0) } # [doc = "USCI Clock low timeout: 1"]
# [inline (always)]
pub fn ucclto_1 (self) -> & 'a mut W { self . variant (UCCLTO_A :: UCCLTO_1) } # [doc = "USCI Clock low timeout: 2"]
# [inline (always)]
pub fn ucclto_2 (self) -> & 'a mut W { self . variant (UCCLTO_A :: UCCLTO_2) } # [doc = "USCI Clock low timeout: 3"]
# [inline (always)]
pub fn ucclto_3 (self) -> & 'a mut W { self . variant (UCCLTO_A :: UCCLTO_3) } } # [doc = "Field `UCETXINT` reader - USCI Early UCTXIFG0"]
pub type UCETXINT_R = crate :: BitReader < bool > ; # [doc = "Field `UCETXINT` writer - USCI Early UCTXIFG0"]
pub type UCETXINT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0CTLW1_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - USCI Deglitch time Bit: 1"]
# [inline (always)]
pub fn ucglit (& self) -> UCGLIT_R { UCGLIT_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - USCI Automatic Stop condition generation Bit: 1"]
# [inline (always)]
pub fn ucastp (& self) -> UCASTP_R { UCASTP_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 4 - USCI Software controlled ACK"]
# [inline (always)]
pub fn ucswack (& self) -> UCSWACK_R { UCSWACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USCI Acknowledge Stop last byte"]
# [inline (always)]
pub fn ucstpnack (& self) -> UCSTPNACK_R { UCSTPNACK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - USCI Clock low timeout Bit: 1"]
# [inline (always)]
pub fn ucclto (& self) -> UCCLTO_R { UCCLTO_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 8 - USCI Early UCTXIFG0"]
# [inline (always)]
pub fn ucetxint (& self) -> UCETXINT_R { UCETXINT_R :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - USCI Deglitch time Bit: 1"]
# [inline (always)]
pub fn ucglit (& mut self) -> UCGLIT_W < 0 > { UCGLIT_W :: new (self) } # [doc = "Bits 2:3 - USCI Automatic Stop condition generation Bit: 1"]
# [inline (always)]
pub fn ucastp (& mut self) -> UCASTP_W < 2 > { UCASTP_W :: new (self) } # [doc = "Bit 4 - USCI Software controlled ACK"]
# [inline (always)]
pub fn ucswack (& mut self) -> UCSWACK_W < 4 > { UCSWACK_W :: new (self) } # [doc = "Bit 5 - USCI Acknowledge Stop last byte"]
# [inline (always)]
pub fn ucstpnack (& mut self) -> UCSTPNACK_W < 5 > { UCSTPNACK_W :: new (self) } # [doc = "Bits 6:7 - USCI Clock low timeout Bit: 1"]
# [inline (always)]
pub fn ucclto (& mut self) -> UCCLTO_W < 6 > { UCCLTO_W :: new (self) } # [doc = "Bit 8 - USCI Early UCTXIFG0"]
# [inline (always)]
pub fn ucetxint (& mut self) -> UCETXINT_W < 8 > { UCETXINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Control Word Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctlw1](index.html) module"]
pub struct UCB0CTLW1_SPEC ; impl crate :: RegisterSpec for UCB0CTLW1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ctlw1::R](R) reader structure"]
impl crate :: Readable for UCB0CTLW1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ctlw1::W](W) writer structure"]
impl crate :: Writable for UCB0CTLW1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0CTLW1 to value 0"]
impl crate :: Resettable for UCB0CTLW1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0TBCNT register accessor: an alias for `Reg<UCB0TBCNT_SPEC>`"]
pub type UCB0TBCNT = crate :: Reg < ucb0tbcnt :: UCB0TBCNT_SPEC > ; # [doc = "USCI B0 Byte Counter Threshold Register"]
pub mod ucb0tbcnt { # [doc = "Register `UCB0TBCNT` reader"]
pub struct R (crate :: R < UCB0TBCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0TBCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0TBCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0TBCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0TBCNT` writer"]
pub struct W (crate :: W < UCB0TBCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0TBCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0TBCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0TBCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Byte Counter Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0tbcnt](index.html) module"]
pub struct UCB0TBCNT_SPEC ; impl crate :: RegisterSpec for UCB0TBCNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0tbcnt::R](R) reader structure"]
impl crate :: Readable for UCB0TBCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0tbcnt::W](W) writer structure"]
impl crate :: Writable for UCB0TBCNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0TBCNT to value 0"]
impl crate :: Resettable for UCB0TBCNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0RXBUF register accessor: an alias for `Reg<UCB0RXBUF_SPEC>`"]
pub type UCB0RXBUF = crate :: Reg < ucb0rxbuf :: UCB0RXBUF_SPEC > ; # [doc = "USCI B0 Receive Buffer"]
pub mod ucb0rxbuf { # [doc = "Register `UCB0RXBUF` reader"]
pub struct R (crate :: R < UCB0RXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0RXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0RXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0RXBUF` writer"]
pub struct W (crate :: W < UCB0RXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0RXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0RXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0RXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf](index.html) module"]
pub struct UCB0RXBUF_SPEC ; impl crate :: RegisterSpec for UCB0RXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0rxbuf::R](R) reader structure"]
impl crate :: Readable for UCB0RXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0rxbuf::W](W) writer structure"]
impl crate :: Writable for UCB0RXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0RXBUF to value 0"]
impl crate :: Resettable for UCB0RXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0TXBUF register accessor: an alias for `Reg<UCB0TXBUF_SPEC>`"]
pub type UCB0TXBUF = crate :: Reg < ucb0txbuf :: UCB0TXBUF_SPEC > ; # [doc = "USCI B0 Transmit Buffer"]
pub mod ucb0txbuf { # [doc = "Register `UCB0TXBUF` reader"]
pub struct R (crate :: R < UCB0TXBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0TXBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0TXBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0TXBUF` writer"]
pub struct W (crate :: W < UCB0TXBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0TXBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0TXBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0TXBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf](index.html) module"]
pub struct UCB0TXBUF_SPEC ; impl crate :: RegisterSpec for UCB0TXBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0txbuf::R](R) reader structure"]
impl crate :: Readable for UCB0TXBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0txbuf::W](W) writer structure"]
impl crate :: Writable for UCB0TXBUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0TXBUF to value 0"]
impl crate :: Resettable for UCB0TXBUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0I2COA0 register accessor: an alias for `Reg<UCB0I2COA0_SPEC>`"]
pub type UCB0I2COA0 = crate :: Reg < ucb0i2coa0 :: UCB0I2COA0_SPEC > ; # [doc = "USCI B0 I2C Own Address 0"]
pub mod ucb0i2coa0 { # [doc = "Register `UCB0I2COA0` reader"]
pub struct R (crate :: R < UCB0I2COA0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0I2COA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0I2COA0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0I2COA0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0I2COA0` writer"]
pub struct W (crate :: W < UCB0I2COA0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0I2COA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0I2COA0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0I2COA0_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOA0` reader - I2C Own Address Bit 0"]
pub type UCOA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA0` writer - I2C Own Address Bit 0"]
pub type UCOA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA1` reader - I2C Own Address Bit 1"]
pub type UCOA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA1` writer - I2C Own Address Bit 1"]
pub type UCOA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA2` reader - I2C Own Address Bit 2"]
pub type UCOA2_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA2` writer - I2C Own Address Bit 2"]
pub type UCOA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA3` reader - I2C Own Address Bit 3"]
pub type UCOA3_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA3` writer - I2C Own Address Bit 3"]
pub type UCOA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA4` reader - I2C Own Address Bit 4"]
pub type UCOA4_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA4` writer - I2C Own Address Bit 4"]
pub type UCOA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA5` reader - I2C Own Address Bit 5"]
pub type UCOA5_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA5` writer - I2C Own Address Bit 5"]
pub type UCOA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA6` reader - I2C Own Address Bit 6"]
pub type UCOA6_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA6` writer - I2C Own Address Bit 6"]
pub type UCOA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA7` reader - I2C Own Address Bit 7"]
pub type UCOA7_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA7` writer - I2C Own Address Bit 7"]
pub type UCOA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA8` reader - I2C Own Address Bit 8"]
pub type UCOA8_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA8` writer - I2C Own Address Bit 8"]
pub type UCOA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOA9` reader - I2C Own Address Bit 9"]
pub type UCOA9_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA9` writer - I2C Own Address Bit 9"]
pub type UCOA9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCOAEN` reader - I2C Own Address enable"]
pub type UCOAEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCOAEN` writer - I2C Own Address enable"]
pub type UCOAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; # [doc = "Field `UCGCEN` reader - I2C General Call enable"]
pub type UCGCEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCGCEN` writer - I2C General Call enable"]
pub type UCGCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& self) -> UCOA0_R { UCOA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& self) -> UCOA1_R { UCOA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& self) -> UCOA2_R { UCOA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& self) -> UCOA3_R { UCOA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& self) -> UCOA4_R { UCOA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& self) -> UCOA5_R { UCOA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& self) -> UCOA6_R { UCOA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& self) -> UCOA7_R { UCOA7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& self) -> UCOA8_R { UCOA8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& self) -> UCOA9_R { UCOA9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& self) -> UCOAEN_R { UCOAEN_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 15 - I2C General Call enable"]
# [inline (always)]
pub fn ucgcen (& self) -> UCGCEN_R { UCGCEN_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& mut self) -> UCOA0_W < 0 > { UCOA0_W :: new (self) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& mut self) -> UCOA1_W < 1 > { UCOA1_W :: new (self) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& mut self) -> UCOA2_W < 2 > { UCOA2_W :: new (self) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& mut self) -> UCOA3_W < 3 > { UCOA3_W :: new (self) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& mut self) -> UCOA4_W < 4 > { UCOA4_W :: new (self) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& mut self) -> UCOA5_W < 5 > { UCOA5_W :: new (self) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& mut self) -> UCOA6_W < 6 > { UCOA6_W :: new (self) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& mut self) -> UCOA7_W < 7 > { UCOA7_W :: new (self) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& mut self) -> UCOA8_W < 8 > { UCOA8_W :: new (self) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& mut self) -> UCOA9_W < 9 > { UCOA9_W :: new (self) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& mut self) -> UCOAEN_W < 10 > { UCOAEN_W :: new (self) } # [doc = "Bit 15 - I2C General Call enable"]
# [inline (always)]
pub fn ucgcen (& mut self) -> UCGCEN_W < 15 > { UCGCEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 I2C Own Address 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa0](index.html) module"]
pub struct UCB0I2COA0_SPEC ; impl crate :: RegisterSpec for UCB0I2COA0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0i2coa0::R](R) reader structure"]
impl crate :: Readable for UCB0I2COA0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0i2coa0::W](W) writer structure"]
impl crate :: Writable for UCB0I2COA0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0I2COA0 to value 0"]
impl crate :: Resettable for UCB0I2COA0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0I2COA1 register accessor: an alias for `Reg<UCB0I2COA1_SPEC>`"]
pub type UCB0I2COA1 = crate :: Reg < ucb0i2coa1 :: UCB0I2COA1_SPEC > ; # [doc = "USCI B0 I2C Own Address 1"]
pub mod ucb0i2coa1 { # [doc = "Register `UCB0I2COA1` reader"]
pub struct R (crate :: R < UCB0I2COA1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0I2COA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0I2COA1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0I2COA1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0I2COA1` writer"]
pub struct W (crate :: W < UCB0I2COA1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0I2COA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0I2COA1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0I2COA1_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOA0` reader - I2C Own Address Bit 0"]
pub type UCOA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA0` writer - I2C Own Address Bit 0"]
pub type UCOA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA1` reader - I2C Own Address Bit 1"]
pub type UCOA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA1` writer - I2C Own Address Bit 1"]
pub type UCOA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA2` reader - I2C Own Address Bit 2"]
pub type UCOA2_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA2` writer - I2C Own Address Bit 2"]
pub type UCOA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA3` reader - I2C Own Address Bit 3"]
pub type UCOA3_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA3` writer - I2C Own Address Bit 3"]
pub type UCOA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA4` reader - I2C Own Address Bit 4"]
pub type UCOA4_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA4` writer - I2C Own Address Bit 4"]
pub type UCOA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA5` reader - I2C Own Address Bit 5"]
pub type UCOA5_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA5` writer - I2C Own Address Bit 5"]
pub type UCOA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA6` reader - I2C Own Address Bit 6"]
pub type UCOA6_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA6` writer - I2C Own Address Bit 6"]
pub type UCOA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA7` reader - I2C Own Address Bit 7"]
pub type UCOA7_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA7` writer - I2C Own Address Bit 7"]
pub type UCOA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA8` reader - I2C Own Address Bit 8"]
pub type UCOA8_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA8` writer - I2C Own Address Bit 8"]
pub type UCOA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOA9` reader - I2C Own Address Bit 9"]
pub type UCOA9_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA9` writer - I2C Own Address Bit 9"]
pub type UCOA9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; # [doc = "Field `UCOAEN` reader - I2C Own Address enable"]
pub type UCOAEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCOAEN` writer - I2C Own Address enable"]
pub type UCOAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& self) -> UCOA0_R { UCOA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& self) -> UCOA1_R { UCOA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& self) -> UCOA2_R { UCOA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& self) -> UCOA3_R { UCOA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& self) -> UCOA4_R { UCOA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& self) -> UCOA5_R { UCOA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& self) -> UCOA6_R { UCOA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& self) -> UCOA7_R { UCOA7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& self) -> UCOA8_R { UCOA8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& self) -> UCOA9_R { UCOA9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& self) -> UCOAEN_R { UCOAEN_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& mut self) -> UCOA0_W < 0 > { UCOA0_W :: new (self) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& mut self) -> UCOA1_W < 1 > { UCOA1_W :: new (self) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& mut self) -> UCOA2_W < 2 > { UCOA2_W :: new (self) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& mut self) -> UCOA3_W < 3 > { UCOA3_W :: new (self) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& mut self) -> UCOA4_W < 4 > { UCOA4_W :: new (self) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& mut self) -> UCOA5_W < 5 > { UCOA5_W :: new (self) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& mut self) -> UCOA6_W < 6 > { UCOA6_W :: new (self) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& mut self) -> UCOA7_W < 7 > { UCOA7_W :: new (self) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& mut self) -> UCOA8_W < 8 > { UCOA8_W :: new (self) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& mut self) -> UCOA9_W < 9 > { UCOA9_W :: new (self) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& mut self) -> UCOAEN_W < 10 > { UCOAEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 I2C Own Address 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa1](index.html) module"]
pub struct UCB0I2COA1_SPEC ; impl crate :: RegisterSpec for UCB0I2COA1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0i2coa1::R](R) reader structure"]
impl crate :: Readable for UCB0I2COA1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0i2coa1::W](W) writer structure"]
impl crate :: Writable for UCB0I2COA1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0I2COA1 to value 0"]
impl crate :: Resettable for UCB0I2COA1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0I2COA2 register accessor: an alias for `Reg<UCB0I2COA2_SPEC>`"]
pub type UCB0I2COA2 = crate :: Reg < ucb0i2coa2 :: UCB0I2COA2_SPEC > ; # [doc = "USCI B0 I2C Own Address 2"]
pub mod ucb0i2coa2 { # [doc = "Register `UCB0I2COA2` reader"]
pub struct R (crate :: R < UCB0I2COA2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0I2COA2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0I2COA2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0I2COA2_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0I2COA2` writer"]
pub struct W (crate :: W < UCB0I2COA2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0I2COA2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0I2COA2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0I2COA2_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOA0` reader - I2C Own Address Bit 0"]
pub type UCOA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA0` writer - I2C Own Address Bit 0"]
pub type UCOA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA1` reader - I2C Own Address Bit 1"]
pub type UCOA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA1` writer - I2C Own Address Bit 1"]
pub type UCOA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA2` reader - I2C Own Address Bit 2"]
pub type UCOA2_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA2` writer - I2C Own Address Bit 2"]
pub type UCOA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA3` reader - I2C Own Address Bit 3"]
pub type UCOA3_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA3` writer - I2C Own Address Bit 3"]
pub type UCOA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA4` reader - I2C Own Address Bit 4"]
pub type UCOA4_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA4` writer - I2C Own Address Bit 4"]
pub type UCOA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA5` reader - I2C Own Address Bit 5"]
pub type UCOA5_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA5` writer - I2C Own Address Bit 5"]
pub type UCOA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA6` reader - I2C Own Address Bit 6"]
pub type UCOA6_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA6` writer - I2C Own Address Bit 6"]
pub type UCOA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA7` reader - I2C Own Address Bit 7"]
pub type UCOA7_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA7` writer - I2C Own Address Bit 7"]
pub type UCOA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA8` reader - I2C Own Address Bit 8"]
pub type UCOA8_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA8` writer - I2C Own Address Bit 8"]
pub type UCOA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOA9` reader - I2C Own Address Bit 9"]
pub type UCOA9_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA9` writer - I2C Own Address Bit 9"]
pub type UCOA9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; # [doc = "Field `UCOAEN` reader - I2C Own Address enable"]
pub type UCOAEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCOAEN` writer - I2C Own Address enable"]
pub type UCOAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& self) -> UCOA0_R { UCOA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& self) -> UCOA1_R { UCOA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& self) -> UCOA2_R { UCOA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& self) -> UCOA3_R { UCOA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& self) -> UCOA4_R { UCOA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& self) -> UCOA5_R { UCOA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& self) -> UCOA6_R { UCOA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& self) -> UCOA7_R { UCOA7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& self) -> UCOA8_R { UCOA8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& self) -> UCOA9_R { UCOA9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& self) -> UCOAEN_R { UCOAEN_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& mut self) -> UCOA0_W < 0 > { UCOA0_W :: new (self) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& mut self) -> UCOA1_W < 1 > { UCOA1_W :: new (self) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& mut self) -> UCOA2_W < 2 > { UCOA2_W :: new (self) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& mut self) -> UCOA3_W < 3 > { UCOA3_W :: new (self) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& mut self) -> UCOA4_W < 4 > { UCOA4_W :: new (self) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& mut self) -> UCOA5_W < 5 > { UCOA5_W :: new (self) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& mut self) -> UCOA6_W < 6 > { UCOA6_W :: new (self) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& mut self) -> UCOA7_W < 7 > { UCOA7_W :: new (self) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& mut self) -> UCOA8_W < 8 > { UCOA8_W :: new (self) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& mut self) -> UCOA9_W < 9 > { UCOA9_W :: new (self) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& mut self) -> UCOAEN_W < 10 > { UCOAEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 I2C Own Address 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa2](index.html) module"]
pub struct UCB0I2COA2_SPEC ; impl crate :: RegisterSpec for UCB0I2COA2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0i2coa2::R](R) reader structure"]
impl crate :: Readable for UCB0I2COA2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0i2coa2::W](W) writer structure"]
impl crate :: Writable for UCB0I2COA2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0I2COA2 to value 0"]
impl crate :: Resettable for UCB0I2COA2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0I2COA3 register accessor: an alias for `Reg<UCB0I2COA3_SPEC>`"]
pub type UCB0I2COA3 = crate :: Reg < ucb0i2coa3 :: UCB0I2COA3_SPEC > ; # [doc = "USCI B0 I2C Own Address 3"]
pub mod ucb0i2coa3 { # [doc = "Register `UCB0I2COA3` reader"]
pub struct R (crate :: R < UCB0I2COA3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0I2COA3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0I2COA3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0I2COA3_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0I2COA3` writer"]
pub struct W (crate :: W < UCB0I2COA3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0I2COA3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0I2COA3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0I2COA3_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCOA0` reader - I2C Own Address Bit 0"]
pub type UCOA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA0` writer - I2C Own Address Bit 0"]
pub type UCOA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA1` reader - I2C Own Address Bit 1"]
pub type UCOA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA1` writer - I2C Own Address Bit 1"]
pub type UCOA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA2` reader - I2C Own Address Bit 2"]
pub type UCOA2_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA2` writer - I2C Own Address Bit 2"]
pub type UCOA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA3` reader - I2C Own Address Bit 3"]
pub type UCOA3_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA3` writer - I2C Own Address Bit 3"]
pub type UCOA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA4` reader - I2C Own Address Bit 4"]
pub type UCOA4_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA4` writer - I2C Own Address Bit 4"]
pub type UCOA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA5` reader - I2C Own Address Bit 5"]
pub type UCOA5_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA5` writer - I2C Own Address Bit 5"]
pub type UCOA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA6` reader - I2C Own Address Bit 6"]
pub type UCOA6_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA6` writer - I2C Own Address Bit 6"]
pub type UCOA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA7` reader - I2C Own Address Bit 7"]
pub type UCOA7_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA7` writer - I2C Own Address Bit 7"]
pub type UCOA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA8` reader - I2C Own Address Bit 8"]
pub type UCOA8_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA8` writer - I2C Own Address Bit 8"]
pub type UCOA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOA9` reader - I2C Own Address Bit 9"]
pub type UCOA9_R = crate :: BitReader < bool > ; # [doc = "Field `UCOA9` writer - I2C Own Address Bit 9"]
pub type UCOA9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; # [doc = "Field `UCOAEN` reader - I2C Own Address enable"]
pub type UCOAEN_R = crate :: BitReader < bool > ; # [doc = "Field `UCOAEN` writer - I2C Own Address enable"]
pub type UCOAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2COA3_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& self) -> UCOA0_R { UCOA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& self) -> UCOA1_R { UCOA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& self) -> UCOA2_R { UCOA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& self) -> UCOA3_R { UCOA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& self) -> UCOA4_R { UCOA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& self) -> UCOA5_R { UCOA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& self) -> UCOA6_R { UCOA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& self) -> UCOA7_R { UCOA7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& self) -> UCOA8_R { UCOA8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& self) -> UCOA9_R { UCOA9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& self) -> UCOAEN_R { UCOAEN_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Own Address Bit 0"]
# [inline (always)]
pub fn ucoa0 (& mut self) -> UCOA0_W < 0 > { UCOA0_W :: new (self) } # [doc = "Bit 1 - I2C Own Address Bit 1"]
# [inline (always)]
pub fn ucoa1 (& mut self) -> UCOA1_W < 1 > { UCOA1_W :: new (self) } # [doc = "Bit 2 - I2C Own Address Bit 2"]
# [inline (always)]
pub fn ucoa2 (& mut self) -> UCOA2_W < 2 > { UCOA2_W :: new (self) } # [doc = "Bit 3 - I2C Own Address Bit 3"]
# [inline (always)]
pub fn ucoa3 (& mut self) -> UCOA3_W < 3 > { UCOA3_W :: new (self) } # [doc = "Bit 4 - I2C Own Address Bit 4"]
# [inline (always)]
pub fn ucoa4 (& mut self) -> UCOA4_W < 4 > { UCOA4_W :: new (self) } # [doc = "Bit 5 - I2C Own Address Bit 5"]
# [inline (always)]
pub fn ucoa5 (& mut self) -> UCOA5_W < 5 > { UCOA5_W :: new (self) } # [doc = "Bit 6 - I2C Own Address Bit 6"]
# [inline (always)]
pub fn ucoa6 (& mut self) -> UCOA6_W < 6 > { UCOA6_W :: new (self) } # [doc = "Bit 7 - I2C Own Address Bit 7"]
# [inline (always)]
pub fn ucoa7 (& mut self) -> UCOA7_W < 7 > { UCOA7_W :: new (self) } # [doc = "Bit 8 - I2C Own Address Bit 8"]
# [inline (always)]
pub fn ucoa8 (& mut self) -> UCOA8_W < 8 > { UCOA8_W :: new (self) } # [doc = "Bit 9 - I2C Own Address Bit 9"]
# [inline (always)]
pub fn ucoa9 (& mut self) -> UCOA9_W < 9 > { UCOA9_W :: new (self) } # [doc = "Bit 10 - I2C Own Address enable"]
# [inline (always)]
pub fn ucoaen (& mut self) -> UCOAEN_W < 10 > { UCOAEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 I2C Own Address 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2coa3](index.html) module"]
pub struct UCB0I2COA3_SPEC ; impl crate :: RegisterSpec for UCB0I2COA3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0i2coa3::R](R) reader structure"]
impl crate :: Readable for UCB0I2COA3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0i2coa3::W](W) writer structure"]
impl crate :: Writable for UCB0I2COA3_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0I2COA3 to value 0"]
impl crate :: Resettable for UCB0I2COA3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0ADDRX register accessor: an alias for `Reg<UCB0ADDRX_SPEC>`"]
pub type UCB0ADDRX = crate :: Reg < ucb0addrx :: UCB0ADDRX_SPEC > ; # [doc = "USCI B0 Received Address Register"]
pub mod ucb0addrx { # [doc = "Register `UCB0ADDRX` reader"]
pub struct R (crate :: R < UCB0ADDRX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0ADDRX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0ADDRX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0ADDRX_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0ADDRX` writer"]
pub struct W (crate :: W < UCB0ADDRX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0ADDRX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0ADDRX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0ADDRX_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCADDRX0` reader - I2C Receive Address Bit 0"]
pub type UCADDRX0_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX0` writer - I2C Receive Address Bit 0"]
pub type UCADDRX0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX1` reader - I2C Receive Address Bit 1"]
pub type UCADDRX1_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX1` writer - I2C Receive Address Bit 1"]
pub type UCADDRX1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX2` reader - I2C Receive Address Bit 2"]
pub type UCADDRX2_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX2` writer - I2C Receive Address Bit 2"]
pub type UCADDRX2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX3` reader - I2C Receive Address Bit 3"]
pub type UCADDRX3_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX3` writer - I2C Receive Address Bit 3"]
pub type UCADDRX3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX4` reader - I2C Receive Address Bit 4"]
pub type UCADDRX4_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX4` writer - I2C Receive Address Bit 4"]
pub type UCADDRX4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX5` reader - I2C Receive Address Bit 5"]
pub type UCADDRX5_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX5` writer - I2C Receive Address Bit 5"]
pub type UCADDRX5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX6` reader - I2C Receive Address Bit 6"]
pub type UCADDRX6_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX6` writer - I2C Receive Address Bit 6"]
pub type UCADDRX6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX7` reader - I2C Receive Address Bit 7"]
pub type UCADDRX7_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX7` writer - I2C Receive Address Bit 7"]
pub type UCADDRX7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX8` reader - I2C Receive Address Bit 8"]
pub type UCADDRX8_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX8` writer - I2C Receive Address Bit 8"]
pub type UCADDRX8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; # [doc = "Field `UCADDRX9` reader - I2C Receive Address Bit 9"]
pub type UCADDRX9_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDRX9` writer - I2C Receive Address Bit 9"]
pub type UCADDRX9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDRX_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Receive Address Bit 0"]
# [inline (always)]
pub fn ucaddrx0 (& self) -> UCADDRX0_R { UCADDRX0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Receive Address Bit 1"]
# [inline (always)]
pub fn ucaddrx1 (& self) -> UCADDRX1_R { UCADDRX1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Receive Address Bit 2"]
# [inline (always)]
pub fn ucaddrx2 (& self) -> UCADDRX2_R { UCADDRX2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Receive Address Bit 3"]
# [inline (always)]
pub fn ucaddrx3 (& self) -> UCADDRX3_R { UCADDRX3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Receive Address Bit 4"]
# [inline (always)]
pub fn ucaddrx4 (& self) -> UCADDRX4_R { UCADDRX4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Receive Address Bit 5"]
# [inline (always)]
pub fn ucaddrx5 (& self) -> UCADDRX5_R { UCADDRX5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Receive Address Bit 6"]
# [inline (always)]
pub fn ucaddrx6 (& self) -> UCADDRX6_R { UCADDRX6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Receive Address Bit 7"]
# [inline (always)]
pub fn ucaddrx7 (& self) -> UCADDRX7_R { UCADDRX7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Receive Address Bit 8"]
# [inline (always)]
pub fn ucaddrx8 (& self) -> UCADDRX8_R { UCADDRX8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Receive Address Bit 9"]
# [inline (always)]
pub fn ucaddrx9 (& self) -> UCADDRX9_R { UCADDRX9_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Receive Address Bit 0"]
# [inline (always)]
pub fn ucaddrx0 (& mut self) -> UCADDRX0_W < 0 > { UCADDRX0_W :: new (self) } # [doc = "Bit 1 - I2C Receive Address Bit 1"]
# [inline (always)]
pub fn ucaddrx1 (& mut self) -> UCADDRX1_W < 1 > { UCADDRX1_W :: new (self) } # [doc = "Bit 2 - I2C Receive Address Bit 2"]
# [inline (always)]
pub fn ucaddrx2 (& mut self) -> UCADDRX2_W < 2 > { UCADDRX2_W :: new (self) } # [doc = "Bit 3 - I2C Receive Address Bit 3"]
# [inline (always)]
pub fn ucaddrx3 (& mut self) -> UCADDRX3_W < 3 > { UCADDRX3_W :: new (self) } # [doc = "Bit 4 - I2C Receive Address Bit 4"]
# [inline (always)]
pub fn ucaddrx4 (& mut self) -> UCADDRX4_W < 4 > { UCADDRX4_W :: new (self) } # [doc = "Bit 5 - I2C Receive Address Bit 5"]
# [inline (always)]
pub fn ucaddrx5 (& mut self) -> UCADDRX5_W < 5 > { UCADDRX5_W :: new (self) } # [doc = "Bit 6 - I2C Receive Address Bit 6"]
# [inline (always)]
pub fn ucaddrx6 (& mut self) -> UCADDRX6_W < 6 > { UCADDRX6_W :: new (self) } # [doc = "Bit 7 - I2C Receive Address Bit 7"]
# [inline (always)]
pub fn ucaddrx7 (& mut self) -> UCADDRX7_W < 7 > { UCADDRX7_W :: new (self) } # [doc = "Bit 8 - I2C Receive Address Bit 8"]
# [inline (always)]
pub fn ucaddrx8 (& mut self) -> UCADDRX8_W < 8 > { UCADDRX8_W :: new (self) } # [doc = "Bit 9 - I2C Receive Address Bit 9"]
# [inline (always)]
pub fn ucaddrx9 (& mut self) -> UCADDRX9_W < 9 > { UCADDRX9_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Received Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addrx](index.html) module"]
pub struct UCB0ADDRX_SPEC ; impl crate :: RegisterSpec for UCB0ADDRX_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0addrx::R](R) reader structure"]
impl crate :: Readable for UCB0ADDRX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0addrx::W](W) writer structure"]
impl crate :: Writable for UCB0ADDRX_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0ADDRX to value 0"]
impl crate :: Resettable for UCB0ADDRX_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0ADDMASK register accessor: an alias for `Reg<UCB0ADDMASK_SPEC>`"]
pub type UCB0ADDMASK = crate :: Reg < ucb0addmask :: UCB0ADDMASK_SPEC > ; # [doc = "USCI B0 Address Mask Register"]
pub mod ucb0addmask { # [doc = "Register `UCB0ADDMASK` reader"]
pub struct R (crate :: R < UCB0ADDMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0ADDMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0ADDMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0ADDMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0ADDMASK` writer"]
pub struct W (crate :: W < UCB0ADDMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0ADDMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0ADDMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0ADDMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCADDMASK0` reader - I2C Address Mask Bit 0"]
pub type UCADDMASK0_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK0` writer - I2C Address Mask Bit 0"]
pub type UCADDMASK0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK1` reader - I2C Address Mask Bit 1"]
pub type UCADDMASK1_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK1` writer - I2C Address Mask Bit 1"]
pub type UCADDMASK1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK2` reader - I2C Address Mask Bit 2"]
pub type UCADDMASK2_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK2` writer - I2C Address Mask Bit 2"]
pub type UCADDMASK2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK3` reader - I2C Address Mask Bit 3"]
pub type UCADDMASK3_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK3` writer - I2C Address Mask Bit 3"]
pub type UCADDMASK3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK4` reader - I2C Address Mask Bit 4"]
pub type UCADDMASK4_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK4` writer - I2C Address Mask Bit 4"]
pub type UCADDMASK4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK5` reader - I2C Address Mask Bit 5"]
pub type UCADDMASK5_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK5` writer - I2C Address Mask Bit 5"]
pub type UCADDMASK5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK6` reader - I2C Address Mask Bit 6"]
pub type UCADDMASK6_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK6` writer - I2C Address Mask Bit 6"]
pub type UCADDMASK6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK7` reader - I2C Address Mask Bit 7"]
pub type UCADDMASK7_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK7` writer - I2C Address Mask Bit 7"]
pub type UCADDMASK7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK8` reader - I2C Address Mask Bit 8"]
pub type UCADDMASK8_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK8` writer - I2C Address Mask Bit 8"]
pub type UCADDMASK8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; # [doc = "Field `UCADDMASK9` reader - I2C Address Mask Bit 9"]
pub type UCADDMASK9_R = crate :: BitReader < bool > ; # [doc = "Field `UCADDMASK9` writer - I2C Address Mask Bit 9"]
pub type UCADDMASK9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0ADDMASK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Address Mask Bit 0"]
# [inline (always)]
pub fn ucaddmask0 (& self) -> UCADDMASK0_R { UCADDMASK0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Address Mask Bit 1"]
# [inline (always)]
pub fn ucaddmask1 (& self) -> UCADDMASK1_R { UCADDMASK1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Address Mask Bit 2"]
# [inline (always)]
pub fn ucaddmask2 (& self) -> UCADDMASK2_R { UCADDMASK2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Address Mask Bit 3"]
# [inline (always)]
pub fn ucaddmask3 (& self) -> UCADDMASK3_R { UCADDMASK3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Address Mask Bit 4"]
# [inline (always)]
pub fn ucaddmask4 (& self) -> UCADDMASK4_R { UCADDMASK4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Address Mask Bit 5"]
# [inline (always)]
pub fn ucaddmask5 (& self) -> UCADDMASK5_R { UCADDMASK5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Address Mask Bit 6"]
# [inline (always)]
pub fn ucaddmask6 (& self) -> UCADDMASK6_R { UCADDMASK6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Address Mask Bit 7"]
# [inline (always)]
pub fn ucaddmask7 (& self) -> UCADDMASK7_R { UCADDMASK7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Address Mask Bit 8"]
# [inline (always)]
pub fn ucaddmask8 (& self) -> UCADDMASK8_R { UCADDMASK8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Address Mask Bit 9"]
# [inline (always)]
pub fn ucaddmask9 (& self) -> UCADDMASK9_R { UCADDMASK9_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Address Mask Bit 0"]
# [inline (always)]
pub fn ucaddmask0 (& mut self) -> UCADDMASK0_W < 0 > { UCADDMASK0_W :: new (self) } # [doc = "Bit 1 - I2C Address Mask Bit 1"]
# [inline (always)]
pub fn ucaddmask1 (& mut self) -> UCADDMASK1_W < 1 > { UCADDMASK1_W :: new (self) } # [doc = "Bit 2 - I2C Address Mask Bit 2"]
# [inline (always)]
pub fn ucaddmask2 (& mut self) -> UCADDMASK2_W < 2 > { UCADDMASK2_W :: new (self) } # [doc = "Bit 3 - I2C Address Mask Bit 3"]
# [inline (always)]
pub fn ucaddmask3 (& mut self) -> UCADDMASK3_W < 3 > { UCADDMASK3_W :: new (self) } # [doc = "Bit 4 - I2C Address Mask Bit 4"]
# [inline (always)]
pub fn ucaddmask4 (& mut self) -> UCADDMASK4_W < 4 > { UCADDMASK4_W :: new (self) } # [doc = "Bit 5 - I2C Address Mask Bit 5"]
# [inline (always)]
pub fn ucaddmask5 (& mut self) -> UCADDMASK5_W < 5 > { UCADDMASK5_W :: new (self) } # [doc = "Bit 6 - I2C Address Mask Bit 6"]
# [inline (always)]
pub fn ucaddmask6 (& mut self) -> UCADDMASK6_W < 6 > { UCADDMASK6_W :: new (self) } # [doc = "Bit 7 - I2C Address Mask Bit 7"]
# [inline (always)]
pub fn ucaddmask7 (& mut self) -> UCADDMASK7_W < 7 > { UCADDMASK7_W :: new (self) } # [doc = "Bit 8 - I2C Address Mask Bit 8"]
# [inline (always)]
pub fn ucaddmask8 (& mut self) -> UCADDMASK8_W < 8 > { UCADDMASK8_W :: new (self) } # [doc = "Bit 9 - I2C Address Mask Bit 9"]
# [inline (always)]
pub fn ucaddmask9 (& mut self) -> UCADDMASK9_W < 9 > { UCADDMASK9_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0addmask](index.html) module"]
pub struct UCB0ADDMASK_SPEC ; impl crate :: RegisterSpec for UCB0ADDMASK_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0addmask::R](R) reader structure"]
impl crate :: Readable for UCB0ADDMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0addmask::W](W) writer structure"]
impl crate :: Writable for UCB0ADDMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0ADDMASK to value 0"]
impl crate :: Resettable for UCB0ADDMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0I2CSA register accessor: an alias for `Reg<UCB0I2CSA_SPEC>`"]
pub type UCB0I2CSA = crate :: Reg < ucb0i2csa :: UCB0I2CSA_SPEC > ; # [doc = "USCI B0 I2C Slave Address"]
pub mod ucb0i2csa { # [doc = "Register `UCB0I2CSA` reader"]
pub struct R (crate :: R < UCB0I2CSA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0I2CSA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0I2CSA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0I2CSA_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0I2CSA` writer"]
pub struct W (crate :: W < UCB0I2CSA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0I2CSA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0I2CSA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0I2CSA_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCSA0` reader - I2C Slave Address Bit 0"]
pub type UCSA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA0` writer - I2C Slave Address Bit 0"]
pub type UCSA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA1` reader - I2C Slave Address Bit 1"]
pub type UCSA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA1` writer - I2C Slave Address Bit 1"]
pub type UCSA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA2` reader - I2C Slave Address Bit 2"]
pub type UCSA2_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA2` writer - I2C Slave Address Bit 2"]
pub type UCSA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA3` reader - I2C Slave Address Bit 3"]
pub type UCSA3_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA3` writer - I2C Slave Address Bit 3"]
pub type UCSA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA4` reader - I2C Slave Address Bit 4"]
pub type UCSA4_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA4` writer - I2C Slave Address Bit 4"]
pub type UCSA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA5` reader - I2C Slave Address Bit 5"]
pub type UCSA5_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA5` writer - I2C Slave Address Bit 5"]
pub type UCSA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA6` reader - I2C Slave Address Bit 6"]
pub type UCSA6_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA6` writer - I2C Slave Address Bit 6"]
pub type UCSA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA7` reader - I2C Slave Address Bit 7"]
pub type UCSA7_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA7` writer - I2C Slave Address Bit 7"]
pub type UCSA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA8` reader - I2C Slave Address Bit 8"]
pub type UCSA8_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA8` writer - I2C Slave Address Bit 8"]
pub type UCSA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; # [doc = "Field `UCSA9` reader - I2C Slave Address Bit 9"]
pub type UCSA9_R = crate :: BitReader < bool > ; # [doc = "Field `UCSA9` writer - I2C Slave Address Bit 9"]
pub type UCSA9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0I2CSA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Slave Address Bit 0"]
# [inline (always)]
pub fn ucsa0 (& self) -> UCSA0_R { UCSA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Slave Address Bit 1"]
# [inline (always)]
pub fn ucsa1 (& self) -> UCSA1_R { UCSA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C Slave Address Bit 2"]
# [inline (always)]
pub fn ucsa2 (& self) -> UCSA2_R { UCSA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C Slave Address Bit 3"]
# [inline (always)]
pub fn ucsa3 (& self) -> UCSA3_R { UCSA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Slave Address Bit 4"]
# [inline (always)]
pub fn ucsa4 (& self) -> UCSA4_R { UCSA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C Slave Address Bit 5"]
# [inline (always)]
pub fn ucsa5 (& self) -> UCSA5_R { UCSA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Slave Address Bit 6"]
# [inline (always)]
pub fn ucsa6 (& self) -> UCSA6_R { UCSA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Slave Address Bit 7"]
# [inline (always)]
pub fn ucsa7 (& self) -> UCSA7_R { UCSA7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Slave Address Bit 8"]
# [inline (always)]
pub fn ucsa8 (& self) -> UCSA8_R { UCSA8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Slave Address Bit 9"]
# [inline (always)]
pub fn ucsa9 (& self) -> UCSA9_R { UCSA9_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Slave Address Bit 0"]
# [inline (always)]
pub fn ucsa0 (& mut self) -> UCSA0_W < 0 > { UCSA0_W :: new (self) } # [doc = "Bit 1 - I2C Slave Address Bit 1"]
# [inline (always)]
pub fn ucsa1 (& mut self) -> UCSA1_W < 1 > { UCSA1_W :: new (self) } # [doc = "Bit 2 - I2C Slave Address Bit 2"]
# [inline (always)]
pub fn ucsa2 (& mut self) -> UCSA2_W < 2 > { UCSA2_W :: new (self) } # [doc = "Bit 3 - I2C Slave Address Bit 3"]
# [inline (always)]
pub fn ucsa3 (& mut self) -> UCSA3_W < 3 > { UCSA3_W :: new (self) } # [doc = "Bit 4 - I2C Slave Address Bit 4"]
# [inline (always)]
pub fn ucsa4 (& mut self) -> UCSA4_W < 4 > { UCSA4_W :: new (self) } # [doc = "Bit 5 - I2C Slave Address Bit 5"]
# [inline (always)]
pub fn ucsa5 (& mut self) -> UCSA5_W < 5 > { UCSA5_W :: new (self) } # [doc = "Bit 6 - I2C Slave Address Bit 6"]
# [inline (always)]
pub fn ucsa6 (& mut self) -> UCSA6_W < 6 > { UCSA6_W :: new (self) } # [doc = "Bit 7 - I2C Slave Address Bit 7"]
# [inline (always)]
pub fn ucsa7 (& mut self) -> UCSA7_W < 7 > { UCSA7_W :: new (self) } # [doc = "Bit 8 - I2C Slave Address Bit 8"]
# [inline (always)]
pub fn ucsa8 (& mut self) -> UCSA8_W < 8 > { UCSA8_W :: new (self) } # [doc = "Bit 9 - I2C Slave Address Bit 9"]
# [inline (always)]
pub fn ucsa9 (& mut self) -> UCSA9_W < 9 > { UCSA9_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 I2C Slave Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0i2csa](index.html) module"]
pub struct UCB0I2CSA_SPEC ; impl crate :: RegisterSpec for UCB0I2CSA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0i2csa::R](R) reader structure"]
impl crate :: Readable for UCB0I2CSA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0i2csa::W](W) writer structure"]
impl crate :: Writable for UCB0I2CSA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0I2CSA to value 0"]
impl crate :: Resettable for UCB0I2CSA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IE register accessor: an alias for `Reg<UCB0IE_SPEC>`"]
pub type UCB0IE = crate :: Reg < ucb0ie :: UCB0IE_SPEC > ; # [doc = "USCI B0 Interrupt Enable Register"]
pub mod ucb0ie { # [doc = "Register `UCB0IE` reader"]
pub struct R (crate :: R < UCB0IE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IE_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IE` writer"]
pub struct W (crate :: W < UCB0IE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie](index.html) module"]
pub struct UCB0IE_SPEC ; impl crate :: RegisterSpec for UCB0IE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ie::R](R) reader structure"]
impl crate :: Readable for UCB0IE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ie::W](W) writer structure"]
impl crate :: Writable for UCB0IE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IE to value 0"]
impl crate :: Resettable for UCB0IE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IE_I2C register accessor: an alias for `Reg<UCB0IE_I2C_SPEC>`"]
pub type UCB0IE_I2C = crate :: Reg < ucb0ie_i2c :: UCB0IE_I2C_SPEC > ; # [doc = "USCI B0 Interrupt Enable Register"]
pub mod ucb0ie_i2c { # [doc = "Register `UCB0IE_I2C` reader"]
pub struct R (crate :: R < UCB0IE_I2C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IE_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IE_I2C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IE_I2C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IE_I2C` writer"]
pub struct W (crate :: W < UCB0IE_I2C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IE_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IE_I2C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IE_I2C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIE0` reader - I2C Receive Interrupt Enable 0"]
pub type UCRXIE0_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE0` writer - I2C Receive Interrupt Enable 0"]
pub type UCRXIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIE0` reader - I2C Transmit Interrupt Enable 0"]
pub type UCTXIE0_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE0` writer - I2C Transmit Interrupt Enable 0"]
pub type UCTXIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCSTTIE` reader - I2C START Condition interrupt enable"]
pub type UCSTTIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTTIE` writer - I2C START Condition interrupt enable"]
pub type UCSTTIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCSTPIE` reader - I2C STOP Condition interrupt enable"]
pub type UCSTPIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTPIE` writer - I2C STOP Condition interrupt enable"]
pub type UCSTPIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCALIE` reader - I2C Arbitration Lost interrupt enable"]
pub type UCALIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCALIE` writer - I2C Arbitration Lost interrupt enable"]
pub type UCALIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCNACKIE` reader - I2C NACK Condition interrupt enable"]
pub type UCNACKIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCNACKIE` writer - I2C NACK Condition interrupt enable"]
pub type UCNACKIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNTIE` reader - I2C Automatic stop assertion interrupt enable"]
pub type UCBCNTIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNTIE` writer - I2C Automatic stop assertion interrupt enable"]
pub type UCBCNTIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCCLTOIE` reader - I2C Clock Low Timeout interrupt enable"]
pub type UCCLTOIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCCLTOIE` writer - I2C Clock Low Timeout interrupt enable"]
pub type UCCLTOIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIE1` reader - I2C Receive Interrupt Enable 1"]
pub type UCRXIE1_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE1` writer - I2C Receive Interrupt Enable 1"]
pub type UCRXIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIE1` reader - I2C Transmit Interrupt Enable 1"]
pub type UCTXIE1_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE1` writer - I2C Transmit Interrupt Enable 1"]
pub type UCTXIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIE2` reader - I2C Receive Interrupt Enable 2"]
pub type UCRXIE2_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE2` writer - I2C Receive Interrupt Enable 2"]
pub type UCRXIE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIE2` reader - I2C Transmit Interrupt Enable 2"]
pub type UCTXIE2_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE2` writer - I2C Transmit Interrupt Enable 2"]
pub type UCTXIE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIE3` reader - I2C Receive Interrupt Enable 3"]
pub type UCRXIE3_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE3` writer - I2C Receive Interrupt Enable 3"]
pub type UCRXIE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIE3` reader - I2C Transmit Interrupt Enable 3"]
pub type UCTXIE3_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE3` writer - I2C Transmit Interrupt Enable 3"]
pub type UCTXIE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; # [doc = "Field `UCBIT9IE` reader - I2C Bit 9 Position Interrupt Enable 3"]
pub type UCBIT9IE_R = crate :: BitReader < bool > ; # [doc = "Field `UCBIT9IE` writer - I2C Bit 9 Position Interrupt Enable 3"]
pub type UCBIT9IE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_I2C_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Receive Interrupt Enable 0"]
# [inline (always)]
pub fn ucrxie0 (& self) -> UCRXIE0_R { UCRXIE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Transmit Interrupt Enable 0"]
# [inline (always)]
pub fn uctxie0 (& self) -> UCTXIE0_R { UCTXIE0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C START Condition interrupt enable"]
# [inline (always)]
pub fn ucsttie (& self) -> UCSTTIE_R { UCSTTIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C STOP Condition interrupt enable"]
# [inline (always)]
pub fn ucstpie (& self) -> UCSTPIE_R { UCSTPIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Arbitration Lost interrupt enable"]
# [inline (always)]
pub fn ucalie (& self) -> UCALIE_R { UCALIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C NACK Condition interrupt enable"]
# [inline (always)]
pub fn ucnackie (& self) -> UCNACKIE_R { UCNACKIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Automatic stop assertion interrupt enable"]
# [inline (always)]
pub fn ucbcntie (& self) -> UCBCNTIE_R { UCBCNTIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Clock Low Timeout interrupt enable"]
# [inline (always)]
pub fn uccltoie (& self) -> UCCLTOIE_R { UCCLTOIE_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Receive Interrupt Enable 1"]
# [inline (always)]
pub fn ucrxie1 (& self) -> UCRXIE1_R { UCRXIE1_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Transmit Interrupt Enable 1"]
# [inline (always)]
pub fn uctxie1 (& self) -> UCTXIE1_R { UCTXIE1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Receive Interrupt Enable 2"]
# [inline (always)]
pub fn ucrxie2 (& self) -> UCRXIE2_R { UCRXIE2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - I2C Transmit Interrupt Enable 2"]
# [inline (always)]
pub fn uctxie2 (& self) -> UCTXIE2_R { UCTXIE2_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - I2C Receive Interrupt Enable 3"]
# [inline (always)]
pub fn ucrxie3 (& self) -> UCRXIE3_R { UCRXIE3_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - I2C Transmit Interrupt Enable 3"]
# [inline (always)]
pub fn uctxie3 (& self) -> UCTXIE3_R { UCTXIE3_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - I2C Bit 9 Position Interrupt Enable 3"]
# [inline (always)]
pub fn ucbit9ie (& self) -> UCBIT9IE_R { UCBIT9IE_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Receive Interrupt Enable 0"]
# [inline (always)]
pub fn ucrxie0 (& mut self) -> UCRXIE0_W < 0 > { UCRXIE0_W :: new (self) } # [doc = "Bit 1 - I2C Transmit Interrupt Enable 0"]
# [inline (always)]
pub fn uctxie0 (& mut self) -> UCTXIE0_W < 1 > { UCTXIE0_W :: new (self) } # [doc = "Bit 2 - I2C START Condition interrupt enable"]
# [inline (always)]
pub fn ucsttie (& mut self) -> UCSTTIE_W < 2 > { UCSTTIE_W :: new (self) } # [doc = "Bit 3 - I2C STOP Condition interrupt enable"]
# [inline (always)]
pub fn ucstpie (& mut self) -> UCSTPIE_W < 3 > { UCSTPIE_W :: new (self) } # [doc = "Bit 4 - I2C Arbitration Lost interrupt enable"]
# [inline (always)]
pub fn ucalie (& mut self) -> UCALIE_W < 4 > { UCALIE_W :: new (self) } # [doc = "Bit 5 - I2C NACK Condition interrupt enable"]
# [inline (always)]
pub fn ucnackie (& mut self) -> UCNACKIE_W < 5 > { UCNACKIE_W :: new (self) } # [doc = "Bit 6 - I2C Automatic stop assertion interrupt enable"]
# [inline (always)]
pub fn ucbcntie (& mut self) -> UCBCNTIE_W < 6 > { UCBCNTIE_W :: new (self) } # [doc = "Bit 7 - I2C Clock Low Timeout interrupt enable"]
# [inline (always)]
pub fn uccltoie (& mut self) -> UCCLTOIE_W < 7 > { UCCLTOIE_W :: new (self) } # [doc = "Bit 8 - I2C Receive Interrupt Enable 1"]
# [inline (always)]
pub fn ucrxie1 (& mut self) -> UCRXIE1_W < 8 > { UCRXIE1_W :: new (self) } # [doc = "Bit 9 - I2C Transmit Interrupt Enable 1"]
# [inline (always)]
pub fn uctxie1 (& mut self) -> UCTXIE1_W < 9 > { UCTXIE1_W :: new (self) } # [doc = "Bit 10 - I2C Receive Interrupt Enable 2"]
# [inline (always)]
pub fn ucrxie2 (& mut self) -> UCRXIE2_W < 10 > { UCRXIE2_W :: new (self) } # [doc = "Bit 11 - I2C Transmit Interrupt Enable 2"]
# [inline (always)]
pub fn uctxie2 (& mut self) -> UCTXIE2_W < 11 > { UCTXIE2_W :: new (self) } # [doc = "Bit 12 - I2C Receive Interrupt Enable 3"]
# [inline (always)]
pub fn ucrxie3 (& mut self) -> UCRXIE3_W < 12 > { UCRXIE3_W :: new (self) } # [doc = "Bit 13 - I2C Transmit Interrupt Enable 3"]
# [inline (always)]
pub fn uctxie3 (& mut self) -> UCTXIE3_W < 13 > { UCTXIE3_W :: new (self) } # [doc = "Bit 14 - I2C Bit 9 Position Interrupt Enable 3"]
# [inline (always)]
pub fn ucbit9ie (& mut self) -> UCBIT9IE_W < 14 > { UCBIT9IE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie_i2c](index.html) module"]
pub struct UCB0IE_I2C_SPEC ; impl crate :: RegisterSpec for UCB0IE_I2C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ie_i2c::R](R) reader structure"]
impl crate :: Readable for UCB0IE_I2C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ie_i2c::W](W) writer structure"]
impl crate :: Writable for UCB0IE_I2C_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IE_I2C to value 0"]
impl crate :: Resettable for UCB0IE_I2C_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IFG register accessor: an alias for `Reg<UCB0IFG_SPEC>`"]
pub type UCB0IFG = crate :: Reg < ucb0ifg :: UCB0IFG_SPEC > ; # [doc = "USCI B0 Interrupt Flags Register"]
pub mod ucb0ifg { # [doc = "Register `UCB0IFG` reader"]
pub struct R (crate :: R < UCB0IFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IFG` writer"]
pub struct W (crate :: W < UCB0IFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IFG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Flags Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg](index.html) module"]
pub struct UCB0IFG_SPEC ; impl crate :: RegisterSpec for UCB0IFG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ifg::R](R) reader structure"]
impl crate :: Readable for UCB0IFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ifg::W](W) writer structure"]
impl crate :: Writable for UCB0IFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IFG to value 0"]
impl crate :: Resettable for UCB0IFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IFG_I2C register accessor: an alias for `Reg<UCB0IFG_I2C_SPEC>`"]
pub type UCB0IFG_I2C = crate :: Reg < ucb0ifg_i2c :: UCB0IFG_I2C_SPEC > ; # [doc = "USCI B0 Interrupt Flags Register"]
pub mod ucb0ifg_i2c { # [doc = "Register `UCB0IFG_I2C` reader"]
pub struct R (crate :: R < UCB0IFG_I2C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IFG_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IFG_I2C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IFG_I2C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IFG_I2C` writer"]
pub struct W (crate :: W < UCB0IFG_I2C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IFG_I2C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IFG_I2C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IFG_I2C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIFG0` reader - I2C Receive Interrupt Flag 0"]
pub type UCRXIFG0_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG0` writer - I2C Receive Interrupt Flag 0"]
pub type UCRXIFG0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIFG0` reader - I2C Transmit Interrupt Flag 0"]
pub type UCTXIFG0_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG0` writer - I2C Transmit Interrupt Flag 0"]
pub type UCTXIFG0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCSTTIFG` reader - I2C START Condition interrupt Flag"]
pub type UCSTTIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTTIFG` writer - I2C START Condition interrupt Flag"]
pub type UCSTTIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCSTPIFG` reader - I2C STOP Condition interrupt Flag"]
pub type UCSTPIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCSTPIFG` writer - I2C STOP Condition interrupt Flag"]
pub type UCSTPIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCALIFG` reader - I2C Arbitration Lost interrupt Flag"]
pub type UCALIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCALIFG` writer - I2C Arbitration Lost interrupt Flag"]
pub type UCALIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCNACKIFG` reader - I2C NACK Condition interrupt Flag"]
pub type UCNACKIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCNACKIFG` writer - I2C NACK Condition interrupt Flag"]
pub type UCNACKIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCBCNTIFG` reader - I2C Byte counter interrupt flag"]
pub type UCBCNTIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCBCNTIFG` writer - I2C Byte counter interrupt flag"]
pub type UCBCNTIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCCLTOIFG` reader - I2C Clock low Timeout interrupt Flag"]
pub type UCCLTOIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCCLTOIFG` writer - I2C Clock low Timeout interrupt Flag"]
pub type UCCLTOIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIFG1` reader - I2C Receive Interrupt Flag 1"]
pub type UCRXIFG1_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG1` writer - I2C Receive Interrupt Flag 1"]
pub type UCRXIFG1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIFG1` reader - I2C Transmit Interrupt Flag 1"]
pub type UCTXIFG1_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG1` writer - I2C Transmit Interrupt Flag 1"]
pub type UCTXIFG1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIFG2` reader - I2C Receive Interrupt Flag 2"]
pub type UCRXIFG2_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG2` writer - I2C Receive Interrupt Flag 2"]
pub type UCRXIFG2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIFG2` reader - I2C Transmit Interrupt Flag 2"]
pub type UCTXIFG2_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG2` writer - I2C Transmit Interrupt Flag 2"]
pub type UCTXIFG2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCRXIFG3` reader - I2C Receive Interrupt Flag 3"]
pub type UCRXIFG3_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG3` writer - I2C Receive Interrupt Flag 3"]
pub type UCRXIFG3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCTXIFG3` reader - I2C Transmit Interrupt Flag 3"]
pub type UCTXIFG3_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG3` writer - I2C Transmit Interrupt Flag 3"]
pub type UCTXIFG3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; # [doc = "Field `UCBIT9IFG` reader - I2C Bit 9 Possition Interrupt Flag 3"]
pub type UCBIT9IFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCBIT9IFG` writer - I2C Bit 9 Possition Interrupt Flag 3"]
pub type UCBIT9IFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_I2C_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - I2C Receive Interrupt Flag 0"]
# [inline (always)]
pub fn ucrxifg0 (& self) -> UCRXIFG0_R { UCRXIFG0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - I2C Transmit Interrupt Flag 0"]
# [inline (always)]
pub fn uctxifg0 (& self) -> UCTXIFG0_R { UCTXIFG0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - I2C START Condition interrupt Flag"]
# [inline (always)]
pub fn ucsttifg (& self) -> UCSTTIFG_R { UCSTTIFG_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - I2C STOP Condition interrupt Flag"]
# [inline (always)]
pub fn ucstpifg (& self) -> UCSTPIFG_R { UCSTPIFG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - I2C Arbitration Lost interrupt Flag"]
# [inline (always)]
pub fn ucalifg (& self) -> UCALIFG_R { UCALIFG_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - I2C NACK Condition interrupt Flag"]
# [inline (always)]
pub fn ucnackifg (& self) -> UCNACKIFG_R { UCNACKIFG_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - I2C Byte counter interrupt flag"]
# [inline (always)]
pub fn ucbcntifg (& self) -> UCBCNTIFG_R { UCBCNTIFG_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - I2C Clock low Timeout interrupt Flag"]
# [inline (always)]
pub fn uccltoifg (& self) -> UCCLTOIFG_R { UCCLTOIFG_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - I2C Receive Interrupt Flag 1"]
# [inline (always)]
pub fn ucrxifg1 (& self) -> UCRXIFG1_R { UCRXIFG1_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - I2C Transmit Interrupt Flag 1"]
# [inline (always)]
pub fn uctxifg1 (& self) -> UCTXIFG1_R { UCTXIFG1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C Receive Interrupt Flag 2"]
# [inline (always)]
pub fn ucrxifg2 (& self) -> UCRXIFG2_R { UCRXIFG2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - I2C Transmit Interrupt Flag 2"]
# [inline (always)]
pub fn uctxifg2 (& self) -> UCTXIFG2_R { UCTXIFG2_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - I2C Receive Interrupt Flag 3"]
# [inline (always)]
pub fn ucrxifg3 (& self) -> UCRXIFG3_R { UCRXIFG3_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - I2C Transmit Interrupt Flag 3"]
# [inline (always)]
pub fn uctxifg3 (& self) -> UCTXIFG3_R { UCTXIFG3_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - I2C Bit 9 Possition Interrupt Flag 3"]
# [inline (always)]
pub fn ucbit9ifg (& self) -> UCBIT9IFG_R { UCBIT9IFG_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - I2C Receive Interrupt Flag 0"]
# [inline (always)]
pub fn ucrxifg0 (& mut self) -> UCRXIFG0_W < 0 > { UCRXIFG0_W :: new (self) } # [doc = "Bit 1 - I2C Transmit Interrupt Flag 0"]
# [inline (always)]
pub fn uctxifg0 (& mut self) -> UCTXIFG0_W < 1 > { UCTXIFG0_W :: new (self) } # [doc = "Bit 2 - I2C START Condition interrupt Flag"]
# [inline (always)]
pub fn ucsttifg (& mut self) -> UCSTTIFG_W < 2 > { UCSTTIFG_W :: new (self) } # [doc = "Bit 3 - I2C STOP Condition interrupt Flag"]
# [inline (always)]
pub fn ucstpifg (& mut self) -> UCSTPIFG_W < 3 > { UCSTPIFG_W :: new (self) } # [doc = "Bit 4 - I2C Arbitration Lost interrupt Flag"]
# [inline (always)]
pub fn ucalifg (& mut self) -> UCALIFG_W < 4 > { UCALIFG_W :: new (self) } # [doc = "Bit 5 - I2C NACK Condition interrupt Flag"]
# [inline (always)]
pub fn ucnackifg (& mut self) -> UCNACKIFG_W < 5 > { UCNACKIFG_W :: new (self) } # [doc = "Bit 6 - I2C Byte counter interrupt flag"]
# [inline (always)]
pub fn ucbcntifg (& mut self) -> UCBCNTIFG_W < 6 > { UCBCNTIFG_W :: new (self) } # [doc = "Bit 7 - I2C Clock low Timeout interrupt Flag"]
# [inline (always)]
pub fn uccltoifg (& mut self) -> UCCLTOIFG_W < 7 > { UCCLTOIFG_W :: new (self) } # [doc = "Bit 8 - I2C Receive Interrupt Flag 1"]
# [inline (always)]
pub fn ucrxifg1 (& mut self) -> UCRXIFG1_W < 8 > { UCRXIFG1_W :: new (self) } # [doc = "Bit 9 - I2C Transmit Interrupt Flag 1"]
# [inline (always)]
pub fn uctxifg1 (& mut self) -> UCTXIFG1_W < 9 > { UCTXIFG1_W :: new (self) } # [doc = "Bit 10 - I2C Receive Interrupt Flag 2"]
# [inline (always)]
pub fn ucrxifg2 (& mut self) -> UCRXIFG2_W < 10 > { UCRXIFG2_W :: new (self) } # [doc = "Bit 11 - I2C Transmit Interrupt Flag 2"]
# [inline (always)]
pub fn uctxifg2 (& mut self) -> UCTXIFG2_W < 11 > { UCTXIFG2_W :: new (self) } # [doc = "Bit 12 - I2C Receive Interrupt Flag 3"]
# [inline (always)]
pub fn ucrxifg3 (& mut self) -> UCRXIFG3_W < 12 > { UCRXIFG3_W :: new (self) } # [doc = "Bit 13 - I2C Transmit Interrupt Flag 3"]
# [inline (always)]
pub fn uctxifg3 (& mut self) -> UCTXIFG3_W < 13 > { UCTXIFG3_W :: new (self) } # [doc = "Bit 14 - I2C Bit 9 Possition Interrupt Flag 3"]
# [inline (always)]
pub fn ucbit9ifg (& mut self) -> UCBIT9IFG_W < 14 > { UCBIT9IFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Flags Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg_i2c](index.html) module"]
pub struct UCB0IFG_I2C_SPEC ; impl crate :: RegisterSpec for UCB0IFG_I2C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ifg_i2c::R](R) reader structure"]
impl crate :: Readable for UCB0IFG_I2C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ifg_i2c::W](W) writer structure"]
impl crate :: Writable for UCB0IFG_I2C_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IFG_I2C to value 0"]
impl crate :: Resettable for UCB0IFG_I2C_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IV register accessor: an alias for `Reg<UCB0IV_SPEC>`"]
pub type UCB0IV = crate :: Reg < ucb0iv :: UCB0IV_SPEC > ; # [doc = "USCI B0 Interrupt Vector Register"]
pub mod ucb0iv { # [doc = "Register `UCB0IV` reader"]
pub struct R (crate :: R < UCB0IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IV` writer"]
pub struct W (crate :: W < UCB0IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv](index.html) module"]
pub struct UCB0IV_SPEC ; impl crate :: RegisterSpec for UCB0IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0iv::R](R) reader structure"]
impl crate :: Readable for UCB0IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0iv::W](W) writer structure"]
impl crate :: Writable for UCB0IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IV to value 0"]
impl crate :: Resettable for UCB0IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "USCI_B0 SPI Mode"]
pub struct USCI_B0_SPI_MODE { _marker : PhantomData < * const () > } unsafe impl Send for USCI_B0_SPI_MODE { } impl USCI_B0_SPI_MODE { # [doc = r"Pointer to the register block"]
pub const PTR : * const usci_b0_spi_mode :: RegisterBlock = 0x0540 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usci_b0_spi_mode :: RegisterBlock { Self :: PTR } } impl Deref for USCI_B0_SPI_MODE { type Target = usci_b0_spi_mode :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USCI_B0_SPI_MODE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USCI_B0_SPI_MODE") . finish () } } # [doc = "USCI_B0 SPI Mode"]
pub mod usci_b0_spi_mode { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USCI B0 Control Register 1"]
pub ucb0ctl1_spi : crate :: Reg < ucb0ctl1_spi :: UCB0CTL1_SPI_SPEC > , # [doc = "0x01 - USCI B0 Control Register 0"]
pub ucb0ctl0_spi : crate :: Reg < ucb0ctl0_spi :: UCB0CTL0_SPI_SPEC > , _reserved2 : [u8 ; 0x04]
, # [doc = "0x06 - USCI B0 Baud Rate 0"]
pub ucb0br0_spi : crate :: Reg < ucb0br0_spi :: UCB0BR0_SPI_SPEC > , # [doc = "0x07 - USCI B0 Baud Rate 1"]
pub ucb0br1_spi : crate :: Reg < ucb0br1_spi :: UCB0BR1_SPI_SPEC > , _reserved4 : [u8 ; 0x04]
, # [doc = "0x0c - USCI B0 Receive Buffer"]
pub ucb0rxbuf_spi : crate :: Reg < ucb0rxbuf_spi :: UCB0RXBUF_SPI_SPEC > , # [doc = "0x0e - USCI B0 Transmit Buffer"]
pub ucb0txbuf_spi : crate :: Reg < ucb0txbuf_spi :: UCB0TXBUF_SPI_SPEC > , _reserved6 : [u8 ; 0x1a]
, # [doc = "0x2a - USCI B0 Interrupt Enable Register"]
pub ucb0ie_spi : crate :: Reg < ucb0ie_spi :: UCB0IE_SPI_SPEC > , # [doc = "0x2c - USCI B0 Interrupt Flags Register"]
pub ucb0ifg_spi : crate :: Reg < ucb0ifg_spi :: UCB0IFG_SPI_SPEC > , # [doc = "0x2e - USCI B0 Interrupt Vector Register"]
pub ucb0iv_spi : crate :: Reg < ucb0iv_spi :: UCB0IV_SPI_SPEC > , } # [doc = "UCB0CTL1_SPI register accessor: an alias for `Reg<UCB0CTL1_SPI_SPEC>`"]
pub type UCB0CTL1_SPI = crate :: Reg < ucb0ctl1_spi :: UCB0CTL1_SPI_SPEC > ; # [doc = "USCI B0 Control Register 1"]
pub mod ucb0ctl1_spi { # [doc = "Register `UCB0CTL1_SPI` reader"]
pub struct R (crate :: R < UCB0CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0CTL1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0CTL1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0CTL1_SPI` writer"]
pub struct W (crate :: W < UCB0CTL1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0CTL1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0CTL1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0CTL1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctl1_spi](index.html) module"]
pub struct UCB0CTL1_SPI_SPEC ; impl crate :: RegisterSpec for UCB0CTL1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0ctl1_spi::R](R) reader structure"]
impl crate :: Readable for UCB0CTL1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ctl1_spi::W](W) writer structure"]
impl crate :: Writable for UCB0CTL1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0CTL1_SPI to value 0"]
impl crate :: Resettable for UCB0CTL1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0CTL0_SPI register accessor: an alias for `Reg<UCB0CTL0_SPI_SPEC>`"]
pub type UCB0CTL0_SPI = crate :: Reg < ucb0ctl0_spi :: UCB0CTL0_SPI_SPEC > ; # [doc = "USCI B0 Control Register 0"]
pub mod ucb0ctl0_spi { # [doc = "Register `UCB0CTL0_SPI` reader"]
pub struct R (crate :: R < UCB0CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0CTL0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0CTL0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0CTL0_SPI` writer"]
pub struct W (crate :: W < UCB0CTL0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0CTL0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0CTL0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0CTL0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ctl0_spi](index.html) module"]
pub struct UCB0CTL0_SPI_SPEC ; impl crate :: RegisterSpec for UCB0CTL0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0ctl0_spi::R](R) reader structure"]
impl crate :: Readable for UCB0CTL0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ctl0_spi::W](W) writer structure"]
impl crate :: Writable for UCB0CTL0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0CTL0_SPI to value 0"]
impl crate :: Resettable for UCB0CTL0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0BR0_SPI register accessor: an alias for `Reg<UCB0BR0_SPI_SPEC>`"]
pub type UCB0BR0_SPI = crate :: Reg < ucb0br0_spi :: UCB0BR0_SPI_SPEC > ; # [doc = "USCI B0 Baud Rate 0"]
pub mod ucb0br0_spi { # [doc = "Register `UCB0BR0_SPI` reader"]
pub struct R (crate :: R < UCB0BR0_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0BR0_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0BR0_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0BR0_SPI` writer"]
pub struct W (crate :: W < UCB0BR0_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0BR0_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0BR0_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0BR0_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Baud Rate 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0br0_spi](index.html) module"]
pub struct UCB0BR0_SPI_SPEC ; impl crate :: RegisterSpec for UCB0BR0_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0br0_spi::R](R) reader structure"]
impl crate :: Readable for UCB0BR0_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0br0_spi::W](W) writer structure"]
impl crate :: Writable for UCB0BR0_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0BR0_SPI to value 0"]
impl crate :: Resettable for UCB0BR0_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0BR1_SPI register accessor: an alias for `Reg<UCB0BR1_SPI_SPEC>`"]
pub type UCB0BR1_SPI = crate :: Reg < ucb0br1_spi :: UCB0BR1_SPI_SPEC > ; # [doc = "USCI B0 Baud Rate 1"]
pub mod ucb0br1_spi { # [doc = "Register `UCB0BR1_SPI` reader"]
pub struct R (crate :: R < UCB0BR1_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0BR1_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0BR1_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0BR1_SPI` writer"]
pub struct W (crate :: W < UCB0BR1_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0BR1_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0BR1_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0BR1_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Baud Rate 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0br1_spi](index.html) module"]
pub struct UCB0BR1_SPI_SPEC ; impl crate :: RegisterSpec for UCB0BR1_SPI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucb0br1_spi::R](R) reader structure"]
impl crate :: Readable for UCB0BR1_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0br1_spi::W](W) writer structure"]
impl crate :: Writable for UCB0BR1_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0BR1_SPI to value 0"]
impl crate :: Resettable for UCB0BR1_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0RXBUF_SPI register accessor: an alias for `Reg<UCB0RXBUF_SPI_SPEC>`"]
pub type UCB0RXBUF_SPI = crate :: Reg < ucb0rxbuf_spi :: UCB0RXBUF_SPI_SPEC > ; # [doc = "USCI B0 Receive Buffer"]
pub mod ucb0rxbuf_spi { # [doc = "Register `UCB0RXBUF_SPI` reader"]
pub struct R (crate :: R < UCB0RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0RXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0RXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0RXBUF_SPI` writer"]
pub struct W (crate :: W < UCB0RXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0RXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0RXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0RXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Receive Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0rxbuf_spi](index.html) module"]
pub struct UCB0RXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCB0RXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0rxbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCB0RXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0rxbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCB0RXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0RXBUF_SPI to value 0"]
impl crate :: Resettable for UCB0RXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0TXBUF_SPI register accessor: an alias for `Reg<UCB0TXBUF_SPI_SPEC>`"]
pub type UCB0TXBUF_SPI = crate :: Reg < ucb0txbuf_spi :: UCB0TXBUF_SPI_SPEC > ; # [doc = "USCI B0 Transmit Buffer"]
pub mod ucb0txbuf_spi { # [doc = "Register `UCB0TXBUF_SPI` reader"]
pub struct R (crate :: R < UCB0TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0TXBUF_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0TXBUF_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0TXBUF_SPI` writer"]
pub struct W (crate :: W < UCB0TXBUF_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0TXBUF_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0TXBUF_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0TXBUF_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Transmit Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0txbuf_spi](index.html) module"]
pub struct UCB0TXBUF_SPI_SPEC ; impl crate :: RegisterSpec for UCB0TXBUF_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0txbuf_spi::R](R) reader structure"]
impl crate :: Readable for UCB0TXBUF_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0txbuf_spi::W](W) writer structure"]
impl crate :: Writable for UCB0TXBUF_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0TXBUF_SPI to value 0"]
impl crate :: Resettable for UCB0TXBUF_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IE_SPI register accessor: an alias for `Reg<UCB0IE_SPI_SPEC>`"]
pub type UCB0IE_SPI = crate :: Reg < ucb0ie_spi :: UCB0IE_SPI_SPEC > ; # [doc = "USCI B0 Interrupt Enable Register"]
pub mod ucb0ie_spi { # [doc = "Register `UCB0IE_SPI` reader"]
pub struct R (crate :: R < UCB0IE_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IE_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IE_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IE_SPI` writer"]
pub struct W (crate :: W < UCB0IE_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IE_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IE_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IE_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIE` reader - USCI Receive Interrupt Enable"]
pub type UCRXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIE` writer - USCI Receive Interrupt Enable"]
pub type UCRXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIE` reader - USCI Transmit Interrupt Enable"]
pub type UCTXIE_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIE` writer - USCI Transmit Interrupt Enable"]
pub type UCTXIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IE_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& self) -> UCRXIE_R { UCRXIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& self) -> UCTXIE_R { UCTXIE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - USCI Receive Interrupt Enable"]
# [inline (always)]
pub fn ucrxie (& mut self) -> UCRXIE_W < 0 > { UCRXIE_W :: new (self) } # [doc = "Bit 1 - USCI Transmit Interrupt Enable"]
# [inline (always)]
pub fn uctxie (& mut self) -> UCTXIE_W < 1 > { UCTXIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ie_spi](index.html) module"]
pub struct UCB0IE_SPI_SPEC ; impl crate :: RegisterSpec for UCB0IE_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ie_spi::R](R) reader structure"]
impl crate :: Readable for UCB0IE_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ie_spi::W](W) writer structure"]
impl crate :: Writable for UCB0IE_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IE_SPI to value 0"]
impl crate :: Resettable for UCB0IE_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IFG_SPI register accessor: an alias for `Reg<UCB0IFG_SPI_SPEC>`"]
pub type UCB0IFG_SPI = crate :: Reg < ucb0ifg_spi :: UCB0IFG_SPI_SPEC > ; # [doc = "USCI B0 Interrupt Flags Register"]
pub mod ucb0ifg_spi { # [doc = "Register `UCB0IFG_SPI` reader"]
pub struct R (crate :: R < UCB0IFG_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IFG_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IFG_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IFG_SPI` writer"]
pub struct W (crate :: W < UCB0IFG_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IFG_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IFG_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IFG_SPI_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCRXIFG` reader - SPI Receive Interrupt Flag"]
pub type UCRXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCRXIFG` writer - SPI Receive Interrupt Flag"]
pub type UCRXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_SPI_SPEC , bool , O > ; # [doc = "Field `UCTXIFG` reader - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UCTXIFG` writer - SPI Transmit Interrupt Flag"]
pub type UCTXIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , UCB0IFG_SPI_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& self) -> UCRXIFG_R { UCRXIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& self) -> UCTXIFG_R { UCTXIFG_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - SPI Receive Interrupt Flag"]
# [inline (always)]
pub fn ucrxifg (& mut self) -> UCRXIFG_W < 0 > { UCRXIFG_W :: new (self) } # [doc = "Bit 1 - SPI Transmit Interrupt Flag"]
# [inline (always)]
pub fn uctxifg (& mut self) -> UCTXIFG_W < 1 > { UCTXIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Flags Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0ifg_spi](index.html) module"]
pub struct UCB0IFG_SPI_SPEC ; impl crate :: RegisterSpec for UCB0IFG_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0ifg_spi::R](R) reader structure"]
impl crate :: Readable for UCB0IFG_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0ifg_spi::W](W) writer structure"]
impl crate :: Writable for UCB0IFG_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IFG_SPI to value 0"]
impl crate :: Resettable for UCB0IFG_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "UCB0IV_SPI register accessor: an alias for `Reg<UCB0IV_SPI_SPEC>`"]
pub type UCB0IV_SPI = crate :: Reg < ucb0iv_spi :: UCB0IV_SPI_SPEC > ; # [doc = "USCI B0 Interrupt Vector Register"]
pub mod ucb0iv_spi { # [doc = "Register `UCB0IV_SPI` reader"]
pub struct R (crate :: R < UCB0IV_SPI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCB0IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCB0IV_SPI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCB0IV_SPI_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCB0IV_SPI` writer"]
pub struct W (crate :: W < UCB0IV_SPI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCB0IV_SPI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCB0IV_SPI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCB0IV_SPI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USCI B0 Interrupt Vector Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucb0iv_spi](index.html) module"]
pub struct UCB0IV_SPI_SPEC ; impl crate :: RegisterSpec for UCB0IV_SPI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ucb0iv_spi::R](R) reader structure"]
impl crate :: Readable for UCB0IV_SPI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucb0iv_spi::W](W) writer structure"]
impl crate :: Writable for UCB0IV_SPI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets UCB0IV_SPI to value 0"]
impl crate :: Resettable for UCB0IV_SPI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "SFR Special Function Registers"]
pub struct SFR { _marker : PhantomData < * const () > } unsafe impl Send for SFR { } impl SFR { # [doc = r"Pointer to the register block"]
pub const PTR : * const sfr :: RegisterBlock = 0x0100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sfr :: RegisterBlock { Self :: PTR } } impl Deref for SFR { type Target = sfr :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SFR { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SFR") . finish () } } # [doc = "SFR Special Function Registers"]
pub mod sfr { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Interrupt Enable 1"]
pub sfrie1 : crate :: Reg < sfrie1 :: SFRIE1_SPEC > , # [doc = "0x02 - Interrupt Flag 1"]
pub sfrifg1 : crate :: Reg < sfrifg1 :: SFRIFG1_SPEC > , # [doc = "0x04 - RESET Pin Control Register"]
pub sfrrpcr : crate :: Reg < sfrrpcr :: SFRRPCR_SPEC > , } # [doc = "SFRIE1 register accessor: an alias for `Reg<SFRIE1_SPEC>`"]
pub type SFRIE1 = crate :: Reg < sfrie1 :: SFRIE1_SPEC > ; # [doc = "Interrupt Enable 1"]
pub mod sfrie1 { # [doc = "Register `SFRIE1` reader"]
pub struct R (crate :: R < SFRIE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SFRIE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SFRIE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SFRIE1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SFRIE1` writer"]
pub struct W (crate :: W < SFRIE1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SFRIE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SFRIE1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SFRIE1_SPEC >) -> Self { W (writer) } } # [doc = "Field `WDTIE` reader - WDT Interrupt Enable"]
pub type WDTIE_R = crate :: BitReader < bool > ; # [doc = "Field `WDTIE` writer - WDT Interrupt Enable"]
pub type WDTIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; # [doc = "Field `OFIE` reader - Osc Fault Enable"]
pub type OFIE_R = crate :: BitReader < bool > ; # [doc = "Field `OFIE` writer - Osc Fault Enable"]
pub type OFIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; # [doc = "Field `VMAIE` reader - Vacant Memory Interrupt Enable"]
pub type VMAIE_R = crate :: BitReader < bool > ; # [doc = "Field `VMAIE` writer - Vacant Memory Interrupt Enable"]
pub type VMAIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; # [doc = "Field `NMIIE` reader - NMI Interrupt Enable"]
pub type NMIIE_R = crate :: BitReader < bool > ; # [doc = "Field `NMIIE` writer - NMI Interrupt Enable"]
pub type NMIIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; # [doc = "Field `JMBINIE` reader - JTAG Mail Box input Interrupt Enable"]
pub type JMBINIE_R = crate :: BitReader < bool > ; # [doc = "Field `JMBINIE` writer - JTAG Mail Box input Interrupt Enable"]
pub type JMBINIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; # [doc = "Field `JMBOUTIE` reader - JTAG Mail Box output Interrupt Enable"]
pub type JMBOUTIE_R = crate :: BitReader < bool > ; # [doc = "Field `JMBOUTIE` writer - JTAG Mail Box output Interrupt Enable"]
pub type JMBOUTIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIE1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - WDT Interrupt Enable"]
# [inline (always)]
pub fn wdtie (& self) -> WDTIE_R { WDTIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Osc Fault Enable"]
# [inline (always)]
pub fn ofie (& self) -> OFIE_R { OFIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Vacant Memory Interrupt Enable"]
# [inline (always)]
pub fn vmaie (& self) -> VMAIE_R { VMAIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - NMI Interrupt Enable"]
# [inline (always)]
pub fn nmiie (& self) -> NMIIE_R { NMIIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - JTAG Mail Box input Interrupt Enable"]
# [inline (always)]
pub fn jmbinie (& self) -> JMBINIE_R { JMBINIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - JTAG Mail Box output Interrupt Enable"]
# [inline (always)]
pub fn jmboutie (& self) -> JMBOUTIE_R { JMBOUTIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - WDT Interrupt Enable"]
# [inline (always)]
pub fn wdtie (& mut self) -> WDTIE_W < 0 > { WDTIE_W :: new (self) } # [doc = "Bit 1 - Osc Fault Enable"]
# [inline (always)]
pub fn ofie (& mut self) -> OFIE_W < 1 > { OFIE_W :: new (self) } # [doc = "Bit 3 - Vacant Memory Interrupt Enable"]
# [inline (always)]
pub fn vmaie (& mut self) -> VMAIE_W < 3 > { VMAIE_W :: new (self) } # [doc = "Bit 4 - NMI Interrupt Enable"]
# [inline (always)]
pub fn nmiie (& mut self) -> NMIIE_W < 4 > { NMIIE_W :: new (self) } # [doc = "Bit 6 - JTAG Mail Box input Interrupt Enable"]
# [inline (always)]
pub fn jmbinie (& mut self) -> JMBINIE_W < 6 > { JMBINIE_W :: new (self) } # [doc = "Bit 7 - JTAG Mail Box output Interrupt Enable"]
# [inline (always)]
pub fn jmboutie (& mut self) -> JMBOUTIE_W < 7 > { JMBOUTIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrie1](index.html) module"]
pub struct SFRIE1_SPEC ; impl crate :: RegisterSpec for SFRIE1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sfrie1::R](R) reader structure"]
impl crate :: Readable for SFRIE1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sfrie1::W](W) writer structure"]
impl crate :: Writable for SFRIE1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SFRIE1 to value 0"]
impl crate :: Resettable for SFRIE1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SFRIFG1 register accessor: an alias for `Reg<SFRIFG1_SPEC>`"]
pub type SFRIFG1 = crate :: Reg < sfrifg1 :: SFRIFG1_SPEC > ; # [doc = "Interrupt Flag 1"]
pub mod sfrifg1 { # [doc = "Register `SFRIFG1` reader"]
pub struct R (crate :: R < SFRIFG1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SFRIFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SFRIFG1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SFRIFG1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SFRIFG1` writer"]
pub struct W (crate :: W < SFRIFG1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SFRIFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SFRIFG1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SFRIFG1_SPEC >) -> Self { W (writer) } } # [doc = "Field `WDTIFG` reader - WDT Interrupt Flag"]
pub type WDTIFG_R = crate :: BitReader < bool > ; # [doc = "Field `WDTIFG` writer - WDT Interrupt Flag"]
pub type WDTIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; # [doc = "Field `OFIFG` reader - Osc Fault Flag"]
pub type OFIFG_R = crate :: BitReader < bool > ; # [doc = "Field `OFIFG` writer - Osc Fault Flag"]
pub type OFIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; # [doc = "Field `VMAIFG` reader - Vacant Memory Interrupt Flag"]
pub type VMAIFG_R = crate :: BitReader < bool > ; # [doc = "Field `VMAIFG` writer - Vacant Memory Interrupt Flag"]
pub type VMAIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; # [doc = "Field `NMIIFG` reader - NMI Interrupt Flag"]
pub type NMIIFG_R = crate :: BitReader < bool > ; # [doc = "Field `NMIIFG` writer - NMI Interrupt Flag"]
pub type NMIIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; # [doc = "Field `JMBINIFG` reader - JTAG Mail Box input Interrupt Flag"]
pub type JMBINIFG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBINIFG` writer - JTAG Mail Box input Interrupt Flag"]
pub type JMBINIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; # [doc = "Field `JMBOUTIFG` reader - JTAG Mail Box output Interrupt Flag"]
pub type JMBOUTIFG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBOUTIFG` writer - JTAG Mail Box output Interrupt Flag"]
pub type JMBOUTIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRIFG1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - WDT Interrupt Flag"]
# [inline (always)]
pub fn wdtifg (& self) -> WDTIFG_R { WDTIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Osc Fault Flag"]
# [inline (always)]
pub fn ofifg (& self) -> OFIFG_R { OFIFG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Vacant Memory Interrupt Flag"]
# [inline (always)]
pub fn vmaifg (& self) -> VMAIFG_R { VMAIFG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - NMI Interrupt Flag"]
# [inline (always)]
pub fn nmiifg (& self) -> NMIIFG_R { NMIIFG_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - JTAG Mail Box input Interrupt Flag"]
# [inline (always)]
pub fn jmbinifg (& self) -> JMBINIFG_R { JMBINIFG_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - JTAG Mail Box output Interrupt Flag"]
# [inline (always)]
pub fn jmboutifg (& self) -> JMBOUTIFG_R { JMBOUTIFG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - WDT Interrupt Flag"]
# [inline (always)]
pub fn wdtifg (& mut self) -> WDTIFG_W < 0 > { WDTIFG_W :: new (self) } # [doc = "Bit 1 - Osc Fault Flag"]
# [inline (always)]
pub fn ofifg (& mut self) -> OFIFG_W < 1 > { OFIFG_W :: new (self) } # [doc = "Bit 3 - Vacant Memory Interrupt Flag"]
# [inline (always)]
pub fn vmaifg (& mut self) -> VMAIFG_W < 3 > { VMAIFG_W :: new (self) } # [doc = "Bit 4 - NMI Interrupt Flag"]
# [inline (always)]
pub fn nmiifg (& mut self) -> NMIIFG_W < 4 > { NMIIFG_W :: new (self) } # [doc = "Bit 6 - JTAG Mail Box input Interrupt Flag"]
# [inline (always)]
pub fn jmbinifg (& mut self) -> JMBINIFG_W < 6 > { JMBINIFG_W :: new (self) } # [doc = "Bit 7 - JTAG Mail Box output Interrupt Flag"]
# [inline (always)]
pub fn jmboutifg (& mut self) -> JMBOUTIFG_W < 7 > { JMBOUTIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrifg1](index.html) module"]
pub struct SFRIFG1_SPEC ; impl crate :: RegisterSpec for SFRIFG1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sfrifg1::R](R) reader structure"]
impl crate :: Readable for SFRIFG1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sfrifg1::W](W) writer structure"]
impl crate :: Writable for SFRIFG1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SFRIFG1 to value 0"]
impl crate :: Resettable for SFRIFG1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SFRRPCR register accessor: an alias for `Reg<SFRRPCR_SPEC>`"]
pub type SFRRPCR = crate :: Reg < sfrrpcr :: SFRRPCR_SPEC > ; # [doc = "RESET Pin Control Register"]
pub mod sfrrpcr { # [doc = "Register `SFRRPCR` reader"]
pub struct R (crate :: R < SFRRPCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SFRRPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SFRRPCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SFRRPCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SFRRPCR` writer"]
pub struct W (crate :: W < SFRRPCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SFRRPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SFRRPCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SFRRPCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYSNMI` reader - NMI select"]
pub type SYSNMI_R = crate :: BitReader < bool > ; # [doc = "Field `SYSNMI` writer - NMI select"]
pub type SYSNMI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRRPCR_SPEC , bool , O > ; # [doc = "Field `SYSNMIIES` reader - NMI edge select"]
pub type SYSNMIIES_R = crate :: BitReader < bool > ; # [doc = "Field `SYSNMIIES` writer - NMI edge select"]
pub type SYSNMIIES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRRPCR_SPEC , bool , O > ; # [doc = "Field `SYSRSTUP` reader - RESET Pin pull down/up select"]
pub type SYSRSTUP_R = crate :: BitReader < bool > ; # [doc = "Field `SYSRSTUP` writer - RESET Pin pull down/up select"]
pub type SYSRSTUP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRRPCR_SPEC , bool , O > ; # [doc = "Field `SYSRSTRE` reader - RESET Pin Resistor enable"]
pub type SYSRSTRE_R = crate :: BitReader < bool > ; # [doc = "Field `SYSRSTRE` writer - RESET Pin Resistor enable"]
pub type SYSRSTRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SFRRPCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - NMI select"]
# [inline (always)]
pub fn sysnmi (& self) -> SYSNMI_R { SYSNMI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - NMI edge select"]
# [inline (always)]
pub fn sysnmiies (& self) -> SYSNMIIES_R { SYSNMIIES_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - RESET Pin pull down/up select"]
# [inline (always)]
pub fn sysrstup (& self) -> SYSRSTUP_R { SYSRSTUP_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - RESET Pin Resistor enable"]
# [inline (always)]
pub fn sysrstre (& self) -> SYSRSTRE_R { SYSRSTRE_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - NMI select"]
# [inline (always)]
pub fn sysnmi (& mut self) -> SYSNMI_W < 0 > { SYSNMI_W :: new (self) } # [doc = "Bit 1 - NMI edge select"]
# [inline (always)]
pub fn sysnmiies (& mut self) -> SYSNMIIES_W < 1 > { SYSNMIIES_W :: new (self) } # [doc = "Bit 2 - RESET Pin pull down/up select"]
# [inline (always)]
pub fn sysrstup (& mut self) -> SYSRSTUP_W < 2 > { SYSRSTUP_W :: new (self) } # [doc = "Bit 3 - RESET Pin Resistor enable"]
# [inline (always)]
pub fn sysrstre (& mut self) -> SYSRSTRE_W < 3 > { SYSRSTRE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RESET Pin Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfrrpcr](index.html) module"]
pub struct SFRRPCR_SPEC ; impl crate :: RegisterSpec for SFRRPCR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sfrrpcr::R](R) reader structure"]
impl crate :: Readable for SFRRPCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sfrrpcr::W](W) writer structure"]
impl crate :: Writable for SFRRPCR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SFRRPCR to value 0"]
impl crate :: Resettable for SFRRPCR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "PMM Power Management System"]
pub struct PMM { _marker : PhantomData < * const () > } unsafe impl Send for PMM { } impl PMM { # [doc = r"Pointer to the register block"]
pub const PTR : * const pmm :: RegisterBlock = 0x0120 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pmm :: RegisterBlock { Self :: PTR } } impl Deref for PMM { type Target = pmm :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PMM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PMM") . finish () } } # [doc = "PMM Power Management System"]
pub mod pmm { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - PMM Control 0"]
pub pmmctl0 : crate :: Reg < pmmctl0 :: PMMCTL0_SPEC > , # [doc = "0x02 - PMM Control 1"]
pub pmmctl1 : crate :: Reg < pmmctl1 :: PMMCTL1_SPEC > , # [doc = "0x04 - PMM Control 2"]
pub pmmctl2 : crate :: Reg < pmmctl2 :: PMMCTL2_SPEC > , _reserved3 : [u8 ; 0x04]
, # [doc = "0x0a - PMM Interrupt Flag"]
pub pmmifg : crate :: Reg < pmmifg :: PMMIFG_SPEC > , _reserved4 : [u8 ; 0x02]
, # [doc = "0x0e - PMM Interrupt Enable"]
pub pmmie : crate :: Reg < pmmie :: PMMIE_SPEC > , # [doc = "0x10 - PMM Power Mode 5 Control Register 0"]
pub pm5ctl0 : crate :: Reg < pm5ctl0 :: PM5CTL0_SPEC > , } # [doc = "PMMCTL0 register accessor: an alias for `Reg<PMMCTL0_SPEC>`"]
pub type PMMCTL0 = crate :: Reg < pmmctl0 :: PMMCTL0_SPEC > ; # [doc = "PMM Control 0"]
pub mod pmmctl0 { # [doc = "Register `PMMCTL0` reader"]
pub struct R (crate :: R < PMMCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMMCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMMCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMMCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PMMCTL0` writer"]
pub struct W (crate :: W < PMMCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMMCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMMCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMMCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PMMSWBOR` reader - PMM Software BOR"]
pub type PMMSWBOR_R = crate :: BitReader < bool > ; # [doc = "Field `PMMSWBOR` writer - PMM Software BOR"]
pub type PMMSWBOR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL0_SPEC , bool , O > ; # [doc = "Field `PMMSWPOR` reader - PMM Software POR"]
pub type PMMSWPOR_R = crate :: BitReader < bool > ; # [doc = "Field `PMMSWPOR` writer - PMM Software POR"]
pub type PMMSWPOR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL0_SPEC , bool , O > ; # [doc = "Field `PMMREGOFF` reader - PMM Turn Regulator off"]
pub type PMMREGOFF_R = crate :: BitReader < bool > ; # [doc = "Field `PMMREGOFF` writer - PMM Turn Regulator off"]
pub type PMMREGOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL0_SPEC , bool , O > ; # [doc = "Field `SVSHE` reader - SVS high side enable"]
pub type SVSHE_R = crate :: BitReader < bool > ; # [doc = "Field `SVSHE` writer - SVS high side enable"]
pub type SVSHE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL0_SPEC , bool , O > ; impl R { # [doc = "Bit 2 - PMM Software BOR"]
# [inline (always)]
pub fn pmmswbor (& self) -> PMMSWBOR_R { PMMSWBOR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - PMM Software POR"]
# [inline (always)]
pub fn pmmswpor (& self) -> PMMSWPOR_R { PMMSWPOR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - PMM Turn Regulator off"]
# [inline (always)]
pub fn pmmregoff (& self) -> PMMREGOFF_R { PMMREGOFF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - SVS high side enable"]
# [inline (always)]
pub fn svshe (& self) -> SVSHE_R { SVSHE_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 2 - PMM Software BOR"]
# [inline (always)]
pub fn pmmswbor (& mut self) -> PMMSWBOR_W < 2 > { PMMSWBOR_W :: new (self) } # [doc = "Bit 3 - PMM Software POR"]
# [inline (always)]
pub fn pmmswpor (& mut self) -> PMMSWPOR_W < 3 > { PMMSWPOR_W :: new (self) } # [doc = "Bit 4 - PMM Turn Regulator off"]
# [inline (always)]
pub fn pmmregoff (& mut self) -> PMMREGOFF_W < 4 > { PMMREGOFF_W :: new (self) } # [doc = "Bit 6 - SVS high side enable"]
# [inline (always)]
pub fn svshe (& mut self) -> SVSHE_W < 6 > { SVSHE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmctl0](index.html) module"]
pub struct PMMCTL0_SPEC ; impl crate :: RegisterSpec for PMMCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pmmctl0::R](R) reader structure"]
impl crate :: Readable for PMMCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmmctl0::W](W) writer structure"]
impl crate :: Writable for PMMCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMMCTL0 to value 0"]
impl crate :: Resettable for PMMCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PMMCTL1 register accessor: an alias for `Reg<PMMCTL1_SPEC>`"]
pub type PMMCTL1 = crate :: Reg < pmmctl1 :: PMMCTL1_SPEC > ; # [doc = "PMM Control 1"]
pub mod pmmctl1 { # [doc = "Register `PMMCTL1` reader"]
pub struct R (crate :: R < PMMCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMMCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMMCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMMCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `PMMCTL1` writer"]
pub struct W (crate :: W < PMMCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMMCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMMCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMMCTL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmctl1](index.html) module"]
pub struct PMMCTL1_SPEC ; impl crate :: RegisterSpec for PMMCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pmmctl1::R](R) reader structure"]
impl crate :: Readable for PMMCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmmctl1::W](W) writer structure"]
impl crate :: Writable for PMMCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMMCTL1 to value 0"]
impl crate :: Resettable for PMMCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PMMCTL2 register accessor: an alias for `Reg<PMMCTL2_SPEC>`"]
pub type PMMCTL2 = crate :: Reg < pmmctl2 :: PMMCTL2_SPEC > ; # [doc = "PMM Control 2"]
pub mod pmmctl2 { # [doc = "Register `PMMCTL2` reader"]
pub struct R (crate :: R < PMMCTL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMMCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMMCTL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMMCTL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `PMMCTL2` writer"]
pub struct W (crate :: W < PMMCTL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMMCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMMCTL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMMCTL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTREFEN` reader - Internal Reference Enable"]
pub type INTREFEN_R = crate :: BitReader < bool > ; # [doc = "Field `INTREFEN` writer - Internal Reference Enable"]
pub type INTREFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `EXTREFEN` reader - External Reference output Enable"]
pub type EXTREFEN_R = crate :: BitReader < bool > ; # [doc = "Field `EXTREFEN` writer - External Reference output Enable"]
pub type EXTREFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `TSENSOREN` reader - Temperature Sensor Enable"]
pub type TSENSOREN_R = crate :: BitReader < bool > ; # [doc = "Field `TSENSOREN` writer - Temperature Sensor Enable"]
pub type TSENSOREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `REFGENACT` reader - REF Reference generator active"]
pub type REFGENACT_R = crate :: BitReader < bool > ; # [doc = "Field `REFGENACT` writer - REF Reference generator active"]
pub type REFGENACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `REFBGACT` reader - REF Reference bandgap active"]
pub type REFBGACT_R = crate :: BitReader < bool > ; # [doc = "Field `REFBGACT` writer - REF Reference bandgap active"]
pub type REFBGACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `BGMODE` reader - REF Bandgap mode"]
pub type BGMODE_R = crate :: BitReader < bool > ; # [doc = "Field `BGMODE` writer - REF Bandgap mode"]
pub type BGMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `REFGENRDY` reader - REF Reference generator ready"]
pub type REFGENRDY_R = crate :: BitReader < bool > ; # [doc = "Field `REFGENRDY` writer - REF Reference generator ready"]
pub type REFGENRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; # [doc = "Field `REFBGRDY` reader - REF Reference bandgap ready"]
pub type REFBGRDY_R = crate :: BitReader < bool > ; # [doc = "Field `REFBGRDY` writer - REF Reference bandgap ready"]
pub type REFBGRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMCTL2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Internal Reference Enable"]
# [inline (always)]
pub fn intrefen (& self) -> INTREFEN_R { INTREFEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Reference output Enable"]
# [inline (always)]
pub fn extrefen (& self) -> EXTREFEN_R { EXTREFEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Temperature Sensor Enable"]
# [inline (always)]
pub fn tsensoren (& self) -> TSENSOREN_R { TSENSOREN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 8 - REF Reference generator active"]
# [inline (always)]
pub fn refgenact (& self) -> REFGENACT_R { REFGENACT_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - REF Reference bandgap active"]
# [inline (always)]
pub fn refbgact (& self) -> REFBGACT_R { REFBGACT_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 11 - REF Bandgap mode"]
# [inline (always)]
pub fn bgmode (& self) -> BGMODE_R { BGMODE_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - REF Reference generator ready"]
# [inline (always)]
pub fn refgenrdy (& self) -> REFGENRDY_R { REFGENRDY_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - REF Reference bandgap ready"]
# [inline (always)]
pub fn refbgrdy (& self) -> REFBGRDY_R { REFBGRDY_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Internal Reference Enable"]
# [inline (always)]
pub fn intrefen (& mut self) -> INTREFEN_W < 0 > { INTREFEN_W :: new (self) } # [doc = "Bit 1 - External Reference output Enable"]
# [inline (always)]
pub fn extrefen (& mut self) -> EXTREFEN_W < 1 > { EXTREFEN_W :: new (self) } # [doc = "Bit 3 - Temperature Sensor Enable"]
# [inline (always)]
pub fn tsensoren (& mut self) -> TSENSOREN_W < 3 > { TSENSOREN_W :: new (self) } # [doc = "Bit 8 - REF Reference generator active"]
# [inline (always)]
pub fn refgenact (& mut self) -> REFGENACT_W < 8 > { REFGENACT_W :: new (self) } # [doc = "Bit 9 - REF Reference bandgap active"]
# [inline (always)]
pub fn refbgact (& mut self) -> REFBGACT_W < 9 > { REFBGACT_W :: new (self) } # [doc = "Bit 11 - REF Bandgap mode"]
# [inline (always)]
pub fn bgmode (& mut self) -> BGMODE_W < 11 > { BGMODE_W :: new (self) } # [doc = "Bit 12 - REF Reference generator ready"]
# [inline (always)]
pub fn refgenrdy (& mut self) -> REFGENRDY_W < 12 > { REFGENRDY_W :: new (self) } # [doc = "Bit 13 - REF Reference bandgap ready"]
# [inline (always)]
pub fn refbgrdy (& mut self) -> REFBGRDY_W < 13 > { REFBGRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmctl2](index.html) module"]
pub struct PMMCTL2_SPEC ; impl crate :: RegisterSpec for PMMCTL2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pmmctl2::R](R) reader structure"]
impl crate :: Readable for PMMCTL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmmctl2::W](W) writer structure"]
impl crate :: Writable for PMMCTL2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMMCTL2 to value 0"]
impl crate :: Resettable for PMMCTL2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PMMIFG register accessor: an alias for `Reg<PMMIFG_SPEC>`"]
pub type PMMIFG = crate :: Reg < pmmifg :: PMMIFG_SPEC > ; # [doc = "PMM Interrupt Flag"]
pub mod pmmifg { # [doc = "Register `PMMIFG` reader"]
pub struct R (crate :: R < PMMIFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMMIFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMMIFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMMIFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `PMMIFG` writer"]
pub struct W (crate :: W < PMMIFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMMIFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMMIFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMMIFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PMMBORIFG` reader - PMM Software BOR interrupt flag"]
pub type PMMBORIFG_R = crate :: BitReader < bool > ; # [doc = "Field `PMMBORIFG` writer - PMM Software BOR interrupt flag"]
pub type PMMBORIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMIFG_SPEC , bool , O > ; # [doc = "Field `PMMRSTIFG` reader - PMM RESET pin interrupt flag"]
pub type PMMRSTIFG_R = crate :: BitReader < bool > ; # [doc = "Field `PMMRSTIFG` writer - PMM RESET pin interrupt flag"]
pub type PMMRSTIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMIFG_SPEC , bool , O > ; # [doc = "Field `PMMPORIFG` reader - PMM Software POR interrupt flag"]
pub type PMMPORIFG_R = crate :: BitReader < bool > ; # [doc = "Field `PMMPORIFG` writer - PMM Software POR interrupt flag"]
pub type PMMPORIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMIFG_SPEC , bool , O > ; # [doc = "Field `SVSHIFG` reader - SVS low side interrupt flag"]
pub type SVSHIFG_R = crate :: BitReader < bool > ; # [doc = "Field `SVSHIFG` writer - SVS low side interrupt flag"]
pub type SVSHIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMIFG_SPEC , bool , O > ; # [doc = "Field `PMMLPM5IFG` reader - LPM5 indication Flag"]
pub type PMMLPM5IFG_R = crate :: BitReader < bool > ; # [doc = "Field `PMMLPM5IFG` writer - LPM5 indication Flag"]
pub type PMMLPM5IFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PMMIFG_SPEC , bool , O > ; impl R { # [doc = "Bit 8 - PMM Software BOR interrupt flag"]
# [inline (always)]
pub fn pmmborifg (& self) -> PMMBORIFG_R { PMMBORIFG_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - PMM RESET pin interrupt flag"]
# [inline (always)]
pub fn pmmrstifg (& self) -> PMMRSTIFG_R { PMMRSTIFG_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - PMM Software POR interrupt flag"]
# [inline (always)]
pub fn pmmporifg (& self) -> PMMPORIFG_R { PMMPORIFG_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 13 - SVS low side interrupt flag"]
# [inline (always)]
pub fn svshifg (& self) -> SVSHIFG_R { SVSHIFG_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 15 - LPM5 indication Flag"]
# [inline (always)]
pub fn pmmlpm5ifg (& self) -> PMMLPM5IFG_R { PMMLPM5IFG_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 8 - PMM Software BOR interrupt flag"]
# [inline (always)]
pub fn pmmborifg (& mut self) -> PMMBORIFG_W < 8 > { PMMBORIFG_W :: new (self) } # [doc = "Bit 9 - PMM RESET pin interrupt flag"]
# [inline (always)]
pub fn pmmrstifg (& mut self) -> PMMRSTIFG_W < 9 > { PMMRSTIFG_W :: new (self) } # [doc = "Bit 10 - PMM Software POR interrupt flag"]
# [inline (always)]
pub fn pmmporifg (& mut self) -> PMMPORIFG_W < 10 > { PMMPORIFG_W :: new (self) } # [doc = "Bit 13 - SVS low side interrupt flag"]
# [inline (always)]
pub fn svshifg (& mut self) -> SVSHIFG_W < 13 > { SVSHIFG_W :: new (self) } # [doc = "Bit 15 - LPM5 indication Flag"]
# [inline (always)]
pub fn pmmlpm5ifg (& mut self) -> PMMLPM5IFG_W < 15 > { PMMLPM5IFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmifg](index.html) module"]
pub struct PMMIFG_SPEC ; impl crate :: RegisterSpec for PMMIFG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pmmifg::R](R) reader structure"]
impl crate :: Readable for PMMIFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmmifg::W](W) writer structure"]
impl crate :: Writable for PMMIFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMMIFG to value 0"]
impl crate :: Resettable for PMMIFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PMMIE register accessor: an alias for `Reg<PMMIE_SPEC>`"]
pub type PMMIE = crate :: Reg < pmmie :: PMMIE_SPEC > ; # [doc = "PMM Interrupt Enable"]
pub mod pmmie { # [doc = "Register `PMMIE` reader"]
pub struct R (crate :: R < PMMIE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMMIE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMMIE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMMIE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PMMIE` writer"]
pub struct W (crate :: W < PMMIE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMMIE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMMIE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMMIE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmmie](index.html) module"]
pub struct PMMIE_SPEC ; impl crate :: RegisterSpec for PMMIE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pmmie::R](R) reader structure"]
impl crate :: Readable for PMMIE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmmie::W](W) writer structure"]
impl crate :: Writable for PMMIE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMMIE to value 0"]
impl crate :: Resettable for PMMIE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PM5CTL0 register accessor: an alias for `Reg<PM5CTL0_SPEC>`"]
pub type PM5CTL0 = crate :: Reg < pm5ctl0 :: PM5CTL0_SPEC > ; # [doc = "PMM Power Mode 5 Control Register 0"]
pub mod pm5ctl0 { # [doc = "Register `PM5CTL0` reader"]
pub struct R (crate :: R < PM5CTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PM5CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PM5CTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PM5CTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PM5CTL0` writer"]
pub struct W (crate :: W < PM5CTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PM5CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PM5CTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PM5CTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOCKLPM5` reader - Lock I/O pin configuration upon entry/exit to/from LPM5"]
pub type LOCKLPM5_R = crate :: BitReader < bool > ; # [doc = "Field `LOCKLPM5` writer - Lock I/O pin configuration upon entry/exit to/from LPM5"]
pub type LOCKLPM5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PM5CTL0_SPEC , bool , O > ; # [doc = "Field `LPM5SW` reader - LPMx.5 switch dis/connected"]
pub type LPM5SW_R = crate :: BitReader < bool > ; # [doc = "Field `LPM5SW` writer - LPMx.5 switch dis/connected"]
pub type LPM5SW_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PM5CTL0_SPEC , bool , O > ; # [doc = "Field `LPM5SM` reader - Manual mode for LPM3.5 switch"]
pub type LPM5SM_R = crate :: BitReader < bool > ; # [doc = "Field `LPM5SM` writer - Manual mode for LPM3.5 switch"]
pub type LPM5SM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , PM5CTL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Lock I/O pin configuration upon entry/exit to/from LPM5"]
# [inline (always)]
pub fn locklpm5 (& self) -> LOCKLPM5_R { LOCKLPM5_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - LPMx.5 switch dis/connected"]
# [inline (always)]
pub fn lpm5sw (& self) -> LPM5SW_R { LPM5SW_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Manual mode for LPM3.5 switch"]
# [inline (always)]
pub fn lpm5sm (& self) -> LPM5SM_R { LPM5SM_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Lock I/O pin configuration upon entry/exit to/from LPM5"]
# [inline (always)]
pub fn locklpm5 (& mut self) -> LOCKLPM5_W < 0 > { LOCKLPM5_W :: new (self) } # [doc = "Bit 4 - LPMx.5 switch dis/connected"]
# [inline (always)]
pub fn lpm5sw (& mut self) -> LPM5SW_W < 4 > { LPM5SW_W :: new (self) } # [doc = "Bit 5 - Manual mode for LPM3.5 switch"]
# [inline (always)]
pub fn lpm5sm (& mut self) -> LPM5SM_W < 5 > { LPM5SM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PMM Power Mode 5 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pm5ctl0](index.html) module"]
pub struct PM5CTL0_SPEC ; impl crate :: RegisterSpec for PM5CTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pm5ctl0::R](R) reader structure"]
impl crate :: Readable for PM5CTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pm5ctl0::W](W) writer structure"]
impl crate :: Writable for PM5CTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PM5CTL0 to value 0"]
impl crate :: Resettable for PM5CTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "SYS System Module"]
pub struct SYS { _marker : PhantomData < * const () > } unsafe impl Send for SYS { } impl SYS { # [doc = r"Pointer to the register block"]
pub const PTR : * const sys :: RegisterBlock = 0x0140 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sys :: RegisterBlock { Self :: PTR } } impl Deref for SYS { type Target = sys :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYS") . finish () } } # [doc = "SYS System Module"]
pub mod sys { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - System control"]
pub sysctl : crate :: Reg < sysctl :: SYSCTL_SPEC > , # [doc = "0x02 - Boot strap configuration area"]
pub sysbslc : crate :: Reg < sysbslc :: SYSBSLC_SPEC > , _reserved2 : [u8 ; 0x02]
, # [doc = "0x06 - JTAG mailbox control"]
pub sysjmbc : crate :: Reg < sysjmbc :: SYSJMBC_SPEC > , # [doc = "0x08 - JTAG mailbox input 0"]
pub sysjmbi0 : crate :: Reg < sysjmbi0 :: SYSJMBI0_SPEC > , # [doc = "0x0a - JTAG mailbox input 1"]
pub sysjmbi1 : crate :: Reg < sysjmbi1 :: SYSJMBI1_SPEC > , # [doc = "0x0c - JTAG mailbox output 0"]
pub sysjmbo0 : crate :: Reg < sysjmbo0 :: SYSJMBO0_SPEC > , # [doc = "0x0e - JTAG mailbox output 1"]
pub sysjmbo1 : crate :: Reg < sysjmbo1 :: SYSJMBO1_SPEC > , _reserved7 : [u8 ; 0x08]
, # [doc = "0x18 - Bus Error vector generator"]
pub sysberriv : crate :: Reg < sysberriv :: SYSBERRIV_SPEC > , # [doc = "0x1a - User NMI vector generator"]
pub sysuniv : crate :: Reg < sysuniv :: SYSUNIV_SPEC > , # [doc = "0x1c - System NMI vector generator"]
pub syssniv : crate :: Reg < syssniv :: SYSSNIV_SPEC > , # [doc = "0x1e - Reset vector generator"]
pub sysrstiv : crate :: Reg < sysrstiv :: SYSRSTIV_SPEC > , # [doc = "0x20 - System Configuration 0"]
pub syscfg0 : crate :: Reg < syscfg0 :: SYSCFG0_SPEC > , # [doc = "0x22 - System Configuration 1"]
pub syscfg1 : crate :: Reg < syscfg1 :: SYSCFG1_SPEC > , # [doc = "0x24 - System Configuration 2"]
pub syscfg2 : crate :: Reg < syscfg2 :: SYSCFG2_SPEC > , } # [doc = "SYSCTL register accessor: an alias for `Reg<SYSCTL_SPEC>`"]
pub type SYSCTL = crate :: Reg < sysctl :: SYSCTL_SPEC > ; # [doc = "System control"]
pub mod sysctl { # [doc = "Register `SYSCTL` reader"]
pub struct R (crate :: R < SYSCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCTL` writer"]
pub struct W (crate :: W < SYSCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYSRIVECT` reader - SYS - RAM based interrupt vectors"]
pub type SYSRIVECT_R = crate :: BitReader < bool > ; # [doc = "Field `SYSRIVECT` writer - SYS - RAM based interrupt vectors"]
pub type SYSRIVECT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCTL_SPEC , bool , O > ; # [doc = "Field `SYSPMMPE` reader - SYS - PMM access protect"]
pub type SYSPMMPE_R = crate :: BitReader < bool > ; # [doc = "Field `SYSPMMPE` writer - SYS - PMM access protect"]
pub type SYSPMMPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCTL_SPEC , bool , O > ; # [doc = "Field `SYSBSLIND` reader - SYS - TCK/RST indication detected"]
pub type SYSBSLIND_R = crate :: BitReader < bool > ; # [doc = "Field `SYSBSLIND` writer - SYS - TCK/RST indication detected"]
pub type SYSBSLIND_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCTL_SPEC , bool , O > ; # [doc = "Field `SYSJTAGPIN` reader - SYS - Dedicated JTAG pins enabled"]
pub type SYSJTAGPIN_R = crate :: BitReader < bool > ; # [doc = "Field `SYSJTAGPIN` writer - SYS - Dedicated JTAG pins enabled"]
pub type SYSJTAGPIN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCTL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SYS - RAM based interrupt vectors"]
# [inline (always)]
pub fn sysrivect (& self) -> SYSRIVECT_R { SYSRIVECT_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - SYS - PMM access protect"]
# [inline (always)]
pub fn syspmmpe (& self) -> SYSPMMPE_R { SYSPMMPE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - SYS - TCK/RST indication detected"]
# [inline (always)]
pub fn sysbslind (& self) -> SYSBSLIND_R { SYSBSLIND_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - SYS - Dedicated JTAG pins enabled"]
# [inline (always)]
pub fn sysjtagpin (& self) -> SYSJTAGPIN_R { SYSJTAGPIN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - SYS - RAM based interrupt vectors"]
# [inline (always)]
pub fn sysrivect (& mut self) -> SYSRIVECT_W < 0 > { SYSRIVECT_W :: new (self) } # [doc = "Bit 2 - SYS - PMM access protect"]
# [inline (always)]
pub fn syspmmpe (& mut self) -> SYSPMMPE_W < 2 > { SYSPMMPE_W :: new (self) } # [doc = "Bit 4 - SYS - TCK/RST indication detected"]
# [inline (always)]
pub fn sysbslind (& mut self) -> SYSBSLIND_W < 4 > { SYSBSLIND_W :: new (self) } # [doc = "Bit 5 - SYS - Dedicated JTAG pins enabled"]
# [inline (always)]
pub fn sysjtagpin (& mut self) -> SYSJTAGPIN_W < 5 > { SYSJTAGPIN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysctl](index.html) module"]
pub struct SYSCTL_SPEC ; impl crate :: RegisterSpec for SYSCTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysctl::R](R) reader structure"]
impl crate :: Readable for SYSCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysctl::W](W) writer structure"]
impl crate :: Writable for SYSCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSCTL to value 0"]
impl crate :: Resettable for SYSCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSBSLC register accessor: an alias for `Reg<SYSBSLC_SPEC>`"]
pub type SYSBSLC = crate :: Reg < sysbslc :: SYSBSLC_SPEC > ; # [doc = "Boot strap configuration area"]
pub mod sysbslc { # [doc = "Register `SYSBSLC` reader"]
pub struct R (crate :: R < SYSBSLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSBSLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSBSLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSBSLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSBSLC` writer"]
pub struct W (crate :: W < SYSBSLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSBSLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSBSLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSBSLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYSBSLR` reader - SYS - RAM assigned to BSL"]
pub type SYSBSLR_R = crate :: BitReader < bool > ; # [doc = "Field `SYSBSLR` writer - SYS - RAM assigned to BSL"]
pub type SYSBSLR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSBSLC_SPEC , bool , O > ; # [doc = "Field `SYSBSLOFF` reader - SYS - BSL Memory disabled"]
pub type SYSBSLOFF_R = crate :: BitReader < bool > ; # [doc = "Field `SYSBSLOFF` writer - SYS - BSL Memory disabled"]
pub type SYSBSLOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSBSLC_SPEC , bool , O > ; # [doc = "Field `SYSBSLPE` reader - SYS - BSL Memory protection enabled"]
pub type SYSBSLPE_R = crate :: BitReader < bool > ; # [doc = "Field `SYSBSLPE` writer - SYS - BSL Memory protection enabled"]
pub type SYSBSLPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSBSLC_SPEC , bool , O > ; impl R { # [doc = "Bit 2 - SYS - RAM assigned to BSL"]
# [inline (always)]
pub fn sysbslr (& self) -> SYSBSLR_R { SYSBSLR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 14 - SYS - BSL Memory disabled"]
# [inline (always)]
pub fn sysbsloff (& self) -> SYSBSLOFF_R { SYSBSLOFF_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - SYS - BSL Memory protection enabled"]
# [inline (always)]
pub fn sysbslpe (& self) -> SYSBSLPE_R { SYSBSLPE_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 2 - SYS - RAM assigned to BSL"]
# [inline (always)]
pub fn sysbslr (& mut self) -> SYSBSLR_W < 2 > { SYSBSLR_W :: new (self) } # [doc = "Bit 14 - SYS - BSL Memory disabled"]
# [inline (always)]
pub fn sysbsloff (& mut self) -> SYSBSLOFF_W < 14 > { SYSBSLOFF_W :: new (self) } # [doc = "Bit 15 - SYS - BSL Memory protection enabled"]
# [inline (always)]
pub fn sysbslpe (& mut self) -> SYSBSLPE_W < 15 > { SYSBSLPE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Boot strap configuration area\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysbslc](index.html) module"]
pub struct SYSBSLC_SPEC ; impl crate :: RegisterSpec for SYSBSLC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysbslc::R](R) reader structure"]
impl crate :: Readable for SYSBSLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysbslc::W](W) writer structure"]
impl crate :: Writable for SYSBSLC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSBSLC to value 0"]
impl crate :: Resettable for SYSBSLC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSJMBC register accessor: an alias for `Reg<SYSJMBC_SPEC>`"]
pub type SYSJMBC = crate :: Reg < sysjmbc :: SYSJMBC_SPEC > ; # [doc = "JTAG mailbox control"]
pub mod sysjmbc { # [doc = "Register `SYSJMBC` reader"]
pub struct R (crate :: R < SYSJMBC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSJMBC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSJMBC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSJMBC_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSJMBC` writer"]
pub struct W (crate :: W < SYSJMBC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSJMBC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSJMBC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSJMBC_SPEC >) -> Self { W (writer) } } # [doc = "Field `JMBIN0FG` reader - SYS - Incoming JTAG Mailbox 0 Flag"]
pub type JMBIN0FG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBIN0FG` writer - SYS - Incoming JTAG Mailbox 0 Flag"]
pub type JMBIN0FG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBIN1FG` reader - SYS - Incoming JTAG Mailbox 1 Flag"]
pub type JMBIN1FG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBIN1FG` writer - SYS - Incoming JTAG Mailbox 1 Flag"]
pub type JMBIN1FG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBOUT0FG` reader - SYS - Outgoing JTAG Mailbox 0 Flag"]
pub type JMBOUT0FG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBOUT0FG` writer - SYS - Outgoing JTAG Mailbox 0 Flag"]
pub type JMBOUT0FG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBOUT1FG` reader - SYS - Outgoing JTAG Mailbox 1 Flag"]
pub type JMBOUT1FG_R = crate :: BitReader < bool > ; # [doc = "Field `JMBOUT1FG` writer - SYS - Outgoing JTAG Mailbox 1 Flag"]
pub type JMBOUT1FG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBMODE` reader - SYS - JMB 16/32 Bit Mode"]
pub type JMBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `JMBMODE` writer - SYS - JMB 16/32 Bit Mode"]
pub type JMBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBCLR0OFF` reader - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe"]
pub type JMBCLR0OFF_R = crate :: BitReader < bool > ; # [doc = "Field `JMBCLR0OFF` writer - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe"]
pub type JMBCLR0OFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; # [doc = "Field `JMBCLR1OFF` reader - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe"]
pub type JMBCLR1OFF_R = crate :: BitReader < bool > ; # [doc = "Field `JMBCLR1OFF` writer - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe"]
pub type JMBCLR1OFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSJMBC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SYS - Incoming JTAG Mailbox 0 Flag"]
# [inline (always)]
pub fn jmbin0fg (& self) -> JMBIN0FG_R { JMBIN0FG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SYS - Incoming JTAG Mailbox 1 Flag"]
# [inline (always)]
pub fn jmbin1fg (& self) -> JMBIN1FG_R { JMBIN1FG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SYS - Outgoing JTAG Mailbox 0 Flag"]
# [inline (always)]
pub fn jmbout0fg (& self) -> JMBOUT0FG_R { JMBOUT0FG_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - SYS - Outgoing JTAG Mailbox 1 Flag"]
# [inline (always)]
pub fn jmbout1fg (& self) -> JMBOUT1FG_R { JMBOUT1FG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - SYS - JMB 16/32 Bit Mode"]
# [inline (always)]
pub fn jmbmode (& self) -> JMBMODE_R { JMBMODE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe"]
# [inline (always)]
pub fn jmbclr0off (& self) -> JMBCLR0OFF_R { JMBCLR0OFF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe"]
# [inline (always)]
pub fn jmbclr1off (& self) -> JMBCLR1OFF_R { JMBCLR1OFF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - SYS - Incoming JTAG Mailbox 0 Flag"]
# [inline (always)]
pub fn jmbin0fg (& mut self) -> JMBIN0FG_W < 0 > { JMBIN0FG_W :: new (self) } # [doc = "Bit 1 - SYS - Incoming JTAG Mailbox 1 Flag"]
# [inline (always)]
pub fn jmbin1fg (& mut self) -> JMBIN1FG_W < 1 > { JMBIN1FG_W :: new (self) } # [doc = "Bit 2 - SYS - Outgoing JTAG Mailbox 0 Flag"]
# [inline (always)]
pub fn jmbout0fg (& mut self) -> JMBOUT0FG_W < 2 > { JMBOUT0FG_W :: new (self) } # [doc = "Bit 3 - SYS - Outgoing JTAG Mailbox 1 Flag"]
# [inline (always)]
pub fn jmbout1fg (& mut self) -> JMBOUT1FG_W < 3 > { JMBOUT1FG_W :: new (self) } # [doc = "Bit 4 - SYS - JMB 16/32 Bit Mode"]
# [inline (always)]
pub fn jmbmode (& mut self) -> JMBMODE_W < 4 > { JMBMODE_W :: new (self) } # [doc = "Bit 6 - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe"]
# [inline (always)]
pub fn jmbclr0off (& mut self) -> JMBCLR0OFF_W < 6 > { JMBCLR0OFF_W :: new (self) } # [doc = "Bit 7 - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe"]
# [inline (always)]
pub fn jmbclr1off (& mut self) -> JMBCLR1OFF_W < 7 > { JMBCLR1OFF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "JTAG mailbox control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbc](index.html) module"]
pub struct SYSJMBC_SPEC ; impl crate :: RegisterSpec for SYSJMBC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysjmbc::R](R) reader structure"]
impl crate :: Readable for SYSJMBC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysjmbc::W](W) writer structure"]
impl crate :: Writable for SYSJMBC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSJMBC to value 0"]
impl crate :: Resettable for SYSJMBC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSJMBI0 register accessor: an alias for `Reg<SYSJMBI0_SPEC>`"]
pub type SYSJMBI0 = crate :: Reg < sysjmbi0 :: SYSJMBI0_SPEC > ; # [doc = "JTAG mailbox input 0"]
pub mod sysjmbi0 { # [doc = "Register `SYSJMBI0` reader"]
pub struct R (crate :: R < SYSJMBI0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSJMBI0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSJMBI0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSJMBI0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSJMBI0` writer"]
pub struct W (crate :: W < SYSJMBI0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSJMBI0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSJMBI0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSJMBI0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "JTAG mailbox input 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbi0](index.html) module"]
pub struct SYSJMBI0_SPEC ; impl crate :: RegisterSpec for SYSJMBI0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysjmbi0::R](R) reader structure"]
impl crate :: Readable for SYSJMBI0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysjmbi0::W](W) writer structure"]
impl crate :: Writable for SYSJMBI0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSJMBI0 to value 0"]
impl crate :: Resettable for SYSJMBI0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSJMBI1 register accessor: an alias for `Reg<SYSJMBI1_SPEC>`"]
pub type SYSJMBI1 = crate :: Reg < sysjmbi1 :: SYSJMBI1_SPEC > ; # [doc = "JTAG mailbox input 1"]
pub mod sysjmbi1 { # [doc = "Register `SYSJMBI1` reader"]
pub struct R (crate :: R < SYSJMBI1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSJMBI1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSJMBI1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSJMBI1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSJMBI1` writer"]
pub struct W (crate :: W < SYSJMBI1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSJMBI1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSJMBI1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSJMBI1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "JTAG mailbox input 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbi1](index.html) module"]
pub struct SYSJMBI1_SPEC ; impl crate :: RegisterSpec for SYSJMBI1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysjmbi1::R](R) reader structure"]
impl crate :: Readable for SYSJMBI1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysjmbi1::W](W) writer structure"]
impl crate :: Writable for SYSJMBI1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSJMBI1 to value 0"]
impl crate :: Resettable for SYSJMBI1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSJMBO0 register accessor: an alias for `Reg<SYSJMBO0_SPEC>`"]
pub type SYSJMBO0 = crate :: Reg < sysjmbo0 :: SYSJMBO0_SPEC > ; # [doc = "JTAG mailbox output 0"]
pub mod sysjmbo0 { # [doc = "Register `SYSJMBO0` reader"]
pub struct R (crate :: R < SYSJMBO0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSJMBO0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSJMBO0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSJMBO0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSJMBO0` writer"]
pub struct W (crate :: W < SYSJMBO0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSJMBO0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSJMBO0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSJMBO0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "JTAG mailbox output 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbo0](index.html) module"]
pub struct SYSJMBO0_SPEC ; impl crate :: RegisterSpec for SYSJMBO0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysjmbo0::R](R) reader structure"]
impl crate :: Readable for SYSJMBO0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysjmbo0::W](W) writer structure"]
impl crate :: Writable for SYSJMBO0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSJMBO0 to value 0"]
impl crate :: Resettable for SYSJMBO0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSJMBO1 register accessor: an alias for `Reg<SYSJMBO1_SPEC>`"]
pub type SYSJMBO1 = crate :: Reg < sysjmbo1 :: SYSJMBO1_SPEC > ; # [doc = "JTAG mailbox output 1"]
pub mod sysjmbo1 { # [doc = "Register `SYSJMBO1` reader"]
pub struct R (crate :: R < SYSJMBO1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSJMBO1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSJMBO1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSJMBO1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSJMBO1` writer"]
pub struct W (crate :: W < SYSJMBO1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSJMBO1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSJMBO1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSJMBO1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "JTAG mailbox output 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysjmbo1](index.html) module"]
pub struct SYSJMBO1_SPEC ; impl crate :: RegisterSpec for SYSJMBO1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysjmbo1::R](R) reader structure"]
impl crate :: Readable for SYSJMBO1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysjmbo1::W](W) writer structure"]
impl crate :: Writable for SYSJMBO1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSJMBO1 to value 0"]
impl crate :: Resettable for SYSJMBO1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSBERRIV register accessor: an alias for `Reg<SYSBERRIV_SPEC>`"]
pub type SYSBERRIV = crate :: Reg < sysberriv :: SYSBERRIV_SPEC > ; # [doc = "Bus Error vector generator"]
pub mod sysberriv { # [doc = "Register `SYSBERRIV` reader"]
pub struct R (crate :: R < SYSBERRIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSBERRIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSBERRIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSBERRIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSBERRIV` writer"]
pub struct W (crate :: W < SYSBERRIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSBERRIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSBERRIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSBERRIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Bus Error vector generator\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysberriv](index.html) module"]
pub struct SYSBERRIV_SPEC ; impl crate :: RegisterSpec for SYSBERRIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysberriv::R](R) reader structure"]
impl crate :: Readable for SYSBERRIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysberriv::W](W) writer structure"]
impl crate :: Writable for SYSBERRIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSBERRIV to value 0"]
impl crate :: Resettable for SYSBERRIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSUNIV register accessor: an alias for `Reg<SYSUNIV_SPEC>`"]
pub type SYSUNIV = crate :: Reg < sysuniv :: SYSUNIV_SPEC > ; # [doc = "User NMI vector generator"]
pub mod sysuniv { # [doc = "Register `SYSUNIV` reader"]
pub struct R (crate :: R < SYSUNIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSUNIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSUNIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSUNIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSUNIV` writer"]
pub struct W (crate :: W < SYSUNIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSUNIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSUNIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSUNIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User NMI vector generator\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysuniv](index.html) module"]
pub struct SYSUNIV_SPEC ; impl crate :: RegisterSpec for SYSUNIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysuniv::R](R) reader structure"]
impl crate :: Readable for SYSUNIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysuniv::W](W) writer structure"]
impl crate :: Writable for SYSUNIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSUNIV to value 0"]
impl crate :: Resettable for SYSUNIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSSNIV register accessor: an alias for `Reg<SYSSNIV_SPEC>`"]
pub type SYSSNIV = crate :: Reg < syssniv :: SYSSNIV_SPEC > ; # [doc = "System NMI vector generator"]
pub mod syssniv { # [doc = "Register `SYSSNIV` reader"]
pub struct R (crate :: R < SYSSNIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSSNIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSSNIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSSNIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSSNIV` writer"]
pub struct W (crate :: W < SYSSNIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSSNIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSSNIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSSNIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System NMI vector generator\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syssniv](index.html) module"]
pub struct SYSSNIV_SPEC ; impl crate :: RegisterSpec for SYSSNIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [syssniv::R](R) reader structure"]
impl crate :: Readable for SYSSNIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syssniv::W](W) writer structure"]
impl crate :: Writable for SYSSNIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSSNIV to value 0"]
impl crate :: Resettable for SYSSNIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSRSTIV register accessor: an alias for `Reg<SYSRSTIV_SPEC>`"]
pub type SYSRSTIV = crate :: Reg < sysrstiv :: SYSRSTIV_SPEC > ; # [doc = "Reset vector generator"]
pub mod sysrstiv { # [doc = "Register `SYSRSTIV` reader"]
pub struct R (crate :: R < SYSRSTIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSRSTIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSRSTIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSRSTIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSRSTIV` writer"]
pub struct W (crate :: W < SYSRSTIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSRSTIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSRSTIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSRSTIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reset vector generator\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sysrstiv](index.html) module"]
pub struct SYSRSTIV_SPEC ; impl crate :: RegisterSpec for SYSRSTIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sysrstiv::R](R) reader structure"]
impl crate :: Readable for SYSRSTIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sysrstiv::W](W) writer structure"]
impl crate :: Writable for SYSRSTIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSRSTIV to value 0"]
impl crate :: Resettable for SYSRSTIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSCFG0 register accessor: an alias for `Reg<SYSCFG0_SPEC>`"]
pub type SYSCFG0 = crate :: Reg < syscfg0 :: SYSCFG0_SPEC > ; # [doc = "System Configuration 0"]
pub mod syscfg0 { # [doc = "Register `SYSCFG0` reader"]
pub struct R (crate :: R < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG0` writer"]
pub struct W (crate :: W < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PFWP` reader - Program FRAM Write Protection"]
pub type PFWP_R = crate :: BitReader < bool > ; # [doc = "Field `PFWP` writer - Program FRAM Write Protection"]
pub type PFWP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG0_SPEC , bool , O > ; # [doc = "Field `DFWP` reader - Data FRAM Write Protection"]
pub type DFWP_R = crate :: BitReader < bool > ; # [doc = "Field `DFWP` writer - Data FRAM Write Protection"]
pub type DFWP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Program FRAM Write Protection"]
# [inline (always)]
pub fn pfwp (& self) -> PFWP_R { PFWP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data FRAM Write Protection"]
# [inline (always)]
pub fn dfwp (& self) -> DFWP_R { DFWP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Program FRAM Write Protection"]
# [inline (always)]
pub fn pfwp (& mut self) -> PFWP_W < 0 > { PFWP_W :: new (self) } # [doc = "Bit 1 - Data FRAM Write Protection"]
# [inline (always)]
pub fn dfwp (& mut self) -> DFWP_W < 1 > { DFWP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg0](index.html) module"]
pub struct SYSCFG0_SPEC ; impl crate :: RegisterSpec for SYSCFG0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [syscfg0::R](R) reader structure"]
impl crate :: Readable for SYSCFG0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg0::W](W) writer structure"]
impl crate :: Writable for SYSCFG0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSCFG0 to value 0"]
impl crate :: Resettable for SYSCFG0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSCFG1 register accessor: an alias for `Reg<SYSCFG1_SPEC>`"]
pub type SYSCFG1 = crate :: Reg < syscfg1 :: SYSCFG1_SPEC > ; # [doc = "System Configuration 1"]
pub mod syscfg1 { # [doc = "Register `SYSCFG1` reader"]
pub struct R (crate :: R < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG1` writer"]
pub struct W (crate :: W < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG1_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREN` reader - Infrared enable"]
pub type IREN_R = crate :: BitReader < bool > ; # [doc = "Field `IREN` writer - Infrared enable"]
pub type IREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG1_SPEC , bool , O > ; # [doc = "Field `IRPSEL` reader - Infrared polarity select"]
pub type IRPSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IRPSEL` writer - Infrared polarity select"]
pub type IRPSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG1_SPEC , bool , O > ; # [doc = "Field `IRMSEL` reader - Infrared mode select"]
pub type IRMSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IRMSEL` writer - Infrared mode select"]
pub type IRMSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG1_SPEC , bool , O > ; # [doc = "Field `IRDSSEL` reader - Infrared data source select"]
pub type IRDSSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IRDSSEL` writer - Infrared data source select"]
pub type IRDSSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG1_SPEC , bool , O > ; # [doc = "Field `IRDATA` reader - Infrared enable"]
pub type IRDATA_R = crate :: BitReader < bool > ; # [doc = "Field `IRDATA` writer - Infrared enable"]
pub type IRDATA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Infrared enable"]
# [inline (always)]
pub fn iren (& self) -> IREN_R { IREN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Infrared polarity select"]
# [inline (always)]
pub fn irpsel (& self) -> IRPSEL_R { IRPSEL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Infrared mode select"]
# [inline (always)]
pub fn irmsel (& self) -> IRMSEL_R { IRMSEL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Infrared data source select"]
# [inline (always)]
pub fn irdssel (& self) -> IRDSSEL_R { IRDSSEL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Infrared enable"]
# [inline (always)]
pub fn irdata (& self) -> IRDATA_R { IRDATA_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Infrared enable"]
# [inline (always)]
pub fn iren (& mut self) -> IREN_W < 0 > { IREN_W :: new (self) } # [doc = "Bit 1 - Infrared polarity select"]
# [inline (always)]
pub fn irpsel (& mut self) -> IRPSEL_W < 1 > { IRPSEL_W :: new (self) } # [doc = "Bit 2 - Infrared mode select"]
# [inline (always)]
pub fn irmsel (& mut self) -> IRMSEL_W < 2 > { IRMSEL_W :: new (self) } # [doc = "Bit 3 - Infrared data source select"]
# [inline (always)]
pub fn irdssel (& mut self) -> IRDSSEL_W < 3 > { IRDSSEL_W :: new (self) } # [doc = "Bit 4 - Infrared enable"]
# [inline (always)]
pub fn irdata (& mut self) -> IRDATA_W < 4 > { IRDATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg1](index.html) module"]
pub struct SYSCFG1_SPEC ; impl crate :: RegisterSpec for SYSCFG1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [syscfg1::R](R) reader structure"]
impl crate :: Readable for SYSCFG1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg1::W](W) writer structure"]
impl crate :: Writable for SYSCFG1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSCFG1 to value 0"]
impl crate :: Resettable for SYSCFG1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYSCFG2 register accessor: an alias for `Reg<SYSCFG2_SPEC>`"]
pub type SYSCFG2 = crate :: Reg < syscfg2 :: SYSCFG2_SPEC > ; # [doc = "System Configuration 2"]
pub mod syscfg2 { # [doc = "Register `SYSCFG2` reader"]
pub struct R (crate :: R < SYSCFG2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG2_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG2` writer"]
pub struct W (crate :: W < SYSCFG2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCPCTL0` reader - ADC input A0 pin select"]
pub type ADCPCTL0_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL0` writer - ADC input A0 pin select"]
pub type ADCPCTL0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL1` reader - ADC input A1 pin select"]
pub type ADCPCTL1_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL1` writer - ADC input A1 pin select"]
pub type ADCPCTL1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL2` reader - ADC input A2 pin select"]
pub type ADCPCTL2_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL2` writer - ADC input A2 pin select"]
pub type ADCPCTL2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL3` reader - ADC input A3 pin select"]
pub type ADCPCTL3_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL3` writer - ADC input A3 pin select"]
pub type ADCPCTL3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL4` reader - ADC input A4 pin select"]
pub type ADCPCTL4_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL4` writer - ADC input A4 pin select"]
pub type ADCPCTL4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL5` reader - ADC input A5 pin select"]
pub type ADCPCTL5_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL5` writer - ADC input A5 pin select"]
pub type ADCPCTL5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL6` reader - ADC input A6 pin select"]
pub type ADCPCTL6_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL6` writer - ADC input A6 pin select"]
pub type ADCPCTL6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; # [doc = "Field `ADCPCTL7` reader - ADC input A7 pin select"]
pub type ADCPCTL7_R = crate :: BitReader < bool > ; # [doc = "Field `ADCPCTL7` writer - ADC input A7 pin select"]
pub type ADCPCTL7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , SYSCFG2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ADC input A0 pin select"]
# [inline (always)]
pub fn adcpctl0 (& self) -> ADCPCTL0_R { ADCPCTL0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC input A1 pin select"]
# [inline (always)]
pub fn adcpctl1 (& self) -> ADCPCTL1_R { ADCPCTL1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - ADC input A2 pin select"]
# [inline (always)]
pub fn adcpctl2 (& self) -> ADCPCTL2_R { ADCPCTL2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - ADC input A3 pin select"]
# [inline (always)]
pub fn adcpctl3 (& self) -> ADCPCTL3_R { ADCPCTL3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ADC input A4 pin select"]
# [inline (always)]
pub fn adcpctl4 (& self) -> ADCPCTL4_R { ADCPCTL4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - ADC input A5 pin select"]
# [inline (always)]
pub fn adcpctl5 (& self) -> ADCPCTL5_R { ADCPCTL5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - ADC input A6 pin select"]
# [inline (always)]
pub fn adcpctl6 (& self) -> ADCPCTL6_R { ADCPCTL6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - ADC input A7 pin select"]
# [inline (always)]
pub fn adcpctl7 (& self) -> ADCPCTL7_R { ADCPCTL7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC input A0 pin select"]
# [inline (always)]
pub fn adcpctl0 (& mut self) -> ADCPCTL0_W < 0 > { ADCPCTL0_W :: new (self) } # [doc = "Bit 1 - ADC input A1 pin select"]
# [inline (always)]
pub fn adcpctl1 (& mut self) -> ADCPCTL1_W < 1 > { ADCPCTL1_W :: new (self) } # [doc = "Bit 2 - ADC input A2 pin select"]
# [inline (always)]
pub fn adcpctl2 (& mut self) -> ADCPCTL2_W < 2 > { ADCPCTL2_W :: new (self) } # [doc = "Bit 3 - ADC input A3 pin select"]
# [inline (always)]
pub fn adcpctl3 (& mut self) -> ADCPCTL3_W < 3 > { ADCPCTL3_W :: new (self) } # [doc = "Bit 4 - ADC input A4 pin select"]
# [inline (always)]
pub fn adcpctl4 (& mut self) -> ADCPCTL4_W < 4 > { ADCPCTL4_W :: new (self) } # [doc = "Bit 5 - ADC input A5 pin select"]
# [inline (always)]
pub fn adcpctl5 (& mut self) -> ADCPCTL5_W < 5 > { ADCPCTL5_W :: new (self) } # [doc = "Bit 6 - ADC input A6 pin select"]
# [inline (always)]
pub fn adcpctl6 (& mut self) -> ADCPCTL6_W < 6 > { ADCPCTL6_W :: new (self) } # [doc = "Bit 7 - ADC input A7 pin select"]
# [inline (always)]
pub fn adcpctl7 (& mut self) -> ADCPCTL7_W < 7 > { ADCPCTL7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg2](index.html) module"]
pub struct SYSCFG2_SPEC ; impl crate :: RegisterSpec for SYSCFG2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [syscfg2::R](R) reader structure"]
impl crate :: Readable for SYSCFG2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg2::W](W) writer structure"]
impl crate :: Writable for SYSCFG2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SYSCFG2 to value 0"]
impl crate :: Resettable for SYSCFG2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "CS Clock System"]
pub struct CS { _marker : PhantomData < * const () > } unsafe impl Send for CS { } impl CS { # [doc = r"Pointer to the register block"]
pub const PTR : * const cs :: RegisterBlock = 0x0180 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cs :: RegisterBlock { Self :: PTR } } impl Deref for CS { type Target = cs :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CS") . finish () } } # [doc = "CS Clock System"]
pub mod cs { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - CS Control Register 0"]
pub csctl0 : crate :: Reg < csctl0 :: CSCTL0_SPEC > , # [doc = "0x02 - CS Control Register 1"]
pub csctl1 : crate :: Reg < csctl1 :: CSCTL1_SPEC > , # [doc = "0x04 - CS Control Register 2"]
pub csctl2 : crate :: Reg < csctl2 :: CSCTL2_SPEC > , # [doc = "0x06 - CS Control Register 3"]
pub csctl3 : crate :: Reg < csctl3 :: CSCTL3_SPEC > , # [doc = "0x08 - CS Control Register 4"]
pub csctl4 : crate :: Reg < csctl4 :: CSCTL4_SPEC > , # [doc = "0x0a - CS Control Register 5"]
pub csctl5 : crate :: Reg < csctl5 :: CSCTL5_SPEC > , # [doc = "0x0c - CS Control Register 6"]
pub csctl6 : crate :: Reg < csctl6 :: CSCTL6_SPEC > , # [doc = "0x0e - CS Control Register 7"]
pub csctl7 : crate :: Reg < csctl7 :: CSCTL7_SPEC > , # [doc = "0x10 - CS Control Register 8"]
pub csctl8 : crate :: Reg < csctl8 :: CSCTL8_SPEC > , } # [doc = "CSCTL0 register accessor: an alias for `Reg<CSCTL0_SPEC>`"]
pub type CSCTL0 = crate :: Reg < csctl0 :: CSCTL0_SPEC > ; # [doc = "CS Control Register 0"]
pub mod csctl0 { # [doc = "Register `CSCTL0` reader"]
pub struct R (crate :: R < CSCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL0` writer"]
pub struct W (crate :: W < CSCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `DCO0` reader - DCO TAP Bit : 0"]
pub type DCO0_R = crate :: BitReader < bool > ; # [doc = "Field `DCO0` writer - DCO TAP Bit : 0"]
pub type DCO0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO1` reader - DCO TAP Bit : 1"]
pub type DCO1_R = crate :: BitReader < bool > ; # [doc = "Field `DCO1` writer - DCO TAP Bit : 1"]
pub type DCO1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO2` reader - DCO TAP Bit : 2"]
pub type DCO2_R = crate :: BitReader < bool > ; # [doc = "Field `DCO2` writer - DCO TAP Bit : 2"]
pub type DCO2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO3` reader - DCO TAP Bit : 3"]
pub type DCO3_R = crate :: BitReader < bool > ; # [doc = "Field `DCO3` writer - DCO TAP Bit : 3"]
pub type DCO3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO4` reader - DCO TAP Bit : 4"]
pub type DCO4_R = crate :: BitReader < bool > ; # [doc = "Field `DCO4` writer - DCO TAP Bit : 4"]
pub type DCO4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO5` reader - DCO TAP Bit : 5"]
pub type DCO5_R = crate :: BitReader < bool > ; # [doc = "Field `DCO5` writer - DCO TAP Bit : 5"]
pub type DCO5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO6` reader - DCO TAP Bit : 6"]
pub type DCO6_R = crate :: BitReader < bool > ; # [doc = "Field `DCO6` writer - DCO TAP Bit : 6"]
pub type DCO6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO7` reader - DCO TAP Bit : 7"]
pub type DCO7_R = crate :: BitReader < bool > ; # [doc = "Field `DCO7` writer - DCO TAP Bit : 7"]
pub type DCO7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `DCO8` reader - DCO TAP Bit : 8"]
pub type DCO8_R = crate :: BitReader < bool > ; # [doc = "Field `DCO8` writer - DCO TAP Bit : 8"]
pub type DCO8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `MOD0` reader - Modulation Bit Counter Bit : 0"]
pub type MOD0_R = crate :: BitReader < bool > ; # [doc = "Field `MOD0` writer - Modulation Bit Counter Bit : 0"]
pub type MOD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `MOD1` reader - Modulation Bit Counter Bit : 1"]
pub type MOD1_R = crate :: BitReader < bool > ; # [doc = "Field `MOD1` writer - Modulation Bit Counter Bit : 1"]
pub type MOD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `MOD2` reader - Modulation Bit Counter Bit : 2"]
pub type MOD2_R = crate :: BitReader < bool > ; # [doc = "Field `MOD2` writer - Modulation Bit Counter Bit : 2"]
pub type MOD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `MOD3` reader - Modulation Bit Counter Bit : 3"]
pub type MOD3_R = crate :: BitReader < bool > ; # [doc = "Field `MOD3` writer - Modulation Bit Counter Bit : 3"]
pub type MOD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; # [doc = "Field `MOD4` reader - Modulation Bit Counter Bit : 4"]
pub type MOD4_R = crate :: BitReader < bool > ; # [doc = "Field `MOD4` writer - Modulation Bit Counter Bit : 4"]
pub type MOD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DCO TAP Bit : 0"]
# [inline (always)]
pub fn dco0 (& self) -> DCO0_R { DCO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DCO TAP Bit : 1"]
# [inline (always)]
pub fn dco1 (& self) -> DCO1_R { DCO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DCO TAP Bit : 2"]
# [inline (always)]
pub fn dco2 (& self) -> DCO2_R { DCO2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DCO TAP Bit : 3"]
# [inline (always)]
pub fn dco3 (& self) -> DCO3_R { DCO3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DCO TAP Bit : 4"]
# [inline (always)]
pub fn dco4 (& self) -> DCO4_R { DCO4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DCO TAP Bit : 5"]
# [inline (always)]
pub fn dco5 (& self) -> DCO5_R { DCO5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DCO TAP Bit : 6"]
# [inline (always)]
pub fn dco6 (& self) -> DCO6_R { DCO6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DCO TAP Bit : 7"]
# [inline (always)]
pub fn dco7 (& self) -> DCO7_R { DCO7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - DCO TAP Bit : 8"]
# [inline (always)]
pub fn dco8 (& self) -> DCO8_R { DCO8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Modulation Bit Counter Bit : 0"]
# [inline (always)]
pub fn mod0 (& self) -> MOD0_R { MOD0_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Modulation Bit Counter Bit : 1"]
# [inline (always)]
pub fn mod1 (& self) -> MOD1_R { MOD1_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Modulation Bit Counter Bit : 2"]
# [inline (always)]
pub fn mod2 (& self) -> MOD2_R { MOD2_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Modulation Bit Counter Bit : 3"]
# [inline (always)]
pub fn mod3 (& self) -> MOD3_R { MOD3_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Modulation Bit Counter Bit : 4"]
# [inline (always)]
pub fn mod4 (& self) -> MOD4_R { MOD4_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - DCO TAP Bit : 0"]
# [inline (always)]
pub fn dco0 (& mut self) -> DCO0_W < 0 > { DCO0_W :: new (self) } # [doc = "Bit 1 - DCO TAP Bit : 1"]
# [inline (always)]
pub fn dco1 (& mut self) -> DCO1_W < 1 > { DCO1_W :: new (self) } # [doc = "Bit 2 - DCO TAP Bit : 2"]
# [inline (always)]
pub fn dco2 (& mut self) -> DCO2_W < 2 > { DCO2_W :: new (self) } # [doc = "Bit 3 - DCO TAP Bit : 3"]
# [inline (always)]
pub fn dco3 (& mut self) -> DCO3_W < 3 > { DCO3_W :: new (self) } # [doc = "Bit 4 - DCO TAP Bit : 4"]
# [inline (always)]
pub fn dco4 (& mut self) -> DCO4_W < 4 > { DCO4_W :: new (self) } # [doc = "Bit 5 - DCO TAP Bit : 5"]
# [inline (always)]
pub fn dco5 (& mut self) -> DCO5_W < 5 > { DCO5_W :: new (self) } # [doc = "Bit 6 - DCO TAP Bit : 6"]
# [inline (always)]
pub fn dco6 (& mut self) -> DCO6_W < 6 > { DCO6_W :: new (self) } # [doc = "Bit 7 - DCO TAP Bit : 7"]
# [inline (always)]
pub fn dco7 (& mut self) -> DCO7_W < 7 > { DCO7_W :: new (self) } # [doc = "Bit 8 - DCO TAP Bit : 8"]
# [inline (always)]
pub fn dco8 (& mut self) -> DCO8_W < 8 > { DCO8_W :: new (self) } # [doc = "Bit 9 - Modulation Bit Counter Bit : 0"]
# [inline (always)]
pub fn mod0 (& mut self) -> MOD0_W < 9 > { MOD0_W :: new (self) } # [doc = "Bit 10 - Modulation Bit Counter Bit : 1"]
# [inline (always)]
pub fn mod1 (& mut self) -> MOD1_W < 10 > { MOD1_W :: new (self) } # [doc = "Bit 11 - Modulation Bit Counter Bit : 2"]
# [inline (always)]
pub fn mod2 (& mut self) -> MOD2_W < 11 > { MOD2_W :: new (self) } # [doc = "Bit 12 - Modulation Bit Counter Bit : 3"]
# [inline (always)]
pub fn mod3 (& mut self) -> MOD3_W < 12 > { MOD3_W :: new (self) } # [doc = "Bit 13 - Modulation Bit Counter Bit : 4"]
# [inline (always)]
pub fn mod4 (& mut self) -> MOD4_W < 13 > { MOD4_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl0](index.html) module"]
pub struct CSCTL0_SPEC ; impl crate :: RegisterSpec for CSCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl0::R](R) reader structure"]
impl crate :: Readable for CSCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl0::W](W) writer structure"]
impl crate :: Writable for CSCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL0 to value 0"]
impl crate :: Resettable for CSCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL1 register accessor: an alias for `Reg<CSCTL1_SPEC>`"]
pub type CSCTL1 = crate :: Reg < csctl1 :: CSCTL1_SPEC > ; # [doc = "CS Control Register 1"]
pub mod csctl1 { # [doc = "Register `CSCTL1` reader"]
pub struct R (crate :: R < CSCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL1` writer"]
pub struct W (crate :: W < CSCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `DISMOD` reader - Disable Modulation"]
pub type DISMOD_R = crate :: BitReader < bool > ; # [doc = "Field `DISMOD` writer - Disable Modulation"]
pub type DISMOD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL1_SPEC , bool , O > ; # [doc = "DCO frequency range select Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DCORSEL_A { # [doc = "0: DCO frequency range select: 0"]
DCORSEL_0 = 0 , # [doc = "1: DCO frequency range select: 1"]
DCORSEL_1 = 1 , # [doc = "2: DCO frequency range select: 2"]
DCORSEL_2 = 2 , # [doc = "3: DCO frequency range select: 3"]
DCORSEL_3 = 3 , # [doc = "4: DCO frequency range select: 4"]
DCORSEL_4 = 4 , # [doc = "5: DCO frequency range select: 5"]
DCORSEL_5 = 5 , # [doc = "6: DCO frequency range select: 6"]
DCORSEL_6 = 6 , # [doc = "7: DCO frequency range select: 7"]
DCORSEL_7 = 7 , } impl From < DCORSEL_A > for u8 { # [inline (always)]
fn from (variant : DCORSEL_A) -> Self { variant as _ } } # [doc = "Field `DCORSEL` reader - DCO frequency range select Bit: 0"]
pub type DCORSEL_R = crate :: FieldReader < u8 , DCORSEL_A > ; impl DCORSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DCORSEL_A { match self . bits { 0 => DCORSEL_A :: DCORSEL_0 , 1 => DCORSEL_A :: DCORSEL_1 , 2 => DCORSEL_A :: DCORSEL_2 , 3 => DCORSEL_A :: DCORSEL_3 , 4 => DCORSEL_A :: DCORSEL_4 , 5 => DCORSEL_A :: DCORSEL_5 , 6 => DCORSEL_A :: DCORSEL_6 , 7 => DCORSEL_A :: DCORSEL_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DCORSEL_0`"]
# [inline (always)]
pub fn is_dcorsel_0 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_0 } # [doc = "Checks if the value of the field is `DCORSEL_1`"]
# [inline (always)]
pub fn is_dcorsel_1 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_1 } # [doc = "Checks if the value of the field is `DCORSEL_2`"]
# [inline (always)]
pub fn is_dcorsel_2 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_2 } # [doc = "Checks if the value of the field is `DCORSEL_3`"]
# [inline (always)]
pub fn is_dcorsel_3 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_3 } # [doc = "Checks if the value of the field is `DCORSEL_4`"]
# [inline (always)]
pub fn is_dcorsel_4 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_4 } # [doc = "Checks if the value of the field is `DCORSEL_5`"]
# [inline (always)]
pub fn is_dcorsel_5 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_5 } # [doc = "Checks if the value of the field is `DCORSEL_6`"]
# [inline (always)]
pub fn is_dcorsel_6 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_6 } # [doc = "Checks if the value of the field is `DCORSEL_7`"]
# [inline (always)]
pub fn is_dcorsel_7 (& self) -> bool { * self == DCORSEL_A :: DCORSEL_7 } } # [doc = "Field `DCORSEL` writer - DCO frequency range select Bit: 0"]
pub type DCORSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL1_SPEC , u8 , DCORSEL_A , 3 , O > ; impl < 'a , const O : u8 > DCORSEL_W < 'a , O > { # [doc = "DCO frequency range select: 0"]
# [inline (always)]
pub fn dcorsel_0 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_0) } # [doc = "DCO frequency range select: 1"]
# [inline (always)]
pub fn dcorsel_1 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_1) } # [doc = "DCO frequency range select: 2"]
# [inline (always)]
pub fn dcorsel_2 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_2) } # [doc = "DCO frequency range select: 3"]
# [inline (always)]
pub fn dcorsel_3 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_3) } # [doc = "DCO frequency range select: 4"]
# [inline (always)]
pub fn dcorsel_4 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_4) } # [doc = "DCO frequency range select: 5"]
# [inline (always)]
pub fn dcorsel_5 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_5) } # [doc = "DCO frequency range select: 6"]
# [inline (always)]
pub fn dcorsel_6 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_6) } # [doc = "DCO frequency range select: 7"]
# [inline (always)]
pub fn dcorsel_7 (self) -> & 'a mut W { self . variant (DCORSEL_A :: DCORSEL_7) } } # [doc = "DCO frequency trim. Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DCOFTRIM_A { # [doc = "0: DCO frequency trim: 0"]
DCOFTRIM_0 = 0 , # [doc = "1: DCO frequency trim: 1"]
DCOFTRIM_1 = 1 , # [doc = "2: DCO frequency trim: 2"]
DCOFTRIM_2 = 2 , # [doc = "3: DCO frequency trim: 3"]
DCOFTRIM_3 = 3 , # [doc = "4: DCO frequency trim: 4"]
DCOFTRIM_4 = 4 , # [doc = "5: DCO frequency trim: 5"]
DCOFTRIM_5 = 5 , # [doc = "6: DCO frequency trim: 6"]
DCOFTRIM_6 = 6 , # [doc = "7: DCO frequency trim: 7"]
DCOFTRIM_7 = 7 , } impl From < DCOFTRIM_A > for u8 { # [inline (always)]
fn from (variant : DCOFTRIM_A) -> Self { variant as _ } } # [doc = "Field `DCOFTRIM` reader - DCO frequency trim. Bit: 0"]
pub type DCOFTRIM_R = crate :: FieldReader < u8 , DCOFTRIM_A > ; impl DCOFTRIM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DCOFTRIM_A { match self . bits { 0 => DCOFTRIM_A :: DCOFTRIM_0 , 1 => DCOFTRIM_A :: DCOFTRIM_1 , 2 => DCOFTRIM_A :: DCOFTRIM_2 , 3 => DCOFTRIM_A :: DCOFTRIM_3 , 4 => DCOFTRIM_A :: DCOFTRIM_4 , 5 => DCOFTRIM_A :: DCOFTRIM_5 , 6 => DCOFTRIM_A :: DCOFTRIM_6 , 7 => DCOFTRIM_A :: DCOFTRIM_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DCOFTRIM_0`"]
# [inline (always)]
pub fn is_dcoftrim_0 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_0 } # [doc = "Checks if the value of the field is `DCOFTRIM_1`"]
# [inline (always)]
pub fn is_dcoftrim_1 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_1 } # [doc = "Checks if the value of the field is `DCOFTRIM_2`"]
# [inline (always)]
pub fn is_dcoftrim_2 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_2 } # [doc = "Checks if the value of the field is `DCOFTRIM_3`"]
# [inline (always)]
pub fn is_dcoftrim_3 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_3 } # [doc = "Checks if the value of the field is `DCOFTRIM_4`"]
# [inline (always)]
pub fn is_dcoftrim_4 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_4 } # [doc = "Checks if the value of the field is `DCOFTRIM_5`"]
# [inline (always)]
pub fn is_dcoftrim_5 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_5 } # [doc = "Checks if the value of the field is `DCOFTRIM_6`"]
# [inline (always)]
pub fn is_dcoftrim_6 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_6 } # [doc = "Checks if the value of the field is `DCOFTRIM_7`"]
# [inline (always)]
pub fn is_dcoftrim_7 (& self) -> bool { * self == DCOFTRIM_A :: DCOFTRIM_7 } } # [doc = "Field `DCOFTRIM` writer - DCO frequency trim. Bit: 0"]
pub type DCOFTRIM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL1_SPEC , u8 , DCOFTRIM_A , 3 , O > ; impl < 'a , const O : u8 > DCOFTRIM_W < 'a , O > { # [doc = "DCO frequency trim: 0"]
# [inline (always)]
pub fn dcoftrim_0 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_0) } # [doc = "DCO frequency trim: 1"]
# [inline (always)]
pub fn dcoftrim_1 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_1) } # [doc = "DCO frequency trim: 2"]
# [inline (always)]
pub fn dcoftrim_2 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_2) } # [doc = "DCO frequency trim: 3"]
# [inline (always)]
pub fn dcoftrim_3 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_3) } # [doc = "DCO frequency trim: 4"]
# [inline (always)]
pub fn dcoftrim_4 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_4) } # [doc = "DCO frequency trim: 5"]
# [inline (always)]
pub fn dcoftrim_5 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_5) } # [doc = "DCO frequency trim: 6"]
# [inline (always)]
pub fn dcoftrim_6 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_6) } # [doc = "DCO frequency trim: 7"]
# [inline (always)]
pub fn dcoftrim_7 (self) -> & 'a mut W { self . variant (DCOFTRIM_A :: DCOFTRIM_7) } } # [doc = "Field `DCOFTRIMEN` reader - DCO frequency trim enable"]
pub type DCOFTRIMEN_R = crate :: BitReader < bool > ; # [doc = "Field `DCOFTRIMEN` writer - DCO frequency trim enable"]
pub type DCOFTRIMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Disable Modulation"]
# [inline (always)]
pub fn dismod (& self) -> DISMOD_R { DISMOD_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - DCO frequency range select Bit: 0"]
# [inline (always)]
pub fn dcorsel (& self) -> DCORSEL_R { DCORSEL_R :: new (((self . bits >> 1) & 7) as u8) } # [doc = "Bits 4:6 - DCO frequency trim. Bit: 0"]
# [inline (always)]
pub fn dcoftrim (& self) -> DCOFTRIM_R { DCOFTRIM_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bit 7 - DCO frequency trim enable"]
# [inline (always)]
pub fn dcoftrimen (& self) -> DCOFTRIMEN_R { DCOFTRIMEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Disable Modulation"]
# [inline (always)]
pub fn dismod (& mut self) -> DISMOD_W < 0 > { DISMOD_W :: new (self) } # [doc = "Bits 1:3 - DCO frequency range select Bit: 0"]
# [inline (always)]
pub fn dcorsel (& mut self) -> DCORSEL_W < 1 > { DCORSEL_W :: new (self) } # [doc = "Bits 4:6 - DCO frequency trim. Bit: 0"]
# [inline (always)]
pub fn dcoftrim (& mut self) -> DCOFTRIM_W < 4 > { DCOFTRIM_W :: new (self) } # [doc = "Bit 7 - DCO frequency trim enable"]
# [inline (always)]
pub fn dcoftrimen (& mut self) -> DCOFTRIMEN_W < 7 > { DCOFTRIMEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl1](index.html) module"]
pub struct CSCTL1_SPEC ; impl crate :: RegisterSpec for CSCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl1::R](R) reader structure"]
impl crate :: Readable for CSCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl1::W](W) writer structure"]
impl crate :: Writable for CSCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL1 to value 0"]
impl crate :: Resettable for CSCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL2 register accessor: an alias for `Reg<CSCTL2_SPEC>`"]
pub type CSCTL2 = crate :: Reg < csctl2 :: CSCTL2_SPEC > ; # [doc = "CS Control Register 2"]
pub mod csctl2 { # [doc = "Register `CSCTL2` reader"]
pub struct R (crate :: R < CSCTL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL2` writer"]
pub struct W (crate :: W < CSCTL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `FLLN0` reader - FLL Multipier Bit : 0"]
pub type FLLN0_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN0` writer - FLL Multipier Bit : 0"]
pub type FLLN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN1` reader - FLL Multipier Bit : 1"]
pub type FLLN1_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN1` writer - FLL Multipier Bit : 1"]
pub type FLLN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN2` reader - FLL Multipier Bit : 2"]
pub type FLLN2_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN2` writer - FLL Multipier Bit : 2"]
pub type FLLN2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN3` reader - FLL Multipier Bit : 3"]
pub type FLLN3_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN3` writer - FLL Multipier Bit : 3"]
pub type FLLN3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN4` reader - FLL Multipier Bit : 4"]
pub type FLLN4_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN4` writer - FLL Multipier Bit : 4"]
pub type FLLN4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN5` reader - FLL Multipier Bit : 5"]
pub type FLLN5_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN5` writer - FLL Multipier Bit : 5"]
pub type FLLN5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN6` reader - FLL Multipier Bit : 6"]
pub type FLLN6_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN6` writer - FLL Multipier Bit : 6"]
pub type FLLN6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN7` reader - FLL Multipier Bit : 7"]
pub type FLLN7_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN7` writer - FLL Multipier Bit : 7"]
pub type FLLN7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN8` reader - FLL Multipier Bit : 8"]
pub type FLLN8_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN8` writer - FLL Multipier Bit : 8"]
pub type FLLN8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Field `FLLN9` reader - FLL Multipier Bit : 9"]
pub type FLLN9_R = crate :: BitReader < bool > ; # [doc = "Field `FLLN9` writer - FLL Multipier Bit : 9"]
pub type FLLN9_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL2_SPEC , bool , O > ; # [doc = "Loop Divider Bit : 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLLD_A { # [doc = "0: Multiply Selected Loop Freq. By 1"]
FLLD_0 = 0 , # [doc = "1: Multiply Selected Loop Freq. By 2"]
FLLD_1 = 1 , # [doc = "2: Multiply Selected Loop Freq. By 4"]
FLLD_2 = 2 , # [doc = "3: Multiply Selected Loop Freq. By 8"]
FLLD_3 = 3 , # [doc = "4: Multiply Selected Loop Freq. By 16"]
FLLD_4 = 4 , # [doc = "5: Multiply Selected Loop Freq. By 32"]
FLLD_5 = 5 , # [doc = "6: Reserved"]
FLLD_6 = 6 , # [doc = "7: Reserved"]
FLLD_7 = 7 , } impl From < FLLD_A > for u8 { # [inline (always)]
fn from (variant : FLLD_A) -> Self { variant as _ } } # [doc = "Field `FLLD` reader - Loop Divider Bit : 0"]
pub type FLLD_R = crate :: FieldReader < u8 , FLLD_A > ; impl FLLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FLLD_A { match self . bits { 0 => FLLD_A :: FLLD_0 , 1 => FLLD_A :: FLLD_1 , 2 => FLLD_A :: FLLD_2 , 3 => FLLD_A :: FLLD_3 , 4 => FLLD_A :: FLLD_4 , 5 => FLLD_A :: FLLD_5 , 6 => FLLD_A :: FLLD_6 , 7 => FLLD_A :: FLLD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLLD_0`"]
# [inline (always)]
pub fn is_flld_0 (& self) -> bool { * self == FLLD_A :: FLLD_0 } # [doc = "Checks if the value of the field is `FLLD_1`"]
# [inline (always)]
pub fn is_flld_1 (& self) -> bool { * self == FLLD_A :: FLLD_1 } # [doc = "Checks if the value of the field is `FLLD_2`"]
# [inline (always)]
pub fn is_flld_2 (& self) -> bool { * self == FLLD_A :: FLLD_2 } # [doc = "Checks if the value of the field is `FLLD_3`"]
# [inline (always)]
pub fn is_flld_3 (& self) -> bool { * self == FLLD_A :: FLLD_3 } # [doc = "Checks if the value of the field is `FLLD_4`"]
# [inline (always)]
pub fn is_flld_4 (& self) -> bool { * self == FLLD_A :: FLLD_4 } # [doc = "Checks if the value of the field is `FLLD_5`"]
# [inline (always)]
pub fn is_flld_5 (& self) -> bool { * self == FLLD_A :: FLLD_5 } # [doc = "Checks if the value of the field is `FLLD_6`"]
# [inline (always)]
pub fn is_flld_6 (& self) -> bool { * self == FLLD_A :: FLLD_6 } # [doc = "Checks if the value of the field is `FLLD_7`"]
# [inline (always)]
pub fn is_flld_7 (& self) -> bool { * self == FLLD_A :: FLLD_7 } } # [doc = "Field `FLLD` writer - Loop Divider Bit : 0"]
pub type FLLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL2_SPEC , u8 , FLLD_A , 3 , O > ; impl < 'a , const O : u8 > FLLD_W < 'a , O > { # [doc = "Multiply Selected Loop Freq. By 1"]
# [inline (always)]
pub fn flld_0 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_0) } # [doc = "Multiply Selected Loop Freq. By 2"]
# [inline (always)]
pub fn flld_1 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_1) } # [doc = "Multiply Selected Loop Freq. By 4"]
# [inline (always)]
pub fn flld_2 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_2) } # [doc = "Multiply Selected Loop Freq. By 8"]
# [inline (always)]
pub fn flld_3 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_3) } # [doc = "Multiply Selected Loop Freq. By 16"]
# [inline (always)]
pub fn flld_4 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_4) } # [doc = "Multiply Selected Loop Freq. By 32"]
# [inline (always)]
pub fn flld_5 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_5) } # [doc = "Reserved"]
# [inline (always)]
pub fn flld_6 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_6) } # [doc = "Reserved"]
# [inline (always)]
pub fn flld_7 (self) -> & 'a mut W { self . variant (FLLD_A :: FLLD_7) } } impl R { # [doc = "Bit 0 - FLL Multipier Bit : 0"]
# [inline (always)]
pub fn flln0 (& self) -> FLLN0_R { FLLN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - FLL Multipier Bit : 1"]
# [inline (always)]
pub fn flln1 (& self) -> FLLN1_R { FLLN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - FLL Multipier Bit : 2"]
# [inline (always)]
pub fn flln2 (& self) -> FLLN2_R { FLLN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - FLL Multipier Bit : 3"]
# [inline (always)]
pub fn flln3 (& self) -> FLLN3_R { FLLN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - FLL Multipier Bit : 4"]
# [inline (always)]
pub fn flln4 (& self) -> FLLN4_R { FLLN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - FLL Multipier Bit : 5"]
# [inline (always)]
pub fn flln5 (& self) -> FLLN5_R { FLLN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - FLL Multipier Bit : 6"]
# [inline (always)]
pub fn flln6 (& self) -> FLLN6_R { FLLN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - FLL Multipier Bit : 7"]
# [inline (always)]
pub fn flln7 (& self) -> FLLN7_R { FLLN7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - FLL Multipier Bit : 8"]
# [inline (always)]
pub fn flln8 (& self) -> FLLN8_R { FLLN8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - FLL Multipier Bit : 9"]
# [inline (always)]
pub fn flln9 (& self) -> FLLN9_R { FLLN9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bits 12:14 - Loop Divider Bit : 0"]
# [inline (always)]
pub fn flld (& self) -> FLLD_R { FLLD_R :: new (((self . bits >> 12) & 7) as u8) } } impl W { # [doc = "Bit 0 - FLL Multipier Bit : 0"]
# [inline (always)]
pub fn flln0 (& mut self) -> FLLN0_W < 0 > { FLLN0_W :: new (self) } # [doc = "Bit 1 - FLL Multipier Bit : 1"]
# [inline (always)]
pub fn flln1 (& mut self) -> FLLN1_W < 1 > { FLLN1_W :: new (self) } # [doc = "Bit 2 - FLL Multipier Bit : 2"]
# [inline (always)]
pub fn flln2 (& mut self) -> FLLN2_W < 2 > { FLLN2_W :: new (self) } # [doc = "Bit 3 - FLL Multipier Bit : 3"]
# [inline (always)]
pub fn flln3 (& mut self) -> FLLN3_W < 3 > { FLLN3_W :: new (self) } # [doc = "Bit 4 - FLL Multipier Bit : 4"]
# [inline (always)]
pub fn flln4 (& mut self) -> FLLN4_W < 4 > { FLLN4_W :: new (self) } # [doc = "Bit 5 - FLL Multipier Bit : 5"]
# [inline (always)]
pub fn flln5 (& mut self) -> FLLN5_W < 5 > { FLLN5_W :: new (self) } # [doc = "Bit 6 - FLL Multipier Bit : 6"]
# [inline (always)]
pub fn flln6 (& mut self) -> FLLN6_W < 6 > { FLLN6_W :: new (self) } # [doc = "Bit 7 - FLL Multipier Bit : 7"]
# [inline (always)]
pub fn flln7 (& mut self) -> FLLN7_W < 7 > { FLLN7_W :: new (self) } # [doc = "Bit 8 - FLL Multipier Bit : 8"]
# [inline (always)]
pub fn flln8 (& mut self) -> FLLN8_W < 8 > { FLLN8_W :: new (self) } # [doc = "Bit 9 - FLL Multipier Bit : 9"]
# [inline (always)]
pub fn flln9 (& mut self) -> FLLN9_W < 9 > { FLLN9_W :: new (self) } # [doc = "Bits 12:14 - Loop Divider Bit : 0"]
# [inline (always)]
pub fn flld (& mut self) -> FLLD_W < 12 > { FLLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl2](index.html) module"]
pub struct CSCTL2_SPEC ; impl crate :: RegisterSpec for CSCTL2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl2::R](R) reader structure"]
impl crate :: Readable for CSCTL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl2::W](W) writer structure"]
impl crate :: Writable for CSCTL2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL2 to value 0"]
impl crate :: Resettable for CSCTL2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL3 register accessor: an alias for `Reg<CSCTL3_SPEC>`"]
pub type CSCTL3 = crate :: Reg < csctl3 :: CSCTL3_SPEC > ; # [doc = "CS Control Register 3"]
pub mod csctl3 { # [doc = "Register `CSCTL3` reader"]
pub struct R (crate :: R < CSCTL3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL3_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL3` writer"]
pub struct W (crate :: W < CSCTL3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL3_SPEC >) -> Self { W (writer) } } # [doc = "Reference Divider Bit : 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLLREFDIV_A { # [doc = "0: Reference Divider: f(LFCLK)/1"]
FLLREFDIV_0 = 0 , # [doc = "1: Reference Divider: f(LFCLK)/2"]
FLLREFDIV_1 = 1 , # [doc = "2: Reference Divider: f(LFCLK)/4"]
FLLREFDIV_2 = 2 , # [doc = "3: Reference Divider: f(LFCLK)/8"]
FLLREFDIV_3 = 3 , # [doc = "4: Reference Divider: f(LFCLK)/12"]
FLLREFDIV_4 = 4 , # [doc = "5: Reference Divider: f(LFCLK)/16"]
FLLREFDIV_5 = 5 , # [doc = "6: Reference Divider: f(LFCLK)/16"]
FLLREFDIV_6 = 6 , # [doc = "7: Reference Divider: f(LFCLK)/16"]
FLLREFDIV_7 = 7 , } impl From < FLLREFDIV_A > for u8 { # [inline (always)]
fn from (variant : FLLREFDIV_A) -> Self { variant as _ } } # [doc = "Field `FLLREFDIV` reader - Reference Divider Bit : 0"]
pub type FLLREFDIV_R = crate :: FieldReader < u8 , FLLREFDIV_A > ; impl FLLREFDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FLLREFDIV_A { match self . bits { 0 => FLLREFDIV_A :: FLLREFDIV_0 , 1 => FLLREFDIV_A :: FLLREFDIV_1 , 2 => FLLREFDIV_A :: FLLREFDIV_2 , 3 => FLLREFDIV_A :: FLLREFDIV_3 , 4 => FLLREFDIV_A :: FLLREFDIV_4 , 5 => FLLREFDIV_A :: FLLREFDIV_5 , 6 => FLLREFDIV_A :: FLLREFDIV_6 , 7 => FLLREFDIV_A :: FLLREFDIV_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLLREFDIV_0`"]
# [inline (always)]
pub fn is_fllrefdiv_0 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_0 } # [doc = "Checks if the value of the field is `FLLREFDIV_1`"]
# [inline (always)]
pub fn is_fllrefdiv_1 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_1 } # [doc = "Checks if the value of the field is `FLLREFDIV_2`"]
# [inline (always)]
pub fn is_fllrefdiv_2 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_2 } # [doc = "Checks if the value of the field is `FLLREFDIV_3`"]
# [inline (always)]
pub fn is_fllrefdiv_3 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_3 } # [doc = "Checks if the value of the field is `FLLREFDIV_4`"]
# [inline (always)]
pub fn is_fllrefdiv_4 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_4 } # [doc = "Checks if the value of the field is `FLLREFDIV_5`"]
# [inline (always)]
pub fn is_fllrefdiv_5 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_5 } # [doc = "Checks if the value of the field is `FLLREFDIV_6`"]
# [inline (always)]
pub fn is_fllrefdiv_6 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_6 } # [doc = "Checks if the value of the field is `FLLREFDIV_7`"]
# [inline (always)]
pub fn is_fllrefdiv_7 (& self) -> bool { * self == FLLREFDIV_A :: FLLREFDIV_7 } } # [doc = "Field `FLLREFDIV` writer - Reference Divider Bit : 0"]
pub type FLLREFDIV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL3_SPEC , u8 , FLLREFDIV_A , 3 , O > ; impl < 'a , const O : u8 > FLLREFDIV_W < 'a , O > { # [doc = "Reference Divider: f(LFCLK)/1"]
# [inline (always)]
pub fn fllrefdiv_0 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_0) } # [doc = "Reference Divider: f(LFCLK)/2"]
# [inline (always)]
pub fn fllrefdiv_1 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_1) } # [doc = "Reference Divider: f(LFCLK)/4"]
# [inline (always)]
pub fn fllrefdiv_2 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_2) } # [doc = "Reference Divider: f(LFCLK)/8"]
# [inline (always)]
pub fn fllrefdiv_3 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_3) } # [doc = "Reference Divider: f(LFCLK)/12"]
# [inline (always)]
pub fn fllrefdiv_4 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_4) } # [doc = "Reference Divider: f(LFCLK)/16"]
# [inline (always)]
pub fn fllrefdiv_5 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_5) } # [doc = "Reference Divider: f(LFCLK)/16"]
# [inline (always)]
pub fn fllrefdiv_6 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_6) } # [doc = "Reference Divider: f(LFCLK)/16"]
# [inline (always)]
pub fn fllrefdiv_7 (self) -> & 'a mut W { self . variant (FLLREFDIV_A :: FLLREFDIV_7) } } # [doc = "FLL Reference Clock Select Bit : 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SELREF_A { # [doc = "0: FLL Reference Clock Select 0"]
SELREF_0 = 0 , # [doc = "1: FLL Reference Clock Select 1"]
SELREF_1 = 1 , # [doc = "2: FLL Reference Clock Select 2"]
SELREF_2 = 2 , # [doc = "3: FLL Reference Clock Select 3"]
SELREF_3 = 3 , } impl From < SELREF_A > for u8 { # [inline (always)]
fn from (variant : SELREF_A) -> Self { variant as _ } } # [doc = "Field `SELREF` reader - FLL Reference Clock Select Bit : 0"]
pub type SELREF_R = crate :: FieldReader < u8 , SELREF_A > ; impl SELREF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SELREF_A { match self . bits { 0 => SELREF_A :: SELREF_0 , 1 => SELREF_A :: SELREF_1 , 2 => SELREF_A :: SELREF_2 , 3 => SELREF_A :: SELREF_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `SELREF_0`"]
# [inline (always)]
pub fn is_selref_0 (& self) -> bool { * self == SELREF_A :: SELREF_0 } # [doc = "Checks if the value of the field is `SELREF_1`"]
# [inline (always)]
pub fn is_selref_1 (& self) -> bool { * self == SELREF_A :: SELREF_1 } # [doc = "Checks if the value of the field is `SELREF_2`"]
# [inline (always)]
pub fn is_selref_2 (& self) -> bool { * self == SELREF_A :: SELREF_2 } # [doc = "Checks if the value of the field is `SELREF_3`"]
# [inline (always)]
pub fn is_selref_3 (& self) -> bool { * self == SELREF_A :: SELREF_3 } } # [doc = "Field `SELREF` writer - FLL Reference Clock Select Bit : 0"]
pub type SELREF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL3_SPEC , u8 , SELREF_A , 2 , O > ; impl < 'a , const O : u8 > SELREF_W < 'a , O > { # [doc = "FLL Reference Clock Select 0"]
# [inline (always)]
pub fn selref_0 (self) -> & 'a mut W { self . variant (SELREF_A :: SELREF_0) } # [doc = "FLL Reference Clock Select 1"]
# [inline (always)]
pub fn selref_1 (self) -> & 'a mut W { self . variant (SELREF_A :: SELREF_1) } # [doc = "FLL Reference Clock Select 2"]
# [inline (always)]
pub fn selref_2 (self) -> & 'a mut W { self . variant (SELREF_A :: SELREF_2) } # [doc = "FLL Reference Clock Select 3"]
# [inline (always)]
pub fn selref_3 (self) -> & 'a mut W { self . variant (SELREF_A :: SELREF_3) } } impl R { # [doc = "Bits 0:2 - Reference Divider Bit : 0"]
# [inline (always)]
pub fn fllrefdiv (& self) -> FLLREFDIV_R { FLLREFDIV_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:5 - FLL Reference Clock Select Bit : 0"]
# [inline (always)]
pub fn selref (& self) -> SELREF_R { SELREF_R :: new (((self . bits >> 4) & 3) as u8) } } impl W { # [doc = "Bits 0:2 - Reference Divider Bit : 0"]
# [inline (always)]
pub fn fllrefdiv (& mut self) -> FLLREFDIV_W < 0 > { FLLREFDIV_W :: new (self) } # [doc = "Bits 4:5 - FLL Reference Clock Select Bit : 0"]
# [inline (always)]
pub fn selref (& mut self) -> SELREF_W < 4 > { SELREF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl3](index.html) module"]
pub struct CSCTL3_SPEC ; impl crate :: RegisterSpec for CSCTL3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl3::R](R) reader structure"]
impl crate :: Readable for CSCTL3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl3::W](W) writer structure"]
impl crate :: Writable for CSCTL3_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL3 to value 0"]
impl crate :: Resettable for CSCTL3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL4 register accessor: an alias for `Reg<CSCTL4_SPEC>`"]
pub type CSCTL4 = crate :: Reg < csctl4 :: CSCTL4_SPEC > ; # [doc = "CS Control Register 4"]
pub mod csctl4 { # [doc = "Register `CSCTL4` reader"]
pub struct R (crate :: R < CSCTL4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL4_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL4` writer"]
pub struct W (crate :: W < CSCTL4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL4_SPEC >) -> Self { W (writer) } } # [doc = "MCLK and SMCLK Source Select Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SELMS_A { # [doc = "0: MCLK and SMCLK Source Select 0"]
SELMS_0 = 0 , # [doc = "1: MCLK and SMCLK Source Select 1"]
SELMS_1 = 1 , # [doc = "2: MCLK and SMCLK Source Select 2"]
SELMS_2 = 2 , # [doc = "3: MCLK and SMCLK Source Select 3"]
SELMS_3 = 3 , # [doc = "4: MCLK and SMCLK Source Select 4"]
SELMS_4 = 4 , # [doc = "5: MCLK and SMCLK Source Select 5"]
SELMS_5 = 5 , # [doc = "6: MCLK and SMCLK Source Select 6"]
SELMS_6 = 6 , # [doc = "7: MCLK and SMCLK Source Select 7"]
SELMS_7 = 7 , } impl From < SELMS_A > for u8 { # [inline (always)]
fn from (variant : SELMS_A) -> Self { variant as _ } } # [doc = "Field `SELMS` reader - MCLK and SMCLK Source Select Bit: 0"]
pub type SELMS_R = crate :: FieldReader < u8 , SELMS_A > ; impl SELMS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SELMS_A { match self . bits { 0 => SELMS_A :: SELMS_0 , 1 => SELMS_A :: SELMS_1 , 2 => SELMS_A :: SELMS_2 , 3 => SELMS_A :: SELMS_3 , 4 => SELMS_A :: SELMS_4 , 5 => SELMS_A :: SELMS_5 , 6 => SELMS_A :: SELMS_6 , 7 => SELMS_A :: SELMS_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `SELMS_0`"]
# [inline (always)]
pub fn is_selms_0 (& self) -> bool { * self == SELMS_A :: SELMS_0 } # [doc = "Checks if the value of the field is `SELMS_1`"]
# [inline (always)]
pub fn is_selms_1 (& self) -> bool { * self == SELMS_A :: SELMS_1 } # [doc = "Checks if the value of the field is `SELMS_2`"]
# [inline (always)]
pub fn is_selms_2 (& self) -> bool { * self == SELMS_A :: SELMS_2 } # [doc = "Checks if the value of the field is `SELMS_3`"]
# [inline (always)]
pub fn is_selms_3 (& self) -> bool { * self == SELMS_A :: SELMS_3 } # [doc = "Checks if the value of the field is `SELMS_4`"]
# [inline (always)]
pub fn is_selms_4 (& self) -> bool { * self == SELMS_A :: SELMS_4 } # [doc = "Checks if the value of the field is `SELMS_5`"]
# [inline (always)]
pub fn is_selms_5 (& self) -> bool { * self == SELMS_A :: SELMS_5 } # [doc = "Checks if the value of the field is `SELMS_6`"]
# [inline (always)]
pub fn is_selms_6 (& self) -> bool { * self == SELMS_A :: SELMS_6 } # [doc = "Checks if the value of the field is `SELMS_7`"]
# [inline (always)]
pub fn is_selms_7 (& self) -> bool { * self == SELMS_A :: SELMS_7 } } # [doc = "Field `SELMS` writer - MCLK and SMCLK Source Select Bit: 0"]
pub type SELMS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL4_SPEC , u8 , SELMS_A , 3 , O > ; impl < 'a , const O : u8 > SELMS_W < 'a , O > { # [doc = "MCLK and SMCLK Source Select 0"]
# [inline (always)]
pub fn selms_0 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_0) } # [doc = "MCLK and SMCLK Source Select 1"]
# [inline (always)]
pub fn selms_1 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_1) } # [doc = "MCLK and SMCLK Source Select 2"]
# [inline (always)]
pub fn selms_2 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_2) } # [doc = "MCLK and SMCLK Source Select 3"]
# [inline (always)]
pub fn selms_3 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_3) } # [doc = "MCLK and SMCLK Source Select 4"]
# [inline (always)]
pub fn selms_4 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_4) } # [doc = "MCLK and SMCLK Source Select 5"]
# [inline (always)]
pub fn selms_5 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_5) } # [doc = "MCLK and SMCLK Source Select 6"]
# [inline (always)]
pub fn selms_6 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_6) } # [doc = "MCLK and SMCLK Source Select 7"]
# [inline (always)]
pub fn selms_7 (self) -> & 'a mut W { self . variant (SELMS_A :: SELMS_7) } } # [doc = "Field `SELA` reader - ACLK Source Select Bit: 0"]
pub type SELA_R = crate :: BitReader < bool > ; # [doc = "Field `SELA` writer - ACLK Source Select Bit: 0"]
pub type SELA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL4_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - MCLK and SMCLK Source Select Bit: 0"]
# [inline (always)]
pub fn selms (& self) -> SELMS_R { SELMS_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 8 - ACLK Source Select Bit: 0"]
# [inline (always)]
pub fn sela (& self) -> SELA_R { SELA_R :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - MCLK and SMCLK Source Select Bit: 0"]
# [inline (always)]
pub fn selms (& mut self) -> SELMS_W < 0 > { SELMS_W :: new (self) } # [doc = "Bit 8 - ACLK Source Select Bit: 0"]
# [inline (always)]
pub fn sela (& mut self) -> SELA_W < 8 > { SELA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl4](index.html) module"]
pub struct CSCTL4_SPEC ; impl crate :: RegisterSpec for CSCTL4_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl4::R](R) reader structure"]
impl crate :: Readable for CSCTL4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl4::W](W) writer structure"]
impl crate :: Writable for CSCTL4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL4 to value 0"]
impl crate :: Resettable for CSCTL4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL5 register accessor: an alias for `Reg<CSCTL5_SPEC>`"]
pub type CSCTL5 = crate :: Reg < csctl5 :: CSCTL5_SPEC > ; # [doc = "CS Control Register 5"]
pub mod csctl5 { # [doc = "Register `CSCTL5` reader"]
pub struct R (crate :: R < CSCTL5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL5_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL5` writer"]
pub struct W (crate :: W < CSCTL5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL5_SPEC >) -> Self { W (writer) } } # [doc = "MCLK Divider Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DIVM_A { # [doc = "0: MCLK Source Divider 0"]
DIVM_0 = 0 , # [doc = "1: MCLK Source Divider 1"]
DIVM_1 = 1 , # [doc = "2: MCLK Source Divider 2"]
DIVM_2 = 2 , # [doc = "3: MCLK Source Divider 3"]
DIVM_3 = 3 , # [doc = "4: MCLK Source Divider 4"]
DIVM_4 = 4 , # [doc = "5: MCLK Source Divider 5"]
DIVM_5 = 5 , # [doc = "6: MCLK Source Divider 6"]
DIVM_6 = 6 , # [doc = "7: MCLK Source Divider 7"]
DIVM_7 = 7 , } impl From < DIVM_A > for u8 { # [inline (always)]
fn from (variant : DIVM_A) -> Self { variant as _ } } # [doc = "Field `DIVM` reader - MCLK Divider Bit: 0"]
pub type DIVM_R = crate :: FieldReader < u8 , DIVM_A > ; impl DIVM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIVM_A { match self . bits { 0 => DIVM_A :: DIVM_0 , 1 => DIVM_A :: DIVM_1 , 2 => DIVM_A :: DIVM_2 , 3 => DIVM_A :: DIVM_3 , 4 => DIVM_A :: DIVM_4 , 5 => DIVM_A :: DIVM_5 , 6 => DIVM_A :: DIVM_6 , 7 => DIVM_A :: DIVM_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIVM_0`"]
# [inline (always)]
pub fn is_divm_0 (& self) -> bool { * self == DIVM_A :: DIVM_0 } # [doc = "Checks if the value of the field is `DIVM_1`"]
# [inline (always)]
pub fn is_divm_1 (& self) -> bool { * self == DIVM_A :: DIVM_1 } # [doc = "Checks if the value of the field is `DIVM_2`"]
# [inline (always)]
pub fn is_divm_2 (& self) -> bool { * self == DIVM_A :: DIVM_2 } # [doc = "Checks if the value of the field is `DIVM_3`"]
# [inline (always)]
pub fn is_divm_3 (& self) -> bool { * self == DIVM_A :: DIVM_3 } # [doc = "Checks if the value of the field is `DIVM_4`"]
# [inline (always)]
pub fn is_divm_4 (& self) -> bool { * self == DIVM_A :: DIVM_4 } # [doc = "Checks if the value of the field is `DIVM_5`"]
# [inline (always)]
pub fn is_divm_5 (& self) -> bool { * self == DIVM_A :: DIVM_5 } # [doc = "Checks if the value of the field is `DIVM_6`"]
# [inline (always)]
pub fn is_divm_6 (& self) -> bool { * self == DIVM_A :: DIVM_6 } # [doc = "Checks if the value of the field is `DIVM_7`"]
# [inline (always)]
pub fn is_divm_7 (& self) -> bool { * self == DIVM_A :: DIVM_7 } } # [doc = "Field `DIVM` writer - MCLK Divider Bit: 0"]
pub type DIVM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL5_SPEC , u8 , DIVM_A , 3 , O > ; impl < 'a , const O : u8 > DIVM_W < 'a , O > { # [doc = "MCLK Source Divider 0"]
# [inline (always)]
pub fn divm_0 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_0) } # [doc = "MCLK Source Divider 1"]
# [inline (always)]
pub fn divm_1 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_1) } # [doc = "MCLK Source Divider 2"]
# [inline (always)]
pub fn divm_2 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_2) } # [doc = "MCLK Source Divider 3"]
# [inline (always)]
pub fn divm_3 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_3) } # [doc = "MCLK Source Divider 4"]
# [inline (always)]
pub fn divm_4 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_4) } # [doc = "MCLK Source Divider 5"]
# [inline (always)]
pub fn divm_5 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_5) } # [doc = "MCLK Source Divider 6"]
# [inline (always)]
pub fn divm_6 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_6) } # [doc = "MCLK Source Divider 7"]
# [inline (always)]
pub fn divm_7 (self) -> & 'a mut W { self . variant (DIVM_A :: DIVM_7) } } # [doc = "SMCLK Divider Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DIVS_A { # [doc = "0: SMCLK Source Divider 0"]
DIVS_0 = 0 , # [doc = "1: SMCLK Source Divider 1"]
DIVS_1 = 1 , # [doc = "2: SMCLK Source Divider 2"]
DIVS_2 = 2 , # [doc = "3: SMCLK Source Divider 3"]
DIVS_3 = 3 , } impl From < DIVS_A > for u8 { # [inline (always)]
fn from (variant : DIVS_A) -> Self { variant as _ } } # [doc = "Field `DIVS` reader - SMCLK Divider Bit: 0"]
pub type DIVS_R = crate :: FieldReader < u8 , DIVS_A > ; impl DIVS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIVS_A { match self . bits { 0 => DIVS_A :: DIVS_0 , 1 => DIVS_A :: DIVS_1 , 2 => DIVS_A :: DIVS_2 , 3 => DIVS_A :: DIVS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIVS_0`"]
# [inline (always)]
pub fn is_divs_0 (& self) -> bool { * self == DIVS_A :: DIVS_0 } # [doc = "Checks if the value of the field is `DIVS_1`"]
# [inline (always)]
pub fn is_divs_1 (& self) -> bool { * self == DIVS_A :: DIVS_1 } # [doc = "Checks if the value of the field is `DIVS_2`"]
# [inline (always)]
pub fn is_divs_2 (& self) -> bool { * self == DIVS_A :: DIVS_2 } # [doc = "Checks if the value of the field is `DIVS_3`"]
# [inline (always)]
pub fn is_divs_3 (& self) -> bool { * self == DIVS_A :: DIVS_3 } } # [doc = "Field `DIVS` writer - SMCLK Divider Bit: 0"]
pub type DIVS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL5_SPEC , u8 , DIVS_A , 2 , O > ; impl < 'a , const O : u8 > DIVS_W < 'a , O > { # [doc = "SMCLK Source Divider 0"]
# [inline (always)]
pub fn divs_0 (self) -> & 'a mut W { self . variant (DIVS_A :: DIVS_0) } # [doc = "SMCLK Source Divider 1"]
# [inline (always)]
pub fn divs_1 (self) -> & 'a mut W { self . variant (DIVS_A :: DIVS_1) } # [doc = "SMCLK Source Divider 2"]
# [inline (always)]
pub fn divs_2 (self) -> & 'a mut W { self . variant (DIVS_A :: DIVS_2) } # [doc = "SMCLK Source Divider 3"]
# [inline (always)]
pub fn divs_3 (self) -> & 'a mut W { self . variant (DIVS_A :: DIVS_3) } } # [doc = "Field `SMCLKOFF` reader - SMCLK off"]
pub type SMCLKOFF_R = crate :: BitReader < bool > ; # [doc = "Field `SMCLKOFF` writer - SMCLK off"]
pub type SMCLKOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL5_SPEC , bool , O > ; # [doc = "Field `VLOAUTOOFF` reader - VLO automatic off enable"]
pub type VLOAUTOOFF_R = crate :: BitReader < bool > ; # [doc = "Field `VLOAUTOOFF` writer - VLO automatic off enable"]
pub type VLOAUTOOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL5_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - MCLK Divider Bit: 0"]
# [inline (always)]
pub fn divm (& self) -> DIVM_R { DIVM_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:5 - SMCLK Divider Bit: 0"]
# [inline (always)]
pub fn divs (& self) -> DIVS_R { DIVS_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 8 - SMCLK off"]
# [inline (always)]
pub fn smclkoff (& self) -> SMCLKOFF_R { SMCLKOFF_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 12 - VLO automatic off enable"]
# [inline (always)]
pub fn vloautooff (& self) -> VLOAUTOOFF_R { VLOAUTOOFF_R :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - MCLK Divider Bit: 0"]
# [inline (always)]
pub fn divm (& mut self) -> DIVM_W < 0 > { DIVM_W :: new (self) } # [doc = "Bits 4:5 - SMCLK Divider Bit: 0"]
# [inline (always)]
pub fn divs (& mut self) -> DIVS_W < 4 > { DIVS_W :: new (self) } # [doc = "Bit 8 - SMCLK off"]
# [inline (always)]
pub fn smclkoff (& mut self) -> SMCLKOFF_W < 8 > { SMCLKOFF_W :: new (self) } # [doc = "Bit 12 - VLO automatic off enable"]
# [inline (always)]
pub fn vloautooff (& mut self) -> VLOAUTOOFF_W < 12 > { VLOAUTOOFF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl5](index.html) module"]
pub struct CSCTL5_SPEC ; impl crate :: RegisterSpec for CSCTL5_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl5::R](R) reader structure"]
impl crate :: Readable for CSCTL5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl5::W](W) writer structure"]
impl crate :: Writable for CSCTL5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL5 to value 0"]
impl crate :: Resettable for CSCTL5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL6 register accessor: an alias for `Reg<CSCTL6_SPEC>`"]
pub type CSCTL6 = crate :: Reg < csctl6 :: CSCTL6_SPEC > ; # [doc = "CS Control Register 6"]
pub mod csctl6 { # [doc = "Register `CSCTL6` reader"]
pub struct R (crate :: R < CSCTL6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL6_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL6` writer"]
pub struct W (crate :: W < CSCTL6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL6_SPEC >) -> Self { W (writer) } } # [doc = "Field `XT1AUTOOFF` reader - XT1 automatic off enable"]
pub type XT1AUTOOFF_R = crate :: BitReader < bool > ; # [doc = "Field `XT1AUTOOFF` writer - XT1 automatic off enable"]
pub type XT1AUTOOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL6_SPEC , bool , O > ; # [doc = "Field `XT1AGCOFF` reader - XT1 Automatic Gain Control (AGC) disable"]
pub type XT1AGCOFF_R = crate :: BitReader < bool > ; # [doc = "Field `XT1AGCOFF` writer - XT1 Automatic Gain Control (AGC) disable"]
pub type XT1AGCOFF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL6_SPEC , bool , O > ; # [doc = "Field `XT1BYPASS` reader - XT1 bypass mode : 0: internal 1:sourced from external pin"]
pub type XT1BYPASS_R = crate :: BitReader < bool > ; # [doc = "Field `XT1BYPASS` writer - XT1 bypass mode : 0: internal 1:sourced from external pin"]
pub type XT1BYPASS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL6_SPEC , bool , O > ; # [doc = "Field `XTS` reader - 1: Selects high-freq. oscillator"]
pub type XTS_R = crate :: BitReader < bool > ; # [doc = "Field `XTS` writer - 1: Selects high-freq. oscillator"]
pub type XTS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL6_SPEC , bool , O > ; # [doc = "XT1 Drive Level mode Bit 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum XT1DRIVE_A { # [doc = "0: XT1 Drive Level mode: 0"]
XT1DRIVE_0 = 0 , # [doc = "1: XT1 Drive Level mode: 1"]
XT1DRIVE_1 = 1 , # [doc = "2: XT1 Drive Level mode: 2"]
XT1DRIVE_2 = 2 , # [doc = "3: XT1 Drive Level mode: 3"]
XT1DRIVE_3 = 3 , } impl From < XT1DRIVE_A > for u8 { # [inline (always)]
fn from (variant : XT1DRIVE_A) -> Self { variant as _ } } # [doc = "Field `XT1DRIVE` reader - XT1 Drive Level mode Bit 0"]
pub type XT1DRIVE_R = crate :: FieldReader < u8 , XT1DRIVE_A > ; impl XT1DRIVE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> XT1DRIVE_A { match self . bits { 0 => XT1DRIVE_A :: XT1DRIVE_0 , 1 => XT1DRIVE_A :: XT1DRIVE_1 , 2 => XT1DRIVE_A :: XT1DRIVE_2 , 3 => XT1DRIVE_A :: XT1DRIVE_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `XT1DRIVE_0`"]
# [inline (always)]
pub fn is_xt1drive_0 (& self) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_0 } # [doc = "Checks if the value of the field is `XT1DRIVE_1`"]
# [inline (always)]
pub fn is_xt1drive_1 (& self) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_1 } # [doc = "Checks if the value of the field is `XT1DRIVE_2`"]
# [inline (always)]
pub fn is_xt1drive_2 (& self) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_2 } # [doc = "Checks if the value of the field is `XT1DRIVE_3`"]
# [inline (always)]
pub fn is_xt1drive_3 (& self) -> bool { * self == XT1DRIVE_A :: XT1DRIVE_3 } } # [doc = "Field `XT1DRIVE` writer - XT1 Drive Level mode Bit 0"]
pub type XT1DRIVE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL6_SPEC , u8 , XT1DRIVE_A , 2 , O > ; impl < 'a , const O : u8 > XT1DRIVE_W < 'a , O > { # [doc = "XT1 Drive Level mode: 0"]
# [inline (always)]
pub fn xt1drive_0 (self) -> & 'a mut W { self . variant (XT1DRIVE_A :: XT1DRIVE_0) } # [doc = "XT1 Drive Level mode: 1"]
# [inline (always)]
pub fn xt1drive_1 (self) -> & 'a mut W { self . variant (XT1DRIVE_A :: XT1DRIVE_1) } # [doc = "XT1 Drive Level mode: 2"]
# [inline (always)]
pub fn xt1drive_2 (self) -> & 'a mut W { self . variant (XT1DRIVE_A :: XT1DRIVE_2) } # [doc = "XT1 Drive Level mode: 3"]
# [inline (always)]
pub fn xt1drive_3 (self) -> & 'a mut W { self . variant (XT1DRIVE_A :: XT1DRIVE_3) } } impl R { # [doc = "Bit 0 - XT1 automatic off enable"]
# [inline (always)]
pub fn xt1autooff (& self) -> XT1AUTOOFF_R { XT1AUTOOFF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XT1 Automatic Gain Control (AGC) disable"]
# [inline (always)]
pub fn xt1agcoff (& self) -> XT1AGCOFF_R { XT1AGCOFF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - XT1 bypass mode : 0: internal 1:sourced from external pin"]
# [inline (always)]
pub fn xt1bypass (& self) -> XT1BYPASS_R { XT1BYPASS_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - 1: Selects high-freq. oscillator"]
# [inline (always)]
pub fn xts (& self) -> XTS_R { XTS_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - XT1 Drive Level mode Bit 0"]
# [inline (always)]
pub fn xt1drive (& self) -> XT1DRIVE_R { XT1DRIVE_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - XT1 automatic off enable"]
# [inline (always)]
pub fn xt1autooff (& mut self) -> XT1AUTOOFF_W < 0 > { XT1AUTOOFF_W :: new (self) } # [doc = "Bit 1 - XT1 Automatic Gain Control (AGC) disable"]
# [inline (always)]
pub fn xt1agcoff (& mut self) -> XT1AGCOFF_W < 1 > { XT1AGCOFF_W :: new (self) } # [doc = "Bit 4 - XT1 bypass mode : 0: internal 1:sourced from external pin"]
# [inline (always)]
pub fn xt1bypass (& mut self) -> XT1BYPASS_W < 4 > { XT1BYPASS_W :: new (self) } # [doc = "Bit 5 - 1: Selects high-freq. oscillator"]
# [inline (always)]
pub fn xts (& mut self) -> XTS_W < 5 > { XTS_W :: new (self) } # [doc = "Bits 6:7 - XT1 Drive Level mode Bit 0"]
# [inline (always)]
pub fn xt1drive (& mut self) -> XT1DRIVE_W < 6 > { XT1DRIVE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl6](index.html) module"]
pub struct CSCTL6_SPEC ; impl crate :: RegisterSpec for CSCTL6_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl6::R](R) reader structure"]
impl crate :: Readable for CSCTL6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl6::W](W) writer structure"]
impl crate :: Writable for CSCTL6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL6 to value 0"]
impl crate :: Resettable for CSCTL6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL7 register accessor: an alias for `Reg<CSCTL7_SPEC>`"]
pub type CSCTL7 = crate :: Reg < csctl7 :: CSCTL7_SPEC > ; # [doc = "CS Control Register 7"]
pub mod csctl7 { # [doc = "Register `CSCTL7` reader"]
pub struct R (crate :: R < CSCTL7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL7_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL7` writer"]
pub struct W (crate :: W < CSCTL7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL7_SPEC >) -> Self { W (writer) } } # [doc = "Field `DCOFFG` reader - DCO fault flag"]
pub type DCOFFG_R = crate :: BitReader < bool > ; # [doc = "Field `DCOFFG` writer - DCO fault flag"]
pub type DCOFFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; # [doc = "Field `XT1OFFG` reader - XT1 Low Frequency Oscillator Fault Flag"]
pub type XT1OFFG_R = crate :: BitReader < bool > ; # [doc = "Field `XT1OFFG` writer - XT1 Low Frequency Oscillator Fault Flag"]
pub type XT1OFFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; # [doc = "Field `FLLULIFG` reader - FLL unlock interrupt flag"]
pub type FLLULIFG_R = crate :: BitReader < bool > ; # [doc = "Field `FLLULIFG` writer - FLL unlock interrupt flag"]
pub type FLLULIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; # [doc = "Field `ENSTFCNT1` reader - Enable start counter for XT1"]
pub type ENSTFCNT1_R = crate :: BitReader < bool > ; # [doc = "Field `ENSTFCNT1` writer - Enable start counter for XT1"]
pub type ENSTFCNT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; # [doc = "FLL unlock condition Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLLUNLOCK_A { # [doc = "0: FLL unlock condition: 0"]
FLLUNLOCK_0 = 0 , # [doc = "1: FLL unlock condition: 1"]
FLLUNLOCK_1 = 1 , # [doc = "2: FLL unlock condition: 2"]
FLLUNLOCK_2 = 2 , # [doc = "3: FLL unlock condition: 3"]
FLLUNLOCK_3 = 3 , } impl From < FLLUNLOCK_A > for u8 { # [inline (always)]
fn from (variant : FLLUNLOCK_A) -> Self { variant as _ } } # [doc = "Field `FLLUNLOCK` reader - FLL unlock condition Bit: 0"]
pub type FLLUNLOCK_R = crate :: FieldReader < u8 , FLLUNLOCK_A > ; impl FLLUNLOCK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FLLUNLOCK_A { match self . bits { 0 => FLLUNLOCK_A :: FLLUNLOCK_0 , 1 => FLLUNLOCK_A :: FLLUNLOCK_1 , 2 => FLLUNLOCK_A :: FLLUNLOCK_2 , 3 => FLLUNLOCK_A :: FLLUNLOCK_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLLUNLOCK_0`"]
# [inline (always)]
pub fn is_fllunlock_0 (& self) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_0 } # [doc = "Checks if the value of the field is `FLLUNLOCK_1`"]
# [inline (always)]
pub fn is_fllunlock_1 (& self) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_1 } # [doc = "Checks if the value of the field is `FLLUNLOCK_2`"]
# [inline (always)]
pub fn is_fllunlock_2 (& self) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_2 } # [doc = "Checks if the value of the field is `FLLUNLOCK_3`"]
# [inline (always)]
pub fn is_fllunlock_3 (& self) -> bool { * self == FLLUNLOCK_A :: FLLUNLOCK_3 } } # [doc = "Field `FLLUNLOCK` writer - FLL unlock condition Bit: 0"]
pub type FLLUNLOCK_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL7_SPEC , u8 , FLLUNLOCK_A , 2 , O > ; impl < 'a , const O : u8 > FLLUNLOCK_W < 'a , O > { # [doc = "FLL unlock condition: 0"]
# [inline (always)]
pub fn fllunlock_0 (self) -> & 'a mut W { self . variant (FLLUNLOCK_A :: FLLUNLOCK_0) } # [doc = "FLL unlock condition: 1"]
# [inline (always)]
pub fn fllunlock_1 (self) -> & 'a mut W { self . variant (FLLUNLOCK_A :: FLLUNLOCK_1) } # [doc = "FLL unlock condition: 2"]
# [inline (always)]
pub fn fllunlock_2 (self) -> & 'a mut W { self . variant (FLLUNLOCK_A :: FLLUNLOCK_2) } # [doc = "FLL unlock condition: 3"]
# [inline (always)]
pub fn fllunlock_3 (self) -> & 'a mut W { self . variant (FLLUNLOCK_A :: FLLUNLOCK_3) } } # [doc = "Unlock history Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLLUNLOCKHIS_A { # [doc = "0: Unlock history: 0"]
FLLUNLOCKHIS_0 = 0 , # [doc = "1: Unlock history: 1"]
FLLUNLOCKHIS_1 = 1 , # [doc = "2: Unlock history: 2"]
FLLUNLOCKHIS_2 = 2 , # [doc = "3: Unlock history: 3"]
FLLUNLOCKHIS_3 = 3 , } impl From < FLLUNLOCKHIS_A > for u8 { # [inline (always)]
fn from (variant : FLLUNLOCKHIS_A) -> Self { variant as _ } } # [doc = "Field `FLLUNLOCKHIS` reader - Unlock history Bit: 0"]
pub type FLLUNLOCKHIS_R = crate :: FieldReader < u8 , FLLUNLOCKHIS_A > ; impl FLLUNLOCKHIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FLLUNLOCKHIS_A { match self . bits { 0 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0 , 1 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1 , 2 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2 , 3 => FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLLUNLOCKHIS_0`"]
# [inline (always)]
pub fn is_fllunlockhis_0 (& self) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0 } # [doc = "Checks if the value of the field is `FLLUNLOCKHIS_1`"]
# [inline (always)]
pub fn is_fllunlockhis_1 (& self) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1 } # [doc = "Checks if the value of the field is `FLLUNLOCKHIS_2`"]
# [inline (always)]
pub fn is_fllunlockhis_2 (& self) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2 } # [doc = "Checks if the value of the field is `FLLUNLOCKHIS_3`"]
# [inline (always)]
pub fn is_fllunlockhis_3 (& self) -> bool { * self == FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3 } } # [doc = "Field `FLLUNLOCKHIS` writer - Unlock history Bit: 0"]
pub type FLLUNLOCKHIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CSCTL7_SPEC , u8 , FLLUNLOCKHIS_A , 2 , O > ; impl < 'a , const O : u8 > FLLUNLOCKHIS_W < 'a , O > { # [doc = "Unlock history: 0"]
# [inline (always)]
pub fn fllunlockhis_0 (self) -> & 'a mut W { self . variant (FLLUNLOCKHIS_A :: FLLUNLOCKHIS_0) } # [doc = "Unlock history: 1"]
# [inline (always)]
pub fn fllunlockhis_1 (self) -> & 'a mut W { self . variant (FLLUNLOCKHIS_A :: FLLUNLOCKHIS_1) } # [doc = "Unlock history: 2"]
# [inline (always)]
pub fn fllunlockhis_2 (self) -> & 'a mut W { self . variant (FLLUNLOCKHIS_A :: FLLUNLOCKHIS_2) } # [doc = "Unlock history: 3"]
# [inline (always)]
pub fn fllunlockhis_3 (self) -> & 'a mut W { self . variant (FLLUNLOCKHIS_A :: FLLUNLOCKHIS_3) } } # [doc = "Field `FLLULPUC` reader - FLL unlock PUC enable"]
pub type FLLULPUC_R = crate :: BitReader < bool > ; # [doc = "Field `FLLULPUC` writer - FLL unlock PUC enable"]
pub type FLLULPUC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; # [doc = "Field `FLLWARNEN` reader - Warning enable"]
pub type FLLWARNEN_R = crate :: BitReader < bool > ; # [doc = "Field `FLLWARNEN` writer - Warning enable"]
pub type FLLWARNEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL7_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DCO fault flag"]
# [inline (always)]
pub fn dcoffg (& self) -> DCOFFG_R { DCOFFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XT1 Low Frequency Oscillator Fault Flag"]
# [inline (always)]
pub fn xt1offg (& self) -> XT1OFFG_R { XT1OFFG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - FLL unlock interrupt flag"]
# [inline (always)]
pub fn fllulifg (& self) -> FLLULIFG_R { FLLULIFG_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Enable start counter for XT1"]
# [inline (always)]
pub fn enstfcnt1 (& self) -> ENSTFCNT1_R { ENSTFCNT1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bits 8:9 - FLL unlock condition Bit: 0"]
# [inline (always)]
pub fn fllunlock (& self) -> FLLUNLOCK_R { FLLUNLOCK_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Unlock history Bit: 0"]
# [inline (always)]
pub fn fllunlockhis (& self) -> FLLUNLOCKHIS_R { FLLUNLOCKHIS_R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bit 12 - FLL unlock PUC enable"]
# [inline (always)]
pub fn fllulpuc (& self) -> FLLULPUC_R { FLLULPUC_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Warning enable"]
# [inline (always)]
pub fn fllwarnen (& self) -> FLLWARNEN_R { FLLWARNEN_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - DCO fault flag"]
# [inline (always)]
pub fn dcoffg (& mut self) -> DCOFFG_W < 0 > { DCOFFG_W :: new (self) } # [doc = "Bit 1 - XT1 Low Frequency Oscillator Fault Flag"]
# [inline (always)]
pub fn xt1offg (& mut self) -> XT1OFFG_W < 1 > { XT1OFFG_W :: new (self) } # [doc = "Bit 4 - FLL unlock interrupt flag"]
# [inline (always)]
pub fn fllulifg (& mut self) -> FLLULIFG_W < 4 > { FLLULIFG_W :: new (self) } # [doc = "Bit 6 - Enable start counter for XT1"]
# [inline (always)]
pub fn enstfcnt1 (& mut self) -> ENSTFCNT1_W < 6 > { ENSTFCNT1_W :: new (self) } # [doc = "Bits 8:9 - FLL unlock condition Bit: 0"]
# [inline (always)]
pub fn fllunlock (& mut self) -> FLLUNLOCK_W < 8 > { FLLUNLOCK_W :: new (self) } # [doc = "Bits 10:11 - Unlock history Bit: 0"]
# [inline (always)]
pub fn fllunlockhis (& mut self) -> FLLUNLOCKHIS_W < 10 > { FLLUNLOCKHIS_W :: new (self) } # [doc = "Bit 12 - FLL unlock PUC enable"]
# [inline (always)]
pub fn fllulpuc (& mut self) -> FLLULPUC_W < 12 > { FLLULPUC_W :: new (self) } # [doc = "Bit 13 - Warning enable"]
# [inline (always)]
pub fn fllwarnen (& mut self) -> FLLWARNEN_W < 13 > { FLLWARNEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl7](index.html) module"]
pub struct CSCTL7_SPEC ; impl crate :: RegisterSpec for CSCTL7_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl7::R](R) reader structure"]
impl crate :: Readable for CSCTL7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl7::W](W) writer structure"]
impl crate :: Writable for CSCTL7_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL7 to value 0"]
impl crate :: Resettable for CSCTL7_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CSCTL8 register accessor: an alias for `Reg<CSCTL8_SPEC>`"]
pub type CSCTL8 = crate :: Reg < csctl8 :: CSCTL8_SPEC > ; # [doc = "CS Control Register 8"]
pub mod csctl8 { # [doc = "Register `CSCTL8` reader"]
pub struct R (crate :: R < CSCTL8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSCTL8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSCTL8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSCTL8_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSCTL8` writer"]
pub struct W (crate :: W < CSCTL8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSCTL8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSCTL8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSCTL8_SPEC >) -> Self { W (writer) } } # [doc = "Field `ACLKREQEN` reader - ACLK Clock Request Enable"]
pub type ACLKREQEN_R = crate :: BitReader < bool > ; # [doc = "Field `ACLKREQEN` writer - ACLK Clock Request Enable"]
pub type ACLKREQEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL8_SPEC , bool , O > ; # [doc = "Field `MCLKREQEN` reader - MCLK Clock Request Enable"]
pub type MCLKREQEN_R = crate :: BitReader < bool > ; # [doc = "Field `MCLKREQEN` writer - MCLK Clock Request Enable"]
pub type MCLKREQEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL8_SPEC , bool , O > ; # [doc = "Field `SMCLKREQEN` reader - SMCLK Clock Request Enable"]
pub type SMCLKREQEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMCLKREQEN` writer - SMCLK Clock Request Enable"]
pub type SMCLKREQEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL8_SPEC , bool , O > ; # [doc = "Field `MODOSCREQEN` reader - MODOSC Clock Request Enable"]
pub type MODOSCREQEN_R = crate :: BitReader < bool > ; # [doc = "Field `MODOSCREQEN` writer - MODOSC Clock Request Enable"]
pub type MODOSCREQEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , CSCTL8_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ACLK Clock Request Enable"]
# [inline (always)]
pub fn aclkreqen (& self) -> ACLKREQEN_R { ACLKREQEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - MCLK Clock Request Enable"]
# [inline (always)]
pub fn mclkreqen (& self) -> MCLKREQEN_R { MCLKREQEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SMCLK Clock Request Enable"]
# [inline (always)]
pub fn smclkreqen (& self) -> SMCLKREQEN_R { SMCLKREQEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - MODOSC Clock Request Enable"]
# [inline (always)]
pub fn modoscreqen (& self) -> MODOSCREQEN_R { MODOSCREQEN_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - ACLK Clock Request Enable"]
# [inline (always)]
pub fn aclkreqen (& mut self) -> ACLKREQEN_W < 0 > { ACLKREQEN_W :: new (self) } # [doc = "Bit 1 - MCLK Clock Request Enable"]
# [inline (always)]
pub fn mclkreqen (& mut self) -> MCLKREQEN_W < 1 > { MCLKREQEN_W :: new (self) } # [doc = "Bit 2 - SMCLK Clock Request Enable"]
# [inline (always)]
pub fn smclkreqen (& mut self) -> SMCLKREQEN_W < 2 > { SMCLKREQEN_W :: new (self) } # [doc = "Bit 3 - MODOSC Clock Request Enable"]
# [inline (always)]
pub fn modoscreqen (& mut self) -> MODOSCREQEN_W < 3 > { MODOSCREQEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CS Control Register 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csctl8](index.html) module"]
pub struct CSCTL8_SPEC ; impl crate :: RegisterSpec for CSCTL8_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [csctl8::R](R) reader structure"]
impl crate :: Readable for CSCTL8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csctl8::W](W) writer structure"]
impl crate :: Writable for CSCTL8_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CSCTL8 to value 0"]
impl crate :: Resettable for CSCTL8_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "FRAM"]
pub struct FRAM { _marker : PhantomData < * const () > } unsafe impl Send for FRAM { } impl FRAM { # [doc = r"Pointer to the register block"]
pub const PTR : * const fram :: RegisterBlock = 0x01a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fram :: RegisterBlock { Self :: PTR } } impl Deref for FRAM { type Target = fram :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FRAM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FRAM") . finish () } } # [doc = "FRAM"]
pub mod fram { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - FRAM Controller Control 0"]
pub frctl0 : crate :: Reg < frctl0 :: FRCTL0_SPEC > , _reserved1 : [u8 ; 0x02]
, # [doc = "0x04 - General Control 0"]
pub gcctl0 : crate :: Reg < gcctl0 :: GCCTL0_SPEC > , # [doc = "0x06 - General Control 1"]
pub gcctl1 : crate :: Reg < gcctl1 :: GCCTL1_SPEC > , } # [doc = "FRCTL0 register accessor: an alias for `Reg<FRCTL0_SPEC>`"]
pub type FRCTL0 = crate :: Reg < frctl0 :: FRCTL0_SPEC > ; # [doc = "FRAM Controller Control 0"]
pub mod frctl0 { # [doc = "Register `FRCTL0` reader"]
pub struct R (crate :: R < FRCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FRCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FRCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FRCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `FRCTL0` writer"]
pub struct W (crate :: W < FRCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FRCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FRCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FRCTL0_SPEC >) -> Self { W (writer) } } # [doc = "FRAM Wait state control Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum NWAITS_A { # [doc = "0: FRAM Wait state control: 0"]
NWAITS_0 = 0 , # [doc = "1: FRAM Wait state control: 1"]
NWAITS_1 = 1 , # [doc = "2: FRAM Wait state control: 2"]
NWAITS_2 = 2 , # [doc = "3: FRAM Wait state control: 3"]
NWAITS_3 = 3 , # [doc = "4: FRAM Wait state control: 4"]
NWAITS_4 = 4 , # [doc = "5: FRAM Wait state control: 5"]
NWAITS_5 = 5 , # [doc = "6: FRAM Wait state control: 6"]
NWAITS_6 = 6 , # [doc = "7: FRAM Wait state control: 7"]
NWAITS_7 = 7 , } impl From < NWAITS_A > for u8 { # [inline (always)]
fn from (variant : NWAITS_A) -> Self { variant as _ } } # [doc = "Field `NWAITS` reader - FRAM Wait state control Bit: 0"]
pub type NWAITS_R = crate :: FieldReader < u8 , NWAITS_A > ; impl NWAITS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NWAITS_A { match self . bits { 0 => NWAITS_A :: NWAITS_0 , 1 => NWAITS_A :: NWAITS_1 , 2 => NWAITS_A :: NWAITS_2 , 3 => NWAITS_A :: NWAITS_3 , 4 => NWAITS_A :: NWAITS_4 , 5 => NWAITS_A :: NWAITS_5 , 6 => NWAITS_A :: NWAITS_6 , 7 => NWAITS_A :: NWAITS_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NWAITS_0`"]
# [inline (always)]
pub fn is_nwaits_0 (& self) -> bool { * self == NWAITS_A :: NWAITS_0 } # [doc = "Checks if the value of the field is `NWAITS_1`"]
# [inline (always)]
pub fn is_nwaits_1 (& self) -> bool { * self == NWAITS_A :: NWAITS_1 } # [doc = "Checks if the value of the field is `NWAITS_2`"]
# [inline (always)]
pub fn is_nwaits_2 (& self) -> bool { * self == NWAITS_A :: NWAITS_2 } # [doc = "Checks if the value of the field is `NWAITS_3`"]
# [inline (always)]
pub fn is_nwaits_3 (& self) -> bool { * self == NWAITS_A :: NWAITS_3 } # [doc = "Checks if the value of the field is `NWAITS_4`"]
# [inline (always)]
pub fn is_nwaits_4 (& self) -> bool { * self == NWAITS_A :: NWAITS_4 } # [doc = "Checks if the value of the field is `NWAITS_5`"]
# [inline (always)]
pub fn is_nwaits_5 (& self) -> bool { * self == NWAITS_A :: NWAITS_5 } # [doc = "Checks if the value of the field is `NWAITS_6`"]
# [inline (always)]
pub fn is_nwaits_6 (& self) -> bool { * self == NWAITS_A :: NWAITS_6 } # [doc = "Checks if the value of the field is `NWAITS_7`"]
# [inline (always)]
pub fn is_nwaits_7 (& self) -> bool { * self == NWAITS_A :: NWAITS_7 } } # [doc = "Field `NWAITS` writer - FRAM Wait state control Bit: 0"]
pub type NWAITS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , FRCTL0_SPEC , u8 , NWAITS_A , 3 , O > ; impl < 'a , const O : u8 > NWAITS_W < 'a , O > { # [doc = "FRAM Wait state control: 0"]
# [inline (always)]
pub fn nwaits_0 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_0) } # [doc = "FRAM Wait state control: 1"]
# [inline (always)]
pub fn nwaits_1 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_1) } # [doc = "FRAM Wait state control: 2"]
# [inline (always)]
pub fn nwaits_2 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_2) } # [doc = "FRAM Wait state control: 3"]
# [inline (always)]
pub fn nwaits_3 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_3) } # [doc = "FRAM Wait state control: 4"]
# [inline (always)]
pub fn nwaits_4 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_4) } # [doc = "FRAM Wait state control: 5"]
# [inline (always)]
pub fn nwaits_5 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_5) } # [doc = "FRAM Wait state control: 6"]
# [inline (always)]
pub fn nwaits_6 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_6) } # [doc = "FRAM Wait state control: 7"]
# [inline (always)]
pub fn nwaits_7 (self) -> & 'a mut W { self . variant (NWAITS_A :: NWAITS_7) } } impl R { # [doc = "Bits 4:6 - FRAM Wait state control Bit: 0"]
# [inline (always)]
pub fn nwaits (& self) -> NWAITS_R { NWAITS_R :: new (((self . bits >> 4) & 7) as u8) } } impl W { # [doc = "Bits 4:6 - FRAM Wait state control Bit: 0"]
# [inline (always)]
pub fn nwaits (& mut self) -> NWAITS_W < 4 > { NWAITS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "FRAM Controller Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [frctl0](index.html) module"]
pub struct FRCTL0_SPEC ; impl crate :: RegisterSpec for FRCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [frctl0::R](R) reader structure"]
impl crate :: Readable for FRCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [frctl0::W](W) writer structure"]
impl crate :: Writable for FRCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FRCTL0 to value 0"]
impl crate :: Resettable for FRCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "GCCTL0 register accessor: an alias for `Reg<GCCTL0_SPEC>`"]
pub type GCCTL0 = crate :: Reg < gcctl0 :: GCCTL0_SPEC > ; # [doc = "General Control 0"]
pub mod gcctl0 { # [doc = "Register `GCCTL0` reader"]
pub struct R (crate :: R < GCCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GCCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GCCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GCCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GCCTL0` writer"]
pub struct W (crate :: W < GCCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GCCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GCCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GCCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `FRLPMPWR` reader - FRAM Enable FRAM auto power up after LPM"]
pub type FRLPMPWR_R = crate :: BitReader < bool > ; # [doc = "Field `FRLPMPWR` writer - FRAM Enable FRAM auto power up after LPM"]
pub type FRLPMPWR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; # [doc = "Field `FRPWR` reader - FRAM Power Control"]
pub type FRPWR_R = crate :: BitReader < bool > ; # [doc = "Field `FRPWR` writer - FRAM Power Control"]
pub type FRPWR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; # [doc = "Field `ACCTEIE` reader - RESERVED"]
pub type ACCTEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ACCTEIE` writer - RESERVED"]
pub type ACCTEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; # [doc = "Field `CBDIE` reader - Enable NMI event if correctable bit error detected"]
pub type CBDIE_R = crate :: BitReader < bool > ; # [doc = "Field `CBDIE` writer - Enable NMI event if correctable bit error detected"]
pub type CBDIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; # [doc = "Field `UBDIE` reader - Enable NMI event if uncorrectable bit error detected"]
pub type UBDIE_R = crate :: BitReader < bool > ; # [doc = "Field `UBDIE` writer - Enable NMI event if uncorrectable bit error detected"]
pub type UBDIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; # [doc = "Field `UBDRSTEN` reader - Enable Power Up Clear (PUC) reset if FRAM uncorrectable bit error detected"]
pub type UBDRSTEN_R = crate :: BitReader < bool > ; # [doc = "Field `UBDRSTEN` writer - Enable Power Up Clear (PUC) reset if FRAM uncorrectable bit error detected"]
pub type UBDRSTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL0_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - FRAM Enable FRAM auto power up after LPM"]
# [inline (always)]
pub fn frlpmpwr (& self) -> FRLPMPWR_R { FRLPMPWR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - FRAM Power Control"]
# [inline (always)]
pub fn frpwr (& self) -> FRPWR_R { FRPWR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - RESERVED"]
# [inline (always)]
pub fn accteie (& self) -> ACCTEIE_R { ACCTEIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Enable NMI event if correctable bit error detected"]
# [inline (always)]
pub fn cbdie (& self) -> CBDIE_R { CBDIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable NMI event if uncorrectable bit error detected"]
# [inline (always)]
pub fn ubdie (& self) -> UBDIE_R { UBDIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Power Up Clear (PUC) reset if FRAM uncorrectable bit error detected"]
# [inline (always)]
pub fn ubdrsten (& self) -> UBDRSTEN_R { UBDRSTEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - FRAM Enable FRAM auto power up after LPM"]
# [inline (always)]
pub fn frlpmpwr (& mut self) -> FRLPMPWR_W < 1 > { FRLPMPWR_W :: new (self) } # [doc = "Bit 2 - FRAM Power Control"]
# [inline (always)]
pub fn frpwr (& mut self) -> FRPWR_W < 2 > { FRPWR_W :: new (self) } # [doc = "Bit 3 - RESERVED"]
# [inline (always)]
pub fn accteie (& mut self) -> ACCTEIE_W < 3 > { ACCTEIE_W :: new (self) } # [doc = "Bit 5 - Enable NMI event if correctable bit error detected"]
# [inline (always)]
pub fn cbdie (& mut self) -> CBDIE_W < 5 > { CBDIE_W :: new (self) } # [doc = "Bit 6 - Enable NMI event if uncorrectable bit error detected"]
# [inline (always)]
pub fn ubdie (& mut self) -> UBDIE_W < 6 > { UBDIE_W :: new (self) } # [doc = "Bit 7 - Enable Power Up Clear (PUC) reset if FRAM uncorrectable bit error detected"]
# [inline (always)]
pub fn ubdrsten (& mut self) -> UBDRSTEN_W < 7 > { UBDRSTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcctl0](index.html) module"]
pub struct GCCTL0_SPEC ; impl crate :: RegisterSpec for GCCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [gcctl0::R](R) reader structure"]
impl crate :: Readable for GCCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gcctl0::W](W) writer structure"]
impl crate :: Writable for GCCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets GCCTL0 to value 0"]
impl crate :: Resettable for GCCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "GCCTL1 register accessor: an alias for `Reg<GCCTL1_SPEC>`"]
pub type GCCTL1 = crate :: Reg < gcctl1 :: GCCTL1_SPEC > ; # [doc = "General Control 1"]
pub mod gcctl1 { # [doc = "Register `GCCTL1` reader"]
pub struct R (crate :: R < GCCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GCCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GCCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GCCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GCCTL1` writer"]
pub struct W (crate :: W < GCCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GCCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GCCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GCCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CBDIFG` reader - FRAM correctable bit error flag"]
pub type CBDIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CBDIFG` writer - FRAM correctable bit error flag"]
pub type CBDIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL1_SPEC , bool , O > ; # [doc = "Field `UBDIFG` reader - FRAM uncorrectable bit error flag"]
pub type UBDIFG_R = crate :: BitReader < bool > ; # [doc = "Field `UBDIFG` writer - FRAM uncorrectable bit error flag"]
pub type UBDIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL1_SPEC , bool , O > ; # [doc = "Field `ACCTEIFG` reader - Access time error flag"]
pub type ACCTEIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ACCTEIFG` writer - Access time error flag"]
pub type ACCTEIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , GCCTL1_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - FRAM correctable bit error flag"]
# [inline (always)]
pub fn cbdifg (& self) -> CBDIFG_R { CBDIFG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - FRAM uncorrectable bit error flag"]
# [inline (always)]
pub fn ubdifg (& self) -> UBDIFG_R { UBDIFG_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Access time error flag"]
# [inline (always)]
pub fn accteifg (& self) -> ACCTEIFG_R { ACCTEIFG_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 1 - FRAM correctable bit error flag"]
# [inline (always)]
pub fn cbdifg (& mut self) -> CBDIFG_W < 1 > { CBDIFG_W :: new (self) } # [doc = "Bit 2 - FRAM uncorrectable bit error flag"]
# [inline (always)]
pub fn ubdifg (& mut self) -> UBDIFG_W < 2 > { UBDIFG_W :: new (self) } # [doc = "Bit 3 - Access time error flag"]
# [inline (always)]
pub fn accteifg (& mut self) -> ACCTEIFG_W < 3 > { ACCTEIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcctl1](index.html) module"]
pub struct GCCTL1_SPEC ; impl crate :: RegisterSpec for GCCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [gcctl1::R](R) reader structure"]
impl crate :: Readable for GCCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gcctl1::W](W) writer structure"]
impl crate :: Writable for GCCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets GCCTL1 to value 0"]
impl crate :: Resettable for GCCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "CRC16"]
pub struct CRC16 { _marker : PhantomData < * const () > } unsafe impl Send for CRC16 { } impl CRC16 { # [doc = r"Pointer to the register block"]
pub const PTR : * const crc16 :: RegisterBlock = 0x01c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const crc16 :: RegisterBlock { Self :: PTR } } impl Deref for CRC16 { type Target = crc16 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CRC16 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CRC16") . finish () } } # [doc = "CRC16"]
pub mod crc16 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - CRC Data In Register"]
pub crcdi : crate :: Reg < crcdi :: CRCDI_SPEC > , # [doc = "0x02 - CRC data in reverse byte Register"]
pub crcdirb : crate :: Reg < crcdirb :: CRCDIRB_SPEC > , # [doc = "0x04 - CRC Initialisation Register and Result Register"]
pub crcinires : crate :: Reg < crcinires :: CRCINIRES_SPEC > , # [doc = "0x06 - CRC reverse result Register"]
pub crcresr : crate :: Reg < crcresr :: CRCRESR_SPEC > , } # [doc = "CRCDI register accessor: an alias for `Reg<CRCDI_SPEC>`"]
pub type CRCDI = crate :: Reg < crcdi :: CRCDI_SPEC > ; # [doc = "CRC Data In Register"]
pub mod crcdi { # [doc = "Register `CRCDI` reader"]
pub struct R (crate :: R < CRCDI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCDI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCDI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCDI_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCDI` writer"]
pub struct W (crate :: W < CRCDI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCDI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCDI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCDI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Data In Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcdi](index.html) module"]
pub struct CRCDI_SPEC ; impl crate :: RegisterSpec for CRCDI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [crcdi::R](R) reader structure"]
impl crate :: Readable for CRCDI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcdi::W](W) writer structure"]
impl crate :: Writable for CRCDI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCDI to value 0"]
impl crate :: Resettable for CRCDI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCDIRB register accessor: an alias for `Reg<CRCDIRB_SPEC>`"]
pub type CRCDIRB = crate :: Reg < crcdirb :: CRCDIRB_SPEC > ; # [doc = "CRC data in reverse byte Register"]
pub mod crcdirb { # [doc = "Register `CRCDIRB` reader"]
pub struct R (crate :: R < CRCDIRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCDIRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCDIRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCDIRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCDIRB` writer"]
pub struct W (crate :: W < CRCDIRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCDIRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCDIRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCDIRB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC data in reverse byte Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcdirb](index.html) module"]
pub struct CRCDIRB_SPEC ; impl crate :: RegisterSpec for CRCDIRB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [crcdirb::R](R) reader structure"]
impl crate :: Readable for CRCDIRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcdirb::W](W) writer structure"]
impl crate :: Writable for CRCDIRB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCDIRB to value 0"]
impl crate :: Resettable for CRCDIRB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCINIRES register accessor: an alias for `Reg<CRCINIRES_SPEC>`"]
pub type CRCINIRES = crate :: Reg < crcinires :: CRCINIRES_SPEC > ; # [doc = "CRC Initialisation Register and Result Register"]
pub mod crcinires { # [doc = "Register `CRCINIRES` reader"]
pub struct R (crate :: R < CRCINIRES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCINIRES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCINIRES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCINIRES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCINIRES` writer"]
pub struct W (crate :: W < CRCINIRES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCINIRES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCINIRES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCINIRES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Initialisation Register and Result Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcinires](index.html) module"]
pub struct CRCINIRES_SPEC ; impl crate :: RegisterSpec for CRCINIRES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [crcinires::R](R) reader structure"]
impl crate :: Readable for CRCINIRES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcinires::W](W) writer structure"]
impl crate :: Writable for CRCINIRES_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCINIRES to value 0"]
impl crate :: Resettable for CRCINIRES_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCRESR register accessor: an alias for `Reg<CRCRESR_SPEC>`"]
pub type CRCRESR = crate :: Reg < crcresr :: CRCRESR_SPEC > ; # [doc = "CRC reverse result Register"]
pub mod crcresr { # [doc = "Register `CRCRESR` reader"]
pub struct R (crate :: R < CRCRESR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCRESR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCRESR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCRESR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCRESR` writer"]
pub struct W (crate :: W < CRCRESR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCRESR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCRESR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCRESR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC reverse result Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcresr](index.html) module"]
pub struct CRCRESR_SPEC ; impl crate :: RegisterSpec for CRCRESR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [crcresr::R](R) reader structure"]
impl crate :: Readable for CRCRESR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcresr::W](W) writer structure"]
impl crate :: Writable for CRCRESR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCRESR to value 0"]
impl crate :: Resettable for CRCRESR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Watchdog Timer"]
pub struct WATCHDOG_TIMER { _marker : PhantomData < * const () > } unsafe impl Send for WATCHDOG_TIMER { } impl WATCHDOG_TIMER { # [doc = r"Pointer to the register block"]
pub const PTR : * const watchdog_timer :: RegisterBlock = 0x01cc as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const watchdog_timer :: RegisterBlock { Self :: PTR } } impl Deref for WATCHDOG_TIMER { type Target = watchdog_timer :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WATCHDOG_TIMER { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WATCHDOG_TIMER") . finish () } } # [doc = "Watchdog Timer"]
pub mod watchdog_timer { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Watchdog Timer Control"]
pub wdtctl : crate :: Reg < wdtctl :: WDTCTL_SPEC > , } # [doc = "WDTCTL register accessor: an alias for `Reg<WDTCTL_SPEC>`"]
pub type WDTCTL = crate :: Reg < wdtctl :: WDTCTL_SPEC > ; # [doc = "Watchdog Timer Control"]
pub mod wdtctl { # [doc = "Register `WDTCTL` reader"]
pub struct R (crate :: R < WDTCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WDTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WDTCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WDTCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WDTCTL` writer"]
pub struct W (crate :: W < WDTCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WDTCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WDTCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WDTCTL_SPEC >) -> Self { W (writer) } } # [doc = "WDT - Timer Interval Select 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WDTIS_A { # [doc = "0: WDT - Timer Interval Select: /2G"]
WDTIS_0 = 0 , # [doc = "1: WDT - Timer Interval Select: /128M"]
WDTIS_1 = 1 , # [doc = "2: WDT - Timer Interval Select: /8192k"]
WDTIS_2 = 2 , # [doc = "3: WDT - Timer Interval Select: /512k"]
WDTIS_3 = 3 , # [doc = "4: WDT - Timer Interval Select: /32k"]
WDTIS_4 = 4 , # [doc = "5: WDT - Timer Interval Select: /8192"]
WDTIS_5 = 5 , # [doc = "6: WDT - Timer Interval Select: /512"]
WDTIS_6 = 6 , # [doc = "7: WDT - Timer Interval Select: /64"]
WDTIS_7 = 7 , } impl From < WDTIS_A > for u8 { # [inline (always)]
fn from (variant : WDTIS_A) -> Self { variant as _ } } # [doc = "Field `WDTIS` reader - WDT - Timer Interval Select 0"]
pub type WDTIS_R = crate :: FieldReader < u8 , WDTIS_A > ; impl WDTIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WDTIS_A { match self . bits { 0 => WDTIS_A :: WDTIS_0 , 1 => WDTIS_A :: WDTIS_1 , 2 => WDTIS_A :: WDTIS_2 , 3 => WDTIS_A :: WDTIS_3 , 4 => WDTIS_A :: WDTIS_4 , 5 => WDTIS_A :: WDTIS_5 , 6 => WDTIS_A :: WDTIS_6 , 7 => WDTIS_A :: WDTIS_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDTIS_0`"]
# [inline (always)]
pub fn is_wdtis_0 (& self) -> bool { * self == WDTIS_A :: WDTIS_0 } # [doc = "Checks if the value of the field is `WDTIS_1`"]
# [inline (always)]
pub fn is_wdtis_1 (& self) -> bool { * self == WDTIS_A :: WDTIS_1 } # [doc = "Checks if the value of the field is `WDTIS_2`"]
# [inline (always)]
pub fn is_wdtis_2 (& self) -> bool { * self == WDTIS_A :: WDTIS_2 } # [doc = "Checks if the value of the field is `WDTIS_3`"]
# [inline (always)]
pub fn is_wdtis_3 (& self) -> bool { * self == WDTIS_A :: WDTIS_3 } # [doc = "Checks if the value of the field is `WDTIS_4`"]
# [inline (always)]
pub fn is_wdtis_4 (& self) -> bool { * self == WDTIS_A :: WDTIS_4 } # [doc = "Checks if the value of the field is `WDTIS_5`"]
# [inline (always)]
pub fn is_wdtis_5 (& self) -> bool { * self == WDTIS_A :: WDTIS_5 } # [doc = "Checks if the value of the field is `WDTIS_6`"]
# [inline (always)]
pub fn is_wdtis_6 (& self) -> bool { * self == WDTIS_A :: WDTIS_6 } # [doc = "Checks if the value of the field is `WDTIS_7`"]
# [inline (always)]
pub fn is_wdtis_7 (& self) -> bool { * self == WDTIS_A :: WDTIS_7 } } # [doc = "Field `WDTIS` writer - WDT - Timer Interval Select 0"]
pub type WDTIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , WDTCTL_SPEC , u8 , WDTIS_A , 3 , O > ; impl < 'a , const O : u8 > WDTIS_W < 'a , O > { # [doc = "WDT - Timer Interval Select: /2G"]
# [inline (always)]
pub fn wdtis_0 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_0) } # [doc = "WDT - Timer Interval Select: /128M"]
# [inline (always)]
pub fn wdtis_1 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_1) } # [doc = "WDT - Timer Interval Select: /8192k"]
# [inline (always)]
pub fn wdtis_2 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_2) } # [doc = "WDT - Timer Interval Select: /512k"]
# [inline (always)]
pub fn wdtis_3 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_3) } # [doc = "WDT - Timer Interval Select: /32k"]
# [inline (always)]
pub fn wdtis_4 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_4) } # [doc = "WDT - Timer Interval Select: /8192"]
# [inline (always)]
pub fn wdtis_5 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_5) } # [doc = "WDT - Timer Interval Select: /512"]
# [inline (always)]
pub fn wdtis_6 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_6) } # [doc = "WDT - Timer Interval Select: /64"]
# [inline (always)]
pub fn wdtis_7 (self) -> & 'a mut W { self . variant (WDTIS_A :: WDTIS_7) } } # [doc = "Field `WDTCNTCL` reader - WDT - Timer Clear"]
pub type WDTCNTCL_R = crate :: BitReader < bool > ; # [doc = "Field `WDTCNTCL` writer - WDT - Timer Clear"]
pub type WDTCNTCL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , WDTCTL_SPEC , bool , O > ; # [doc = "Field `WDTTMSEL` reader - WDT - Timer Mode Select"]
pub type WDTTMSEL_R = crate :: BitReader < bool > ; # [doc = "Field `WDTTMSEL` writer - WDT - Timer Mode Select"]
pub type WDTTMSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , WDTCTL_SPEC , bool , O > ; # [doc = "WDT - Timer Clock Source Select 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WDTSSEL_A { # [doc = "0: WDT - Timer Clock Source Select: SMCLK"]
WDTSSEL_0 = 0 , # [doc = "1: WDT - Timer Clock Source Select: ACLK"]
WDTSSEL_1 = 1 , # [doc = "2: WDT - Timer Clock Source Select: VLO_CLK"]
WDTSSEL_2 = 2 , # [doc = "3: WDT - Timer Clock Source Select: reserved"]
WDTSSEL_3 = 3 , } impl From < WDTSSEL_A > for u8 { # [inline (always)]
fn from (variant : WDTSSEL_A) -> Self { variant as _ } } # [doc = "Field `WDTSSEL` reader - WDT - Timer Clock Source Select 0"]
pub type WDTSSEL_R = crate :: FieldReader < u8 , WDTSSEL_A > ; impl WDTSSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WDTSSEL_A { match self . bits { 0 => WDTSSEL_A :: WDTSSEL_0 , 1 => WDTSSEL_A :: WDTSSEL_1 , 2 => WDTSSEL_A :: WDTSSEL_2 , 3 => WDTSSEL_A :: WDTSSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDTSSEL_0`"]
# [inline (always)]
pub fn is_wdtssel_0 (& self) -> bool { * self == WDTSSEL_A :: WDTSSEL_0 } # [doc = "Checks if the value of the field is `WDTSSEL_1`"]
# [inline (always)]
pub fn is_wdtssel_1 (& self) -> bool { * self == WDTSSEL_A :: WDTSSEL_1 } # [doc = "Checks if the value of the field is `WDTSSEL_2`"]
# [inline (always)]
pub fn is_wdtssel_2 (& self) -> bool { * self == WDTSSEL_A :: WDTSSEL_2 } # [doc = "Checks if the value of the field is `WDTSSEL_3`"]
# [inline (always)]
pub fn is_wdtssel_3 (& self) -> bool { * self == WDTSSEL_A :: WDTSSEL_3 } } # [doc = "Field `WDTSSEL` writer - WDT - Timer Clock Source Select 0"]
pub type WDTSSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , WDTCTL_SPEC , u8 , WDTSSEL_A , 2 , O > ; impl < 'a , const O : u8 > WDTSSEL_W < 'a , O > { # [doc = "WDT - Timer Clock Source Select: SMCLK"]
# [inline (always)]
pub fn wdtssel_0 (self) -> & 'a mut W { self . variant (WDTSSEL_A :: WDTSSEL_0) } # [doc = "WDT - Timer Clock Source Select: ACLK"]
# [inline (always)]
pub fn wdtssel_1 (self) -> & 'a mut W { self . variant (WDTSSEL_A :: WDTSSEL_1) } # [doc = "WDT - Timer Clock Source Select: VLO_CLK"]
# [inline (always)]
pub fn wdtssel_2 (self) -> & 'a mut W { self . variant (WDTSSEL_A :: WDTSSEL_2) } # [doc = "WDT - Timer Clock Source Select: reserved"]
# [inline (always)]
pub fn wdtssel_3 (self) -> & 'a mut W { self . variant (WDTSSEL_A :: WDTSSEL_3) } } # [doc = "Field `WDTHOLD` reader - WDT - Timer hold"]
pub type WDTHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `WDTHOLD` writer - WDT - Timer hold"]
pub type WDTHOLD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , WDTCTL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - WDT - Timer Interval Select 0"]
# [inline (always)]
pub fn wdtis (& self) -> WDTIS_R { WDTIS_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - WDT - Timer Clear"]
# [inline (always)]
pub fn wdtcntcl (& self) -> WDTCNTCL_R { WDTCNTCL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - WDT - Timer Mode Select"]
# [inline (always)]
pub fn wdttmsel (& self) -> WDTTMSEL_R { WDTTMSEL_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - WDT - Timer Clock Source Select 0"]
# [inline (always)]
pub fn wdtssel (& self) -> WDTSSEL_R { WDTSSEL_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - WDT - Timer hold"]
# [inline (always)]
pub fn wdthold (& self) -> WDTHOLD_R { WDTHOLD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - WDT - Timer Interval Select 0"]
# [inline (always)]
pub fn wdtis (& mut self) -> WDTIS_W < 0 > { WDTIS_W :: new (self) } # [doc = "Bit 3 - WDT - Timer Clear"]
# [inline (always)]
pub fn wdtcntcl (& mut self) -> WDTCNTCL_W < 3 > { WDTCNTCL_W :: new (self) } # [doc = "Bit 4 - WDT - Timer Mode Select"]
# [inline (always)]
pub fn wdttmsel (& mut self) -> WDTTMSEL_W < 4 > { WDTTMSEL_W :: new (self) } # [doc = "Bits 5:6 - WDT - Timer Clock Source Select 0"]
# [inline (always)]
pub fn wdtssel (& mut self) -> WDTSSEL_W < 5 > { WDTSSEL_W :: new (self) } # [doc = "Bit 7 - WDT - Timer hold"]
# [inline (always)]
pub fn wdthold (& mut self) -> WDTHOLD_W < 7 > { WDTHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Timer Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtctl](index.html) module"]
pub struct WDTCTL_SPEC ; impl crate :: RegisterSpec for WDTCTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [wdtctl::R](R) reader structure"]
impl crate :: Readable for WDTCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wdtctl::W](W) writer structure"]
impl crate :: Writable for WDTCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WDTCTL to value 0"]
impl crate :: Resettable for WDTCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Real-Time Clock"]
pub struct REAL_TIME_CLOCK { _marker : PhantomData < * const () > } unsafe impl Send for REAL_TIME_CLOCK { } impl REAL_TIME_CLOCK { # [doc = r"Pointer to the register block"]
pub const PTR : * const real_time_clock :: RegisterBlock = 0x0300 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const real_time_clock :: RegisterBlock { Self :: PTR } } impl Deref for REAL_TIME_CLOCK { type Target = real_time_clock :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for REAL_TIME_CLOCK { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("REAL_TIME_CLOCK") . finish () } } # [doc = "Real-Time Clock"]
pub mod real_time_clock { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - RTC control Register"]
pub rtcctl : crate :: Reg < rtcctl :: RTCCTL_SPEC > , _reserved1 : [u8 ; 0x02]
, # [doc = "0x04 - RTC interrupt vector"]
pub rtciv : crate :: Reg < rtciv :: RTCIV_SPEC > , _reserved2 : [u8 ; 0x02]
, # [doc = "0x08 - RTC moduloRegister"]
pub rtcmod : crate :: Reg < rtcmod :: RTCMOD_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x0c - RTC counter Register"]
pub rtccnt : crate :: Reg < rtccnt :: RTCCNT_SPEC > , } # [doc = "RTCCTL register accessor: an alias for `Reg<RTCCTL_SPEC>`"]
pub type RTCCTL = crate :: Reg < rtcctl :: RTCCTL_SPEC > ; # [doc = "RTC control Register"]
pub mod rtcctl { # [doc = "Register `RTCCTL` reader"]
pub struct R (crate :: R < RTCCTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RTCCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RTCCTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RTCCTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RTCCTL` writer"]
pub struct W (crate :: W < RTCCTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RTCCTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RTCCTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RTCCTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RTCIF` reader - Low-Power-Counter Interrupt Flag"]
pub type RTCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RTCIF` writer - Low-Power-Counter Interrupt Flag"]
pub type RTCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , RTCCTL_SPEC , bool , O > ; # [doc = "Field `RTCIE` reader - Low-Power-Counter Interrupt Enable"]
pub type RTCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RTCIE` writer - Low-Power-Counter Interrupt Enable"]
pub type RTCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , RTCCTL_SPEC , bool , O > ; # [doc = "Field `RTCSR` reader - Low-Power-Counter Software Reset"]
pub type RTCSR_R = crate :: BitReader < bool > ; # [doc = "Field `RTCSR` writer - Low-Power-Counter Software Reset"]
pub type RTCSR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , RTCCTL_SPEC , bool , O > ; # [doc = "Low-Power-Counter Clock Pre-divider Select Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RTCPS_A { # [doc = "0: Low-Power-Counter Clock Pre-divider Select: 0"]
RTCPS_0 = 0 , # [doc = "1: Low-Power-Counter Clock Pre-divider Select: 1"]
RTCPS_1 = 1 , # [doc = "2: Low-Power-Counter Clock Pre-divider Select: 2"]
RTCPS_2 = 2 , # [doc = "3: Low-Power-Counter Clock Pre-divider Select: 3"]
RTCPS_3 = 3 , # [doc = "4: Low-Power-Counter Clock Pre-divider Select: 4"]
RTCPS_4 = 4 , # [doc = "5: Low-Power-Counter Clock Pre-divider Select: 5"]
RTCPS_5 = 5 , # [doc = "6: Low-Power-Counter Clock Pre-divider Select: 6"]
RTCPS_6 = 6 , # [doc = "7: Low-Power-Counter Clock Pre-divider Select: 7"]
RTCPS_7 = 7 , } impl From < RTCPS_A > for u8 { # [inline (always)]
fn from (variant : RTCPS_A) -> Self { variant as _ } } # [doc = "Field `RTCPS` reader - Low-Power-Counter Clock Pre-divider Select Bit: 0"]
pub type RTCPS_R = crate :: FieldReader < u8 , RTCPS_A > ; impl RTCPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RTCPS_A { match self . bits { 0 => RTCPS_A :: RTCPS_0 , 1 => RTCPS_A :: RTCPS_1 , 2 => RTCPS_A :: RTCPS_2 , 3 => RTCPS_A :: RTCPS_3 , 4 => RTCPS_A :: RTCPS_4 , 5 => RTCPS_A :: RTCPS_5 , 6 => RTCPS_A :: RTCPS_6 , 7 => RTCPS_A :: RTCPS_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RTCPS_0`"]
# [inline (always)]
pub fn is_rtcps_0 (& self) -> bool { * self == RTCPS_A :: RTCPS_0 } # [doc = "Checks if the value of the field is `RTCPS_1`"]
# [inline (always)]
pub fn is_rtcps_1 (& self) -> bool { * self == RTCPS_A :: RTCPS_1 } # [doc = "Checks if the value of the field is `RTCPS_2`"]
# [inline (always)]
pub fn is_rtcps_2 (& self) -> bool { * self == RTCPS_A :: RTCPS_2 } # [doc = "Checks if the value of the field is `RTCPS_3`"]
# [inline (always)]
pub fn is_rtcps_3 (& self) -> bool { * self == RTCPS_A :: RTCPS_3 } # [doc = "Checks if the value of the field is `RTCPS_4`"]
# [inline (always)]
pub fn is_rtcps_4 (& self) -> bool { * self == RTCPS_A :: RTCPS_4 } # [doc = "Checks if the value of the field is `RTCPS_5`"]
# [inline (always)]
pub fn is_rtcps_5 (& self) -> bool { * self == RTCPS_A :: RTCPS_5 } # [doc = "Checks if the value of the field is `RTCPS_6`"]
# [inline (always)]
pub fn is_rtcps_6 (& self) -> bool { * self == RTCPS_A :: RTCPS_6 } # [doc = "Checks if the value of the field is `RTCPS_7`"]
# [inline (always)]
pub fn is_rtcps_7 (& self) -> bool { * self == RTCPS_A :: RTCPS_7 } } # [doc = "Field `RTCPS` writer - Low-Power-Counter Clock Pre-divider Select Bit: 0"]
pub type RTCPS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , RTCCTL_SPEC , u8 , RTCPS_A , 3 , O > ; impl < 'a , const O : u8 > RTCPS_W < 'a , O > { # [doc = "Low-Power-Counter Clock Pre-divider Select: 0"]
# [inline (always)]
pub fn rtcps_0 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_0) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 1"]
# [inline (always)]
pub fn rtcps_1 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_1) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 2"]
# [inline (always)]
pub fn rtcps_2 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_2) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 3"]
# [inline (always)]
pub fn rtcps_3 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_3) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 4"]
# [inline (always)]
pub fn rtcps_4 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_4) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 5"]
# [inline (always)]
pub fn rtcps_5 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_5) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 6"]
# [inline (always)]
pub fn rtcps_6 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_6) } # [doc = "Low-Power-Counter Clock Pre-divider Select: 7"]
# [inline (always)]
pub fn rtcps_7 (self) -> & 'a mut W { self . variant (RTCPS_A :: RTCPS_7) } } # [doc = "Low-Power-Counter Clock Source Select Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RTCSS_A { # [doc = "0: Low-Power-Counter Clock Source Select: 0"]
RTCSS_0 = 0 , # [doc = "1: Low-Power-Counter Clock Source Select: 1"]
RTCSS_1 = 1 , # [doc = "2: Low-Power-Counter Clock Source Select: 2"]
RTCSS_2 = 2 , # [doc = "3: Low-Power-Counter Clock Source Select: 3"]
RTCSS_3 = 3 , } impl From < RTCSS_A > for u8 { # [inline (always)]
fn from (variant : RTCSS_A) -> Self { variant as _ } } # [doc = "Field `RTCSS` reader - Low-Power-Counter Clock Source Select Bit: 0"]
pub type RTCSS_R = crate :: FieldReader < u8 , RTCSS_A > ; impl RTCSS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RTCSS_A { match self . bits { 0 => RTCSS_A :: RTCSS_0 , 1 => RTCSS_A :: RTCSS_1 , 2 => RTCSS_A :: RTCSS_2 , 3 => RTCSS_A :: RTCSS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RTCSS_0`"]
# [inline (always)]
pub fn is_rtcss_0 (& self) -> bool { * self == RTCSS_A :: RTCSS_0 } # [doc = "Checks if the value of the field is `RTCSS_1`"]
# [inline (always)]
pub fn is_rtcss_1 (& self) -> bool { * self == RTCSS_A :: RTCSS_1 } # [doc = "Checks if the value of the field is `RTCSS_2`"]
# [inline (always)]
pub fn is_rtcss_2 (& self) -> bool { * self == RTCSS_A :: RTCSS_2 } # [doc = "Checks if the value of the field is `RTCSS_3`"]
# [inline (always)]
pub fn is_rtcss_3 (& self) -> bool { * self == RTCSS_A :: RTCSS_3 } } # [doc = "Field `RTCSS` writer - Low-Power-Counter Clock Source Select Bit: 0"]
pub type RTCSS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , RTCCTL_SPEC , u8 , RTCSS_A , 2 , O > ; impl < 'a , const O : u8 > RTCSS_W < 'a , O > { # [doc = "Low-Power-Counter Clock Source Select: 0"]
# [inline (always)]
pub fn rtcss_0 (self) -> & 'a mut W { self . variant (RTCSS_A :: RTCSS_0) } # [doc = "Low-Power-Counter Clock Source Select: 1"]
# [inline (always)]
pub fn rtcss_1 (self) -> & 'a mut W { self . variant (RTCSS_A :: RTCSS_1) } # [doc = "Low-Power-Counter Clock Source Select: 2"]
# [inline (always)]
pub fn rtcss_2 (self) -> & 'a mut W { self . variant (RTCSS_A :: RTCSS_2) } # [doc = "Low-Power-Counter Clock Source Select: 3"]
# [inline (always)]
pub fn rtcss_3 (self) -> & 'a mut W { self . variant (RTCSS_A :: RTCSS_3) } } impl R { # [doc = "Bit 0 - Low-Power-Counter Interrupt Flag"]
# [inline (always)]
pub fn rtcif (& self) -> RTCIF_R { RTCIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low-Power-Counter Interrupt Enable"]
# [inline (always)]
pub fn rtcie (& self) -> RTCIE_R { RTCIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Low-Power-Counter Software Reset"]
# [inline (always)]
pub fn rtcsr (& self) -> RTCSR_R { RTCSR_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bits 8:10 - Low-Power-Counter Clock Pre-divider Select Bit: 0"]
# [inline (always)]
pub fn rtcps (& self) -> RTCPS_R { RTCPS_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bits 12:13 - Low-Power-Counter Clock Source Select Bit: 0"]
# [inline (always)]
pub fn rtcss (& self) -> RTCSS_R { RTCSS_R :: new (((self . bits >> 12) & 3) as u8) } } impl W { # [doc = "Bit 0 - Low-Power-Counter Interrupt Flag"]
# [inline (always)]
pub fn rtcif (& mut self) -> RTCIF_W < 0 > { RTCIF_W :: new (self) } # [doc = "Bit 1 - Low-Power-Counter Interrupt Enable"]
# [inline (always)]
pub fn rtcie (& mut self) -> RTCIE_W < 1 > { RTCIE_W :: new (self) } # [doc = "Bit 6 - Low-Power-Counter Software Reset"]
# [inline (always)]
pub fn rtcsr (& mut self) -> RTCSR_W < 6 > { RTCSR_W :: new (self) } # [doc = "Bits 8:10 - Low-Power-Counter Clock Pre-divider Select Bit: 0"]
# [inline (always)]
pub fn rtcps (& mut self) -> RTCPS_W < 8 > { RTCPS_W :: new (self) } # [doc = "Bits 12:13 - Low-Power-Counter Clock Source Select Bit: 0"]
# [inline (always)]
pub fn rtcss (& mut self) -> RTCSS_W < 12 > { RTCSS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RTC control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtcctl](index.html) module"]
pub struct RTCCTL_SPEC ; impl crate :: RegisterSpec for RTCCTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [rtcctl::R](R) reader structure"]
impl crate :: Readable for RTCCTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rtcctl::W](W) writer structure"]
impl crate :: Writable for RTCCTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RTCCTL to value 0"]
impl crate :: Resettable for RTCCTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RTCIV register accessor: an alias for `Reg<RTCIV_SPEC>`"]
pub type RTCIV = crate :: Reg < rtciv :: RTCIV_SPEC > ; # [doc = "RTC interrupt vector"]
pub mod rtciv { # [doc = "Register `RTCIV` reader"]
pub struct R (crate :: R < RTCIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RTCIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RTCIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RTCIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `RTCIV` writer"]
pub struct W (crate :: W < RTCIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RTCIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RTCIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RTCIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RTC interrupt vector\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtciv](index.html) module"]
pub struct RTCIV_SPEC ; impl crate :: RegisterSpec for RTCIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [rtciv::R](R) reader structure"]
impl crate :: Readable for RTCIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rtciv::W](W) writer structure"]
impl crate :: Writable for RTCIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RTCIV to value 0"]
impl crate :: Resettable for RTCIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RTCMOD register accessor: an alias for `Reg<RTCMOD_SPEC>`"]
pub type RTCMOD = crate :: Reg < rtcmod :: RTCMOD_SPEC > ; # [doc = "RTC moduloRegister"]
pub mod rtcmod { # [doc = "Register `RTCMOD` reader"]
pub struct R (crate :: R < RTCMOD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RTCMOD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RTCMOD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RTCMOD_SPEC >) -> Self { R (reader) } } # [doc = "Register `RTCMOD` writer"]
pub struct W (crate :: W < RTCMOD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RTCMOD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RTCMOD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RTCMOD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RTC moduloRegister\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtcmod](index.html) module"]
pub struct RTCMOD_SPEC ; impl crate :: RegisterSpec for RTCMOD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [rtcmod::R](R) reader structure"]
impl crate :: Readable for RTCMOD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rtcmod::W](W) writer structure"]
impl crate :: Writable for RTCMOD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RTCMOD to value 0"]
impl crate :: Resettable for RTCMOD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RTCCNT register accessor: an alias for `Reg<RTCCNT_SPEC>`"]
pub type RTCCNT = crate :: Reg < rtccnt :: RTCCNT_SPEC > ; # [doc = "RTC counter Register"]
pub mod rtccnt { # [doc = "Register `RTCCNT` reader"]
pub struct R (crate :: R < RTCCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RTCCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RTCCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RTCCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `RTCCNT` writer"]
pub struct W (crate :: W < RTCCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RTCCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RTCCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RTCCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RTC counter Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtccnt](index.html) module"]
pub struct RTCCNT_SPEC ; impl crate :: RegisterSpec for RTCCNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [rtccnt::R](R) reader structure"]
impl crate :: Readable for RTCCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rtccnt::W](W) writer structure"]
impl crate :: Writable for RTCCNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RTCCNT to value 0"]
impl crate :: Resettable for RTCCNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Timer0_A3"]
pub struct TIMER_0_A3 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER_0_A3 { } impl TIMER_0_A3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer_0_a3 :: RegisterBlock = 0x0380 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer_0_a3 :: RegisterBlock { Self :: PTR } } impl Deref for TIMER_0_A3 { type Target = timer_0_a3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER_0_A3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER_0_A3") . finish () } } # [doc = "Timer0_A3"]
pub mod timer_0_a3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer0_A3 Control"]
pub ta0ctl : crate :: Reg < ta0ctl :: TA0CTL_SPEC > , # [doc = "0x02 - Timer0_A3 Capture/Compare Control 0"]
pub ta0cctl0 : crate :: Reg < ta0cctl0 :: TA0CCTL0_SPEC > , # [doc = "0x04 - Timer0_A3 Capture/Compare Control 1"]
pub ta0cctl1 : crate :: Reg < ta0cctl1 :: TA0CCTL1_SPEC > , # [doc = "0x06 - Timer0_A3 Capture/Compare Control 2"]
pub ta0cctl2 : crate :: Reg < ta0cctl2 :: TA0CCTL2_SPEC > , _reserved4 : [u8 ; 0x08]
, # [doc = "0x10 - Timer0_A3"]
pub ta0r : crate :: Reg < ta0r :: TA0R_SPEC > , # [doc = "0x12 - Timer0_A3 Capture/Compare 0"]
pub ta0ccr0 : crate :: Reg < ta0ccr0 :: TA0CCR0_SPEC > , # [doc = "0x14 - Timer0_A3 Capture/Compare 1"]
pub ta0ccr1 : crate :: Reg < ta0ccr1 :: TA0CCR1_SPEC > , # [doc = "0x16 - Timer0_A3 Capture/Compare 2"]
pub ta0ccr2 : crate :: Reg < ta0ccr2 :: TA0CCR2_SPEC > , _reserved8 : [u8 ; 0x08]
, # [doc = "0x20 - Timer0_A3 Expansion Register 0"]
pub ta0ex0 : crate :: Reg < ta0ex0 :: TA0EX0_SPEC > , _reserved9 : [u8 ; 0x0c]
, # [doc = "0x2e - Timer0_A3 Interrupt Vector Word"]
pub ta0iv : crate :: Reg < ta0iv :: TA0IV_SPEC > , } # [doc = "TA0CTL register accessor: an alias for `Reg<TA0CTL_SPEC>`"]
pub type TA0CTL = crate :: Reg < ta0ctl :: TA0CTL_SPEC > ; # [doc = "Timer0_A3 Control"]
pub mod ta0ctl { # [doc = "Register `TA0CTL` reader"]
pub struct R (crate :: R < TA0CTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CTL` writer"]
pub struct W (crate :: W < TA0CTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TAIFG` reader - Timer A counter interrupt flag"]
pub type TAIFG_R = crate :: BitReader < bool > ; # [doc = "Field `TAIFG` writer - Timer A counter interrupt flag"]
pub type TAIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CTL_SPEC , bool , O > ; # [doc = "Field `TAIE` reader - Timer A counter interrupt enable"]
pub type TAIE_R = crate :: BitReader < bool > ; # [doc = "Field `TAIE` writer - Timer A counter interrupt enable"]
pub type TAIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CTL_SPEC , bool , O > ; # [doc = "Field `TACLR` reader - Timer A counter clear"]
pub type TACLR_R = crate :: BitReader < bool > ; # [doc = "Field `TACLR` writer - Timer A counter clear"]
pub type TACLR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CTL_SPEC , bool , O > ; # [doc = "Timer A mode control 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MC_A { # [doc = "0: Timer A mode control: 0 - Stop"]
MC_0 = 0 , # [doc = "1: Timer A mode control: 1 - Up to CCR0"]
MC_1 = 1 , # [doc = "2: Timer A mode control: 2 - Continuous up"]
MC_2 = 2 , # [doc = "3: Timer A mode control: 3 - Up/Down"]
MC_3 = 3 , } impl From < MC_A > for u8 { # [inline (always)]
fn from (variant : MC_A) -> Self { variant as _ } } # [doc = "Field `MC` reader - Timer A mode control 1"]
pub type MC_R = crate :: FieldReader < u8 , MC_A > ; impl MC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MC_A { match self . bits { 0 => MC_A :: MC_0 , 1 => MC_A :: MC_1 , 2 => MC_A :: MC_2 , 3 => MC_A :: MC_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `MC_0`"]
# [inline (always)]
pub fn is_mc_0 (& self) -> bool { * self == MC_A :: MC_0 } # [doc = "Checks if the value of the field is `MC_1`"]
# [inline (always)]
pub fn is_mc_1 (& self) -> bool { * self == MC_A :: MC_1 } # [doc = "Checks if the value of the field is `MC_2`"]
# [inline (always)]
pub fn is_mc_2 (& self) -> bool { * self == MC_A :: MC_2 } # [doc = "Checks if the value of the field is `MC_3`"]
# [inline (always)]
pub fn is_mc_3 (& self) -> bool { * self == MC_A :: MC_3 } } # [doc = "Field `MC` writer - Timer A mode control 1"]
pub type MC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CTL_SPEC , u8 , MC_A , 2 , O > ; impl < 'a , const O : u8 > MC_W < 'a , O > { # [doc = "Timer A mode control: 0 - Stop"]
# [inline (always)]
pub fn mc_0 (self) -> & 'a mut W { self . variant (MC_A :: MC_0) } # [doc = "Timer A mode control: 1 - Up to CCR0"]
# [inline (always)]
pub fn mc_1 (self) -> & 'a mut W { self . variant (MC_A :: MC_1) } # [doc = "Timer A mode control: 2 - Continuous up"]
# [inline (always)]
pub fn mc_2 (self) -> & 'a mut W { self . variant (MC_A :: MC_2) } # [doc = "Timer A mode control: 3 - Up/Down"]
# [inline (always)]
pub fn mc_3 (self) -> & 'a mut W { self . variant (MC_A :: MC_3) } } # [doc = "Timer A clock input divider 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ID_A { # [doc = "0: Timer A input divider: 0 - /1"]
ID_0 = 0 , # [doc = "1: Timer A input divider: 1 - /2"]
ID_1 = 1 , # [doc = "2: Timer A input divider: 2 - /4"]
ID_2 = 2 , # [doc = "3: Timer A input divider: 3 - /8"]
ID_3 = 3 , } impl From < ID_A > for u8 { # [inline (always)]
fn from (variant : ID_A) -> Self { variant as _ } } # [doc = "Field `ID` reader - Timer A clock input divider 1"]
pub type ID_R = crate :: FieldReader < u8 , ID_A > ; impl ID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ID_A { match self . bits { 0 => ID_A :: ID_0 , 1 => ID_A :: ID_1 , 2 => ID_A :: ID_2 , 3 => ID_A :: ID_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ID_0`"]
# [inline (always)]
pub fn is_id_0 (& self) -> bool { * self == ID_A :: ID_0 } # [doc = "Checks if the value of the field is `ID_1`"]
# [inline (always)]
pub fn is_id_1 (& self) -> bool { * self == ID_A :: ID_1 } # [doc = "Checks if the value of the field is `ID_2`"]
# [inline (always)]
pub fn is_id_2 (& self) -> bool { * self == ID_A :: ID_2 } # [doc = "Checks if the value of the field is `ID_3`"]
# [inline (always)]
pub fn is_id_3 (& self) -> bool { * self == ID_A :: ID_3 } } # [doc = "Field `ID` writer - Timer A clock input divider 1"]
pub type ID_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CTL_SPEC , u8 , ID_A , 2 , O > ; impl < 'a , const O : u8 > ID_W < 'a , O > { # [doc = "Timer A input divider: 0 - /1"]
# [inline (always)]
pub fn id_0 (self) -> & 'a mut W { self . variant (ID_A :: ID_0) } # [doc = "Timer A input divider: 1 - /2"]
# [inline (always)]
pub fn id_1 (self) -> & 'a mut W { self . variant (ID_A :: ID_1) } # [doc = "Timer A input divider: 2 - /4"]
# [inline (always)]
pub fn id_2 (self) -> & 'a mut W { self . variant (ID_A :: ID_2) } # [doc = "Timer A input divider: 3 - /8"]
# [inline (always)]
pub fn id_3 (self) -> & 'a mut W { self . variant (ID_A :: ID_3) } } # [doc = "Timer A clock source select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TASSEL_A { # [doc = "0: Timer A clock source select: 0 - TACLK"]
TASSEL_0 = 0 , # [doc = "1: Timer A clock source select: 1 - ACLK"]
TASSEL_1 = 1 , # [doc = "2: Timer A clock source select: 2 - SMCLK"]
TASSEL_2 = 2 , # [doc = "3: Timer A clock source select: 3 - INCLK"]
TASSEL_3 = 3 , } impl From < TASSEL_A > for u8 { # [inline (always)]
fn from (variant : TASSEL_A) -> Self { variant as _ } } # [doc = "Field `TASSEL` reader - Timer A clock source select 1"]
pub type TASSEL_R = crate :: FieldReader < u8 , TASSEL_A > ; impl TASSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TASSEL_A { match self . bits { 0 => TASSEL_A :: TASSEL_0 , 1 => TASSEL_A :: TASSEL_1 , 2 => TASSEL_A :: TASSEL_2 , 3 => TASSEL_A :: TASSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TASSEL_0`"]
# [inline (always)]
pub fn is_tassel_0 (& self) -> bool { * self == TASSEL_A :: TASSEL_0 } # [doc = "Checks if the value of the field is `TASSEL_1`"]
# [inline (always)]
pub fn is_tassel_1 (& self) -> bool { * self == TASSEL_A :: TASSEL_1 } # [doc = "Checks if the value of the field is `TASSEL_2`"]
# [inline (always)]
pub fn is_tassel_2 (& self) -> bool { * self == TASSEL_A :: TASSEL_2 } # [doc = "Checks if the value of the field is `TASSEL_3`"]
# [inline (always)]
pub fn is_tassel_3 (& self) -> bool { * self == TASSEL_A :: TASSEL_3 } } # [doc = "Field `TASSEL` writer - Timer A clock source select 1"]
pub type TASSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CTL_SPEC , u8 , TASSEL_A , 2 , O > ; impl < 'a , const O : u8 > TASSEL_W < 'a , O > { # [doc = "Timer A clock source select: 0 - TACLK"]
# [inline (always)]
pub fn tassel_0 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_0) } # [doc = "Timer A clock source select: 1 - ACLK"]
# [inline (always)]
pub fn tassel_1 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_1) } # [doc = "Timer A clock source select: 2 - SMCLK"]
# [inline (always)]
pub fn tassel_2 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_2) } # [doc = "Timer A clock source select: 3 - INCLK"]
# [inline (always)]
pub fn tassel_3 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_3) } } impl R { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& self) -> TAIFG_R { TAIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& self) -> TAIE_R { TAIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& self) -> TACLR_R { TACLR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& self) -> MC_R { MC_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& self) -> TASSEL_R { TASSEL_R :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& mut self) -> TAIFG_W < 0 > { TAIFG_W :: new (self) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& mut self) -> TAIE_W < 1 > { TAIE_W :: new (self) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& mut self) -> TACLR_W < 2 > { TACLR_W :: new (self) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& mut self) -> MC_W < 4 > { MC_W :: new (self) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& mut self) -> ID_W < 6 > { ID_W :: new (self) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& mut self) -> TASSEL_W < 8 > { TASSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0ctl](index.html) module"]
pub struct TA0CTL_SPEC ; impl crate :: RegisterSpec for TA0CTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0ctl::R](R) reader structure"]
impl crate :: Readable for TA0CTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0ctl::W](W) writer structure"]
impl crate :: Writable for TA0CTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CTL to value 0"]
impl crate :: Resettable for TA0CTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCTL0 register accessor: an alias for `Reg<TA0CCTL0_SPEC>`"]
pub type TA0CCTL0 = crate :: Reg < ta0cctl0 :: TA0CCTL0_SPEC > ; # [doc = "Timer0_A3 Capture/Compare Control 0"]
pub mod ta0cctl0 { # [doc = "Register `TA0CCTL0` reader"]
pub struct R (crate :: R < TA0CCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCTL0` writer"]
pub struct W (crate :: W < TA0CCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL0_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL0_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL0_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL0_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0cctl0](index.html) module"]
pub struct TA0CCTL0_SPEC ; impl crate :: RegisterSpec for TA0CCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0cctl0::R](R) reader structure"]
impl crate :: Readable for TA0CCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0cctl0::W](W) writer structure"]
impl crate :: Writable for TA0CCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCTL0 to value 0"]
impl crate :: Resettable for TA0CCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCTL1 register accessor: an alias for `Reg<TA0CCTL1_SPEC>`"]
pub type TA0CCTL1 = crate :: Reg < ta0cctl1 :: TA0CCTL1_SPEC > ; # [doc = "Timer0_A3 Capture/Compare Control 1"]
pub mod ta0cctl1 { # [doc = "Register `TA0CCTL1` reader"]
pub struct R (crate :: R < TA0CCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCTL1` writer"]
pub struct W (crate :: W < TA0CCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL1_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL1_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL1_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL1_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0cctl1](index.html) module"]
pub struct TA0CCTL1_SPEC ; impl crate :: RegisterSpec for TA0CCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0cctl1::R](R) reader structure"]
impl crate :: Readable for TA0CCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0cctl1::W](W) writer structure"]
impl crate :: Writable for TA0CCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCTL1 to value 0"]
impl crate :: Resettable for TA0CCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCTL2 register accessor: an alias for `Reg<TA0CCTL2_SPEC>`"]
pub type TA0CCTL2 = crate :: Reg < ta0cctl2 :: TA0CCTL2_SPEC > ; # [doc = "Timer0_A3 Capture/Compare Control 2"]
pub mod ta0cctl2 { # [doc = "Register `TA0CCTL2` reader"]
pub struct R (crate :: R < TA0CCTL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCTL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCTL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCTL2` writer"]
pub struct W (crate :: W < TA0CCTL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCTL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCTL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL2_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA0CCTL2_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL2_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0CCTL2_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0cctl2](index.html) module"]
pub struct TA0CCTL2_SPEC ; impl crate :: RegisterSpec for TA0CCTL2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0cctl2::R](R) reader structure"]
impl crate :: Readable for TA0CCTL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0cctl2::W](W) writer structure"]
impl crate :: Writable for TA0CCTL2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCTL2 to value 0"]
impl crate :: Resettable for TA0CCTL2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0R register accessor: an alias for `Reg<TA0R_SPEC>`"]
pub type TA0R = crate :: Reg < ta0r :: TA0R_SPEC > ; # [doc = "Timer0_A3"]
pub mod ta0r { # [doc = "Register `TA0R` reader"]
pub struct R (crate :: R < TA0R_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0R_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0R_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0R` writer"]
pub struct W (crate :: W < TA0R_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0R_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0R_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0r](index.html) module"]
pub struct TA0R_SPEC ; impl crate :: RegisterSpec for TA0R_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0r::R](R) reader structure"]
impl crate :: Readable for TA0R_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0r::W](W) writer structure"]
impl crate :: Writable for TA0R_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0R to value 0"]
impl crate :: Resettable for TA0R_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCR0 register accessor: an alias for `Reg<TA0CCR0_SPEC>`"]
pub type TA0CCR0 = crate :: Reg < ta0ccr0 :: TA0CCR0_SPEC > ; # [doc = "Timer0_A3 Capture/Compare 0"]
pub mod ta0ccr0 { # [doc = "Register `TA0CCR0` reader"]
pub struct R (crate :: R < TA0CCR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCR0` writer"]
pub struct W (crate :: W < TA0CCR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0ccr0](index.html) module"]
pub struct TA0CCR0_SPEC ; impl crate :: RegisterSpec for TA0CCR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0ccr0::R](R) reader structure"]
impl crate :: Readable for TA0CCR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0ccr0::W](W) writer structure"]
impl crate :: Writable for TA0CCR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCR0 to value 0"]
impl crate :: Resettable for TA0CCR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCR1 register accessor: an alias for `Reg<TA0CCR1_SPEC>`"]
pub type TA0CCR1 = crate :: Reg < ta0ccr1 :: TA0CCR1_SPEC > ; # [doc = "Timer0_A3 Capture/Compare 1"]
pub mod ta0ccr1 { # [doc = "Register `TA0CCR1` reader"]
pub struct R (crate :: R < TA0CCR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCR1` writer"]
pub struct W (crate :: W < TA0CCR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0ccr1](index.html) module"]
pub struct TA0CCR1_SPEC ; impl crate :: RegisterSpec for TA0CCR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0ccr1::R](R) reader structure"]
impl crate :: Readable for TA0CCR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0ccr1::W](W) writer structure"]
impl crate :: Writable for TA0CCR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCR1 to value 0"]
impl crate :: Resettable for TA0CCR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0CCR2 register accessor: an alias for `Reg<TA0CCR2_SPEC>`"]
pub type TA0CCR2 = crate :: Reg < ta0ccr2 :: TA0CCR2_SPEC > ; # [doc = "Timer0_A3 Capture/Compare 2"]
pub mod ta0ccr2 { # [doc = "Register `TA0CCR2` reader"]
pub struct R (crate :: R < TA0CCR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0CCR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0CCR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0CCR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0CCR2` writer"]
pub struct W (crate :: W < TA0CCR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0CCR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0CCR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0CCR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Capture/Compare 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0ccr2](index.html) module"]
pub struct TA0CCR2_SPEC ; impl crate :: RegisterSpec for TA0CCR2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0ccr2::R](R) reader structure"]
impl crate :: Readable for TA0CCR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0ccr2::W](W) writer structure"]
impl crate :: Writable for TA0CCR2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0CCR2 to value 0"]
impl crate :: Resettable for TA0CCR2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0EX0 register accessor: an alias for `Reg<TA0EX0_SPEC>`"]
pub type TA0EX0 = crate :: Reg < ta0ex0 :: TA0EX0_SPEC > ; # [doc = "Timer0_A3 Expansion Register 0"]
pub mod ta0ex0 { # [doc = "Register `TA0EX0` reader"]
pub struct R (crate :: R < TA0EX0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0EX0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0EX0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0EX0` writer"]
pub struct W (crate :: W < TA0EX0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0EX0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0EX0_SPEC >) -> Self { W (writer) } } # [doc = "Timer A Input divider expansion Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TAIDEX_A { # [doc = "0: Timer A Input divider expansion : /1"]
TAIDEX_0 = 0 , # [doc = "1: Timer A Input divider expansion : /2"]
TAIDEX_1 = 1 , # [doc = "2: Timer A Input divider expansion : /3"]
TAIDEX_2 = 2 , # [doc = "3: Timer A Input divider expansion : /4"]
TAIDEX_3 = 3 , # [doc = "4: Timer A Input divider expansion : /5"]
TAIDEX_4 = 4 , # [doc = "5: Timer A Input divider expansion : /6"]
TAIDEX_5 = 5 , # [doc = "6: Timer A Input divider expansion : /7"]
TAIDEX_6 = 6 , # [doc = "7: Timer A Input divider expansion : /8"]
TAIDEX_7 = 7 , } impl From < TAIDEX_A > for u8 { # [inline (always)]
fn from (variant : TAIDEX_A) -> Self { variant as _ } } # [doc = "Field `TAIDEX` reader - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_R = crate :: FieldReader < u8 , TAIDEX_A > ; impl TAIDEX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TAIDEX_A { match self . bits { 0 => TAIDEX_A :: TAIDEX_0 , 1 => TAIDEX_A :: TAIDEX_1 , 2 => TAIDEX_A :: TAIDEX_2 , 3 => TAIDEX_A :: TAIDEX_3 , 4 => TAIDEX_A :: TAIDEX_4 , 5 => TAIDEX_A :: TAIDEX_5 , 6 => TAIDEX_A :: TAIDEX_6 , 7 => TAIDEX_A :: TAIDEX_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TAIDEX_0`"]
# [inline (always)]
pub fn is_taidex_0 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_0 } # [doc = "Checks if the value of the field is `TAIDEX_1`"]
# [inline (always)]
pub fn is_taidex_1 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_1 } # [doc = "Checks if the value of the field is `TAIDEX_2`"]
# [inline (always)]
pub fn is_taidex_2 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_2 } # [doc = "Checks if the value of the field is `TAIDEX_3`"]
# [inline (always)]
pub fn is_taidex_3 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_3 } # [doc = "Checks if the value of the field is `TAIDEX_4`"]
# [inline (always)]
pub fn is_taidex_4 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_4 } # [doc = "Checks if the value of the field is `TAIDEX_5`"]
# [inline (always)]
pub fn is_taidex_5 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_5 } # [doc = "Checks if the value of the field is `TAIDEX_6`"]
# [inline (always)]
pub fn is_taidex_6 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_6 } # [doc = "Checks if the value of the field is `TAIDEX_7`"]
# [inline (always)]
pub fn is_taidex_7 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_7 } } # [doc = "Field `TAIDEX` writer - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA0EX0_SPEC , u8 , TAIDEX_A , 3 , O > ; impl < 'a , const O : u8 > TAIDEX_W < 'a , O > { # [doc = "Timer A Input divider expansion : /1"]
# [inline (always)]
pub fn taidex_0 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_0) } # [doc = "Timer A Input divider expansion : /2"]
# [inline (always)]
pub fn taidex_1 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_1) } # [doc = "Timer A Input divider expansion : /3"]
# [inline (always)]
pub fn taidex_2 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_2) } # [doc = "Timer A Input divider expansion : /4"]
# [inline (always)]
pub fn taidex_3 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_3) } # [doc = "Timer A Input divider expansion : /5"]
# [inline (always)]
pub fn taidex_4 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_4) } # [doc = "Timer A Input divider expansion : /6"]
# [inline (always)]
pub fn taidex_5 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_5) } # [doc = "Timer A Input divider expansion : /7"]
# [inline (always)]
pub fn taidex_6 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_6) } # [doc = "Timer A Input divider expansion : /8"]
# [inline (always)]
pub fn taidex_7 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_7) } } impl R { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& self) -> TAIDEX_R { TAIDEX_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& mut self) -> TAIDEX_W < 0 > { TAIDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0ex0](index.html) module"]
pub struct TA0EX0_SPEC ; impl crate :: RegisterSpec for TA0EX0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0ex0::R](R) reader structure"]
impl crate :: Readable for TA0EX0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0ex0::W](W) writer structure"]
impl crate :: Writable for TA0EX0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0EX0 to value 0"]
impl crate :: Resettable for TA0EX0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA0IV register accessor: an alias for `Reg<TA0IV_SPEC>`"]
pub type TA0IV = crate :: Reg < ta0iv :: TA0IV_SPEC > ; # [doc = "Timer0_A3 Interrupt Vector Word"]
pub mod ta0iv { # [doc = "Register `TA0IV` reader"]
pub struct R (crate :: R < TA0IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA0IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA0IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA0IV` writer"]
pub struct W (crate :: W < TA0IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA0IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA0IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA0IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer0_A3 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta0iv](index.html) module"]
pub struct TA0IV_SPEC ; impl crate :: RegisterSpec for TA0IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta0iv::R](R) reader structure"]
impl crate :: Readable for TA0IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta0iv::W](W) writer structure"]
impl crate :: Writable for TA0IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA0IV to value 0"]
impl crate :: Resettable for TA0IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Timer1_A3"]
pub struct TIMER_1_A3 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER_1_A3 { } impl TIMER_1_A3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer_1_a3 :: RegisterBlock = 0x03c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer_1_a3 :: RegisterBlock { Self :: PTR } } impl Deref for TIMER_1_A3 { type Target = timer_1_a3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER_1_A3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER_1_A3") . finish () } } # [doc = "Timer1_A3"]
pub mod timer_1_a3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer1_A3 Control"]
pub ta1ctl : crate :: Reg < ta1ctl :: TA1CTL_SPEC > , # [doc = "0x02 - Timer1_A3 Capture/Compare Control 0"]
pub ta1cctl0 : crate :: Reg < ta1cctl0 :: TA1CCTL0_SPEC > , # [doc = "0x04 - Timer1_A3 Capture/Compare Control 1"]
pub ta1cctl1 : crate :: Reg < ta1cctl1 :: TA1CCTL1_SPEC > , # [doc = "0x06 - Timer1_A3 Capture/Compare Control 2"]
pub ta1cctl2 : crate :: Reg < ta1cctl2 :: TA1CCTL2_SPEC > , _reserved4 : [u8 ; 0x08]
, # [doc = "0x10 - Timer1_A3"]
pub ta1r : crate :: Reg < ta1r :: TA1R_SPEC > , # [doc = "0x12 - Timer1_A3 Capture/Compare 0"]
pub ta1ccr0 : crate :: Reg < ta1ccr0 :: TA1CCR0_SPEC > , # [doc = "0x14 - Timer1_A3 Capture/Compare 1"]
pub ta1ccr1 : crate :: Reg < ta1ccr1 :: TA1CCR1_SPEC > , # [doc = "0x16 - Timer1_A3 Capture/Compare 2"]
pub ta1ccr2 : crate :: Reg < ta1ccr2 :: TA1CCR2_SPEC > , _reserved8 : [u8 ; 0x08]
, # [doc = "0x20 - Timer1_A3 Expansion Register 0"]
pub ta1ex0 : crate :: Reg < ta1ex0 :: TA1EX0_SPEC > , _reserved9 : [u8 ; 0x0c]
, # [doc = "0x2e - Timer1_A3 Interrupt Vector Word"]
pub ta1iv : crate :: Reg < ta1iv :: TA1IV_SPEC > , } # [doc = "TA1CTL register accessor: an alias for `Reg<TA1CTL_SPEC>`"]
pub type TA1CTL = crate :: Reg < ta1ctl :: TA1CTL_SPEC > ; # [doc = "Timer1_A3 Control"]
pub mod ta1ctl { # [doc = "Register `TA1CTL` reader"]
pub struct R (crate :: R < TA1CTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CTL` writer"]
pub struct W (crate :: W < TA1CTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TAIFG` reader - Timer A counter interrupt flag"]
pub type TAIFG_R = crate :: BitReader < bool > ; # [doc = "Field `TAIFG` writer - Timer A counter interrupt flag"]
pub type TAIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CTL_SPEC , bool , O > ; # [doc = "Field `TAIE` reader - Timer A counter interrupt enable"]
pub type TAIE_R = crate :: BitReader < bool > ; # [doc = "Field `TAIE` writer - Timer A counter interrupt enable"]
pub type TAIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CTL_SPEC , bool , O > ; # [doc = "Field `TACLR` reader - Timer A counter clear"]
pub type TACLR_R = crate :: BitReader < bool > ; # [doc = "Field `TACLR` writer - Timer A counter clear"]
pub type TACLR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CTL_SPEC , bool , O > ; # [doc = "Timer A mode control 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MC_A { # [doc = "0: Timer A mode control: 0 - Stop"]
MC_0 = 0 , # [doc = "1: Timer A mode control: 1 - Up to CCR0"]
MC_1 = 1 , # [doc = "2: Timer A mode control: 2 - Continuous up"]
MC_2 = 2 , # [doc = "3: Timer A mode control: 3 - Up/Down"]
MC_3 = 3 , } impl From < MC_A > for u8 { # [inline (always)]
fn from (variant : MC_A) -> Self { variant as _ } } # [doc = "Field `MC` reader - Timer A mode control 1"]
pub type MC_R = crate :: FieldReader < u8 , MC_A > ; impl MC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MC_A { match self . bits { 0 => MC_A :: MC_0 , 1 => MC_A :: MC_1 , 2 => MC_A :: MC_2 , 3 => MC_A :: MC_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `MC_0`"]
# [inline (always)]
pub fn is_mc_0 (& self) -> bool { * self == MC_A :: MC_0 } # [doc = "Checks if the value of the field is `MC_1`"]
# [inline (always)]
pub fn is_mc_1 (& self) -> bool { * self == MC_A :: MC_1 } # [doc = "Checks if the value of the field is `MC_2`"]
# [inline (always)]
pub fn is_mc_2 (& self) -> bool { * self == MC_A :: MC_2 } # [doc = "Checks if the value of the field is `MC_3`"]
# [inline (always)]
pub fn is_mc_3 (& self) -> bool { * self == MC_A :: MC_3 } } # [doc = "Field `MC` writer - Timer A mode control 1"]
pub type MC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CTL_SPEC , u8 , MC_A , 2 , O > ; impl < 'a , const O : u8 > MC_W < 'a , O > { # [doc = "Timer A mode control: 0 - Stop"]
# [inline (always)]
pub fn mc_0 (self) -> & 'a mut W { self . variant (MC_A :: MC_0) } # [doc = "Timer A mode control: 1 - Up to CCR0"]
# [inline (always)]
pub fn mc_1 (self) -> & 'a mut W { self . variant (MC_A :: MC_1) } # [doc = "Timer A mode control: 2 - Continuous up"]
# [inline (always)]
pub fn mc_2 (self) -> & 'a mut W { self . variant (MC_A :: MC_2) } # [doc = "Timer A mode control: 3 - Up/Down"]
# [inline (always)]
pub fn mc_3 (self) -> & 'a mut W { self . variant (MC_A :: MC_3) } } # [doc = "Timer A clock input divider 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ID_A { # [doc = "0: Timer A input divider: 0 - /1"]
ID_0 = 0 , # [doc = "1: Timer A input divider: 1 - /2"]
ID_1 = 1 , # [doc = "2: Timer A input divider: 2 - /4"]
ID_2 = 2 , # [doc = "3: Timer A input divider: 3 - /8"]
ID_3 = 3 , } impl From < ID_A > for u8 { # [inline (always)]
fn from (variant : ID_A) -> Self { variant as _ } } # [doc = "Field `ID` reader - Timer A clock input divider 1"]
pub type ID_R = crate :: FieldReader < u8 , ID_A > ; impl ID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ID_A { match self . bits { 0 => ID_A :: ID_0 , 1 => ID_A :: ID_1 , 2 => ID_A :: ID_2 , 3 => ID_A :: ID_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ID_0`"]
# [inline (always)]
pub fn is_id_0 (& self) -> bool { * self == ID_A :: ID_0 } # [doc = "Checks if the value of the field is `ID_1`"]
# [inline (always)]
pub fn is_id_1 (& self) -> bool { * self == ID_A :: ID_1 } # [doc = "Checks if the value of the field is `ID_2`"]
# [inline (always)]
pub fn is_id_2 (& self) -> bool { * self == ID_A :: ID_2 } # [doc = "Checks if the value of the field is `ID_3`"]
# [inline (always)]
pub fn is_id_3 (& self) -> bool { * self == ID_A :: ID_3 } } # [doc = "Field `ID` writer - Timer A clock input divider 1"]
pub type ID_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CTL_SPEC , u8 , ID_A , 2 , O > ; impl < 'a , const O : u8 > ID_W < 'a , O > { # [doc = "Timer A input divider: 0 - /1"]
# [inline (always)]
pub fn id_0 (self) -> & 'a mut W { self . variant (ID_A :: ID_0) } # [doc = "Timer A input divider: 1 - /2"]
# [inline (always)]
pub fn id_1 (self) -> & 'a mut W { self . variant (ID_A :: ID_1) } # [doc = "Timer A input divider: 2 - /4"]
# [inline (always)]
pub fn id_2 (self) -> & 'a mut W { self . variant (ID_A :: ID_2) } # [doc = "Timer A input divider: 3 - /8"]
# [inline (always)]
pub fn id_3 (self) -> & 'a mut W { self . variant (ID_A :: ID_3) } } # [doc = "Timer A clock source select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TASSEL_A { # [doc = "0: Timer A clock source select: 0 - TACLK"]
TASSEL_0 = 0 , # [doc = "1: Timer A clock source select: 1 - ACLK"]
TASSEL_1 = 1 , # [doc = "2: Timer A clock source select: 2 - SMCLK"]
TASSEL_2 = 2 , # [doc = "3: Timer A clock source select: 3 - INCLK"]
TASSEL_3 = 3 , } impl From < TASSEL_A > for u8 { # [inline (always)]
fn from (variant : TASSEL_A) -> Self { variant as _ } } # [doc = "Field `TASSEL` reader - Timer A clock source select 1"]
pub type TASSEL_R = crate :: FieldReader < u8 , TASSEL_A > ; impl TASSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TASSEL_A { match self . bits { 0 => TASSEL_A :: TASSEL_0 , 1 => TASSEL_A :: TASSEL_1 , 2 => TASSEL_A :: TASSEL_2 , 3 => TASSEL_A :: TASSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TASSEL_0`"]
# [inline (always)]
pub fn is_tassel_0 (& self) -> bool { * self == TASSEL_A :: TASSEL_0 } # [doc = "Checks if the value of the field is `TASSEL_1`"]
# [inline (always)]
pub fn is_tassel_1 (& self) -> bool { * self == TASSEL_A :: TASSEL_1 } # [doc = "Checks if the value of the field is `TASSEL_2`"]
# [inline (always)]
pub fn is_tassel_2 (& self) -> bool { * self == TASSEL_A :: TASSEL_2 } # [doc = "Checks if the value of the field is `TASSEL_3`"]
# [inline (always)]
pub fn is_tassel_3 (& self) -> bool { * self == TASSEL_A :: TASSEL_3 } } # [doc = "Field `TASSEL` writer - Timer A clock source select 1"]
pub type TASSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CTL_SPEC , u8 , TASSEL_A , 2 , O > ; impl < 'a , const O : u8 > TASSEL_W < 'a , O > { # [doc = "Timer A clock source select: 0 - TACLK"]
# [inline (always)]
pub fn tassel_0 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_0) } # [doc = "Timer A clock source select: 1 - ACLK"]
# [inline (always)]
pub fn tassel_1 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_1) } # [doc = "Timer A clock source select: 2 - SMCLK"]
# [inline (always)]
pub fn tassel_2 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_2) } # [doc = "Timer A clock source select: 3 - INCLK"]
# [inline (always)]
pub fn tassel_3 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_3) } } impl R { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& self) -> TAIFG_R { TAIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& self) -> TAIE_R { TAIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& self) -> TACLR_R { TACLR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& self) -> MC_R { MC_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& self) -> TASSEL_R { TASSEL_R :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& mut self) -> TAIFG_W < 0 > { TAIFG_W :: new (self) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& mut self) -> TAIE_W < 1 > { TAIE_W :: new (self) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& mut self) -> TACLR_W < 2 > { TACLR_W :: new (self) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& mut self) -> MC_W < 4 > { MC_W :: new (self) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& mut self) -> ID_W < 6 > { ID_W :: new (self) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& mut self) -> TASSEL_W < 8 > { TASSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1ctl](index.html) module"]
pub struct TA1CTL_SPEC ; impl crate :: RegisterSpec for TA1CTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1ctl::R](R) reader structure"]
impl crate :: Readable for TA1CTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1ctl::W](W) writer structure"]
impl crate :: Writable for TA1CTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CTL to value 0"]
impl crate :: Resettable for TA1CTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCTL0 register accessor: an alias for `Reg<TA1CCTL0_SPEC>`"]
pub type TA1CCTL0 = crate :: Reg < ta1cctl0 :: TA1CCTL0_SPEC > ; # [doc = "Timer1_A3 Capture/Compare Control 0"]
pub mod ta1cctl0 { # [doc = "Register `TA1CCTL0` reader"]
pub struct R (crate :: R < TA1CCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCTL0` writer"]
pub struct W (crate :: W < TA1CCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL0_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL0_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL0_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL0_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1cctl0](index.html) module"]
pub struct TA1CCTL0_SPEC ; impl crate :: RegisterSpec for TA1CCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1cctl0::R](R) reader structure"]
impl crate :: Readable for TA1CCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1cctl0::W](W) writer structure"]
impl crate :: Writable for TA1CCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCTL0 to value 0"]
impl crate :: Resettable for TA1CCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCTL1 register accessor: an alias for `Reg<TA1CCTL1_SPEC>`"]
pub type TA1CCTL1 = crate :: Reg < ta1cctl1 :: TA1CCTL1_SPEC > ; # [doc = "Timer1_A3 Capture/Compare Control 1"]
pub mod ta1cctl1 { # [doc = "Register `TA1CCTL1` reader"]
pub struct R (crate :: R < TA1CCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCTL1` writer"]
pub struct W (crate :: W < TA1CCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL1_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL1_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL1_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL1_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1cctl1](index.html) module"]
pub struct TA1CCTL1_SPEC ; impl crate :: RegisterSpec for TA1CCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1cctl1::R](R) reader structure"]
impl crate :: Readable for TA1CCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1cctl1::W](W) writer structure"]
impl crate :: Writable for TA1CCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCTL1 to value 0"]
impl crate :: Resettable for TA1CCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCTL2 register accessor: an alias for `Reg<TA1CCTL2_SPEC>`"]
pub type TA1CCTL2 = crate :: Reg < ta1cctl2 :: TA1CCTL2_SPEC > ; # [doc = "Timer1_A3 Capture/Compare Control 2"]
pub mod ta1cctl2 { # [doc = "Register `TA1CCTL2` reader"]
pub struct R (crate :: R < TA1CCTL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCTL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCTL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCTL2` writer"]
pub struct W (crate :: W < TA1CCTL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCTL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCTL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL2_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA1CCTL2_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL2_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1CCTL2_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1cctl2](index.html) module"]
pub struct TA1CCTL2_SPEC ; impl crate :: RegisterSpec for TA1CCTL2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1cctl2::R](R) reader structure"]
impl crate :: Readable for TA1CCTL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1cctl2::W](W) writer structure"]
impl crate :: Writable for TA1CCTL2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCTL2 to value 0"]
impl crate :: Resettable for TA1CCTL2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1R register accessor: an alias for `Reg<TA1R_SPEC>`"]
pub type TA1R = crate :: Reg < ta1r :: TA1R_SPEC > ; # [doc = "Timer1_A3"]
pub mod ta1r { # [doc = "Register `TA1R` reader"]
pub struct R (crate :: R < TA1R_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1R_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1R_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1R` writer"]
pub struct W (crate :: W < TA1R_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1R_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1R_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1r](index.html) module"]
pub struct TA1R_SPEC ; impl crate :: RegisterSpec for TA1R_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1r::R](R) reader structure"]
impl crate :: Readable for TA1R_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1r::W](W) writer structure"]
impl crate :: Writable for TA1R_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1R to value 0"]
impl crate :: Resettable for TA1R_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCR0 register accessor: an alias for `Reg<TA1CCR0_SPEC>`"]
pub type TA1CCR0 = crate :: Reg < ta1ccr0 :: TA1CCR0_SPEC > ; # [doc = "Timer1_A3 Capture/Compare 0"]
pub mod ta1ccr0 { # [doc = "Register `TA1CCR0` reader"]
pub struct R (crate :: R < TA1CCR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCR0` writer"]
pub struct W (crate :: W < TA1CCR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1ccr0](index.html) module"]
pub struct TA1CCR0_SPEC ; impl crate :: RegisterSpec for TA1CCR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1ccr0::R](R) reader structure"]
impl crate :: Readable for TA1CCR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1ccr0::W](W) writer structure"]
impl crate :: Writable for TA1CCR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCR0 to value 0"]
impl crate :: Resettable for TA1CCR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCR1 register accessor: an alias for `Reg<TA1CCR1_SPEC>`"]
pub type TA1CCR1 = crate :: Reg < ta1ccr1 :: TA1CCR1_SPEC > ; # [doc = "Timer1_A3 Capture/Compare 1"]
pub mod ta1ccr1 { # [doc = "Register `TA1CCR1` reader"]
pub struct R (crate :: R < TA1CCR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCR1` writer"]
pub struct W (crate :: W < TA1CCR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1ccr1](index.html) module"]
pub struct TA1CCR1_SPEC ; impl crate :: RegisterSpec for TA1CCR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1ccr1::R](R) reader structure"]
impl crate :: Readable for TA1CCR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1ccr1::W](W) writer structure"]
impl crate :: Writable for TA1CCR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCR1 to value 0"]
impl crate :: Resettable for TA1CCR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1CCR2 register accessor: an alias for `Reg<TA1CCR2_SPEC>`"]
pub type TA1CCR2 = crate :: Reg < ta1ccr2 :: TA1CCR2_SPEC > ; # [doc = "Timer1_A3 Capture/Compare 2"]
pub mod ta1ccr2 { # [doc = "Register `TA1CCR2` reader"]
pub struct R (crate :: R < TA1CCR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1CCR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1CCR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1CCR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1CCR2` writer"]
pub struct W (crate :: W < TA1CCR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1CCR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1CCR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1CCR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Capture/Compare 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1ccr2](index.html) module"]
pub struct TA1CCR2_SPEC ; impl crate :: RegisterSpec for TA1CCR2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1ccr2::R](R) reader structure"]
impl crate :: Readable for TA1CCR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1ccr2::W](W) writer structure"]
impl crate :: Writable for TA1CCR2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1CCR2 to value 0"]
impl crate :: Resettable for TA1CCR2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1EX0 register accessor: an alias for `Reg<TA1EX0_SPEC>`"]
pub type TA1EX0 = crate :: Reg < ta1ex0 :: TA1EX0_SPEC > ; # [doc = "Timer1_A3 Expansion Register 0"]
pub mod ta1ex0 { # [doc = "Register `TA1EX0` reader"]
pub struct R (crate :: R < TA1EX0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1EX0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1EX0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1EX0` writer"]
pub struct W (crate :: W < TA1EX0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1EX0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1EX0_SPEC >) -> Self { W (writer) } } # [doc = "Timer A Input divider expansion Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TAIDEX_A { # [doc = "0: Timer A Input divider expansion : /1"]
TAIDEX_0 = 0 , # [doc = "1: Timer A Input divider expansion : /2"]
TAIDEX_1 = 1 , # [doc = "2: Timer A Input divider expansion : /3"]
TAIDEX_2 = 2 , # [doc = "3: Timer A Input divider expansion : /4"]
TAIDEX_3 = 3 , # [doc = "4: Timer A Input divider expansion : /5"]
TAIDEX_4 = 4 , # [doc = "5: Timer A Input divider expansion : /6"]
TAIDEX_5 = 5 , # [doc = "6: Timer A Input divider expansion : /7"]
TAIDEX_6 = 6 , # [doc = "7: Timer A Input divider expansion : /8"]
TAIDEX_7 = 7 , } impl From < TAIDEX_A > for u8 { # [inline (always)]
fn from (variant : TAIDEX_A) -> Self { variant as _ } } # [doc = "Field `TAIDEX` reader - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_R = crate :: FieldReader < u8 , TAIDEX_A > ; impl TAIDEX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TAIDEX_A { match self . bits { 0 => TAIDEX_A :: TAIDEX_0 , 1 => TAIDEX_A :: TAIDEX_1 , 2 => TAIDEX_A :: TAIDEX_2 , 3 => TAIDEX_A :: TAIDEX_3 , 4 => TAIDEX_A :: TAIDEX_4 , 5 => TAIDEX_A :: TAIDEX_5 , 6 => TAIDEX_A :: TAIDEX_6 , 7 => TAIDEX_A :: TAIDEX_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TAIDEX_0`"]
# [inline (always)]
pub fn is_taidex_0 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_0 } # [doc = "Checks if the value of the field is `TAIDEX_1`"]
# [inline (always)]
pub fn is_taidex_1 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_1 } # [doc = "Checks if the value of the field is `TAIDEX_2`"]
# [inline (always)]
pub fn is_taidex_2 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_2 } # [doc = "Checks if the value of the field is `TAIDEX_3`"]
# [inline (always)]
pub fn is_taidex_3 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_3 } # [doc = "Checks if the value of the field is `TAIDEX_4`"]
# [inline (always)]
pub fn is_taidex_4 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_4 } # [doc = "Checks if the value of the field is `TAIDEX_5`"]
# [inline (always)]
pub fn is_taidex_5 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_5 } # [doc = "Checks if the value of the field is `TAIDEX_6`"]
# [inline (always)]
pub fn is_taidex_6 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_6 } # [doc = "Checks if the value of the field is `TAIDEX_7`"]
# [inline (always)]
pub fn is_taidex_7 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_7 } } # [doc = "Field `TAIDEX` writer - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA1EX0_SPEC , u8 , TAIDEX_A , 3 , O > ; impl < 'a , const O : u8 > TAIDEX_W < 'a , O > { # [doc = "Timer A Input divider expansion : /1"]
# [inline (always)]
pub fn taidex_0 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_0) } # [doc = "Timer A Input divider expansion : /2"]
# [inline (always)]
pub fn taidex_1 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_1) } # [doc = "Timer A Input divider expansion : /3"]
# [inline (always)]
pub fn taidex_2 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_2) } # [doc = "Timer A Input divider expansion : /4"]
# [inline (always)]
pub fn taidex_3 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_3) } # [doc = "Timer A Input divider expansion : /5"]
# [inline (always)]
pub fn taidex_4 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_4) } # [doc = "Timer A Input divider expansion : /6"]
# [inline (always)]
pub fn taidex_5 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_5) } # [doc = "Timer A Input divider expansion : /7"]
# [inline (always)]
pub fn taidex_6 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_6) } # [doc = "Timer A Input divider expansion : /8"]
# [inline (always)]
pub fn taidex_7 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_7) } } impl R { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& self) -> TAIDEX_R { TAIDEX_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& mut self) -> TAIDEX_W < 0 > { TAIDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1ex0](index.html) module"]
pub struct TA1EX0_SPEC ; impl crate :: RegisterSpec for TA1EX0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1ex0::R](R) reader structure"]
impl crate :: Readable for TA1EX0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1ex0::W](W) writer structure"]
impl crate :: Writable for TA1EX0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1EX0 to value 0"]
impl crate :: Resettable for TA1EX0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA1IV register accessor: an alias for `Reg<TA1IV_SPEC>`"]
pub type TA1IV = crate :: Reg < ta1iv :: TA1IV_SPEC > ; # [doc = "Timer1_A3 Interrupt Vector Word"]
pub mod ta1iv { # [doc = "Register `TA1IV` reader"]
pub struct R (crate :: R < TA1IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA1IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA1IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA1IV` writer"]
pub struct W (crate :: W < TA1IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA1IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA1IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA1IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer1_A3 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta1iv](index.html) module"]
pub struct TA1IV_SPEC ; impl crate :: RegisterSpec for TA1IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta1iv::R](R) reader structure"]
impl crate :: Readable for TA1IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta1iv::W](W) writer structure"]
impl crate :: Writable for TA1IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA1IV to value 0"]
impl crate :: Resettable for TA1IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Timer2_A2"]
pub struct TIMER_2_A2 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER_2_A2 { } impl TIMER_2_A2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer_2_a2 :: RegisterBlock = 0x0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer_2_a2 :: RegisterBlock { Self :: PTR } } impl Deref for TIMER_2_A2 { type Target = timer_2_a2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER_2_A2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER_2_A2") . finish () } } # [doc = "Timer2_A2"]
pub mod timer_2_a2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer2_A2 Control"]
pub ta2ctl : crate :: Reg < ta2ctl :: TA2CTL_SPEC > , # [doc = "0x02 - Timer2_A2 Capture/Compare Control 0"]
pub ta2cctl0 : crate :: Reg < ta2cctl0 :: TA2CCTL0_SPEC > , # [doc = "0x04 - Timer2_A2 Capture/Compare Control 1"]
pub ta2cctl1 : crate :: Reg < ta2cctl1 :: TA2CCTL1_SPEC > , _reserved3 : [u8 ; 0x0a]
, # [doc = "0x10 - Timer2_A2"]
pub ta2r : crate :: Reg < ta2r :: TA2R_SPEC > , # [doc = "0x12 - Timer2_A2 Capture/Compare 0"]
pub ta2ccr0 : crate :: Reg < ta2ccr0 :: TA2CCR0_SPEC > , # [doc = "0x14 - Timer2_A2 Capture/Compare 1"]
pub ta2ccr1 : crate :: Reg < ta2ccr1 :: TA2CCR1_SPEC > , _reserved6 : [u8 ; 0x0a]
, # [doc = "0x20 - Timer2_A2 Expansion Register 0"]
pub ta2ex0 : crate :: Reg < ta2ex0 :: TA2EX0_SPEC > , _reserved7 : [u8 ; 0x0c]
, # [doc = "0x2e - Timer2_A2 Interrupt Vector Word"]
pub ta2iv : crate :: Reg < ta2iv :: TA2IV_SPEC > , } # [doc = "TA2CTL register accessor: an alias for `Reg<TA2CTL_SPEC>`"]
pub type TA2CTL = crate :: Reg < ta2ctl :: TA2CTL_SPEC > ; # [doc = "Timer2_A2 Control"]
pub mod ta2ctl { # [doc = "Register `TA2CTL` reader"]
pub struct R (crate :: R < TA2CTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2CTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2CTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2CTL` writer"]
pub struct W (crate :: W < TA2CTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2CTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2CTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TAIFG` reader - Timer A counter interrupt flag"]
pub type TAIFG_R = crate :: BitReader < bool > ; # [doc = "Field `TAIFG` writer - Timer A counter interrupt flag"]
pub type TAIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CTL_SPEC , bool , O > ; # [doc = "Field `TAIE` reader - Timer A counter interrupt enable"]
pub type TAIE_R = crate :: BitReader < bool > ; # [doc = "Field `TAIE` writer - Timer A counter interrupt enable"]
pub type TAIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CTL_SPEC , bool , O > ; # [doc = "Field `TACLR` reader - Timer A counter clear"]
pub type TACLR_R = crate :: BitReader < bool > ; # [doc = "Field `TACLR` writer - Timer A counter clear"]
pub type TACLR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CTL_SPEC , bool , O > ; # [doc = "Timer A mode control 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MC_A { # [doc = "0: Timer A mode control: 0 - Stop"]
MC_0 = 0 , # [doc = "1: Timer A mode control: 1 - Up to CCR0"]
MC_1 = 1 , # [doc = "2: Timer A mode control: 2 - Continuous up"]
MC_2 = 2 , # [doc = "3: Timer A mode control: 3 - Up/Down"]
MC_3 = 3 , } impl From < MC_A > for u8 { # [inline (always)]
fn from (variant : MC_A) -> Self { variant as _ } } # [doc = "Field `MC` reader - Timer A mode control 1"]
pub type MC_R = crate :: FieldReader < u8 , MC_A > ; impl MC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MC_A { match self . bits { 0 => MC_A :: MC_0 , 1 => MC_A :: MC_1 , 2 => MC_A :: MC_2 , 3 => MC_A :: MC_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `MC_0`"]
# [inline (always)]
pub fn is_mc_0 (& self) -> bool { * self == MC_A :: MC_0 } # [doc = "Checks if the value of the field is `MC_1`"]
# [inline (always)]
pub fn is_mc_1 (& self) -> bool { * self == MC_A :: MC_1 } # [doc = "Checks if the value of the field is `MC_2`"]
# [inline (always)]
pub fn is_mc_2 (& self) -> bool { * self == MC_A :: MC_2 } # [doc = "Checks if the value of the field is `MC_3`"]
# [inline (always)]
pub fn is_mc_3 (& self) -> bool { * self == MC_A :: MC_3 } } # [doc = "Field `MC` writer - Timer A mode control 1"]
pub type MC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CTL_SPEC , u8 , MC_A , 2 , O > ; impl < 'a , const O : u8 > MC_W < 'a , O > { # [doc = "Timer A mode control: 0 - Stop"]
# [inline (always)]
pub fn mc_0 (self) -> & 'a mut W { self . variant (MC_A :: MC_0) } # [doc = "Timer A mode control: 1 - Up to CCR0"]
# [inline (always)]
pub fn mc_1 (self) -> & 'a mut W { self . variant (MC_A :: MC_1) } # [doc = "Timer A mode control: 2 - Continuous up"]
# [inline (always)]
pub fn mc_2 (self) -> & 'a mut W { self . variant (MC_A :: MC_2) } # [doc = "Timer A mode control: 3 - Up/Down"]
# [inline (always)]
pub fn mc_3 (self) -> & 'a mut W { self . variant (MC_A :: MC_3) } } # [doc = "Timer A clock input divider 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ID_A { # [doc = "0: Timer A input divider: 0 - /1"]
ID_0 = 0 , # [doc = "1: Timer A input divider: 1 - /2"]
ID_1 = 1 , # [doc = "2: Timer A input divider: 2 - /4"]
ID_2 = 2 , # [doc = "3: Timer A input divider: 3 - /8"]
ID_3 = 3 , } impl From < ID_A > for u8 { # [inline (always)]
fn from (variant : ID_A) -> Self { variant as _ } } # [doc = "Field `ID` reader - Timer A clock input divider 1"]
pub type ID_R = crate :: FieldReader < u8 , ID_A > ; impl ID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ID_A { match self . bits { 0 => ID_A :: ID_0 , 1 => ID_A :: ID_1 , 2 => ID_A :: ID_2 , 3 => ID_A :: ID_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ID_0`"]
# [inline (always)]
pub fn is_id_0 (& self) -> bool { * self == ID_A :: ID_0 } # [doc = "Checks if the value of the field is `ID_1`"]
# [inline (always)]
pub fn is_id_1 (& self) -> bool { * self == ID_A :: ID_1 } # [doc = "Checks if the value of the field is `ID_2`"]
# [inline (always)]
pub fn is_id_2 (& self) -> bool { * self == ID_A :: ID_2 } # [doc = "Checks if the value of the field is `ID_3`"]
# [inline (always)]
pub fn is_id_3 (& self) -> bool { * self == ID_A :: ID_3 } } # [doc = "Field `ID` writer - Timer A clock input divider 1"]
pub type ID_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CTL_SPEC , u8 , ID_A , 2 , O > ; impl < 'a , const O : u8 > ID_W < 'a , O > { # [doc = "Timer A input divider: 0 - /1"]
# [inline (always)]
pub fn id_0 (self) -> & 'a mut W { self . variant (ID_A :: ID_0) } # [doc = "Timer A input divider: 1 - /2"]
# [inline (always)]
pub fn id_1 (self) -> & 'a mut W { self . variant (ID_A :: ID_1) } # [doc = "Timer A input divider: 2 - /4"]
# [inline (always)]
pub fn id_2 (self) -> & 'a mut W { self . variant (ID_A :: ID_2) } # [doc = "Timer A input divider: 3 - /8"]
# [inline (always)]
pub fn id_3 (self) -> & 'a mut W { self . variant (ID_A :: ID_3) } } # [doc = "Timer A clock source select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TASSEL_A { # [doc = "0: Timer A clock source select: 0 - TACLK"]
TASSEL_0 = 0 , # [doc = "1: Timer A clock source select: 1 - ACLK"]
TASSEL_1 = 1 , # [doc = "2: Timer A clock source select: 2 - SMCLK"]
TASSEL_2 = 2 , # [doc = "3: Timer A clock source select: 3 - INCLK"]
TASSEL_3 = 3 , } impl From < TASSEL_A > for u8 { # [inline (always)]
fn from (variant : TASSEL_A) -> Self { variant as _ } } # [doc = "Field `TASSEL` reader - Timer A clock source select 1"]
pub type TASSEL_R = crate :: FieldReader < u8 , TASSEL_A > ; impl TASSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TASSEL_A { match self . bits { 0 => TASSEL_A :: TASSEL_0 , 1 => TASSEL_A :: TASSEL_1 , 2 => TASSEL_A :: TASSEL_2 , 3 => TASSEL_A :: TASSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TASSEL_0`"]
# [inline (always)]
pub fn is_tassel_0 (& self) -> bool { * self == TASSEL_A :: TASSEL_0 } # [doc = "Checks if the value of the field is `TASSEL_1`"]
# [inline (always)]
pub fn is_tassel_1 (& self) -> bool { * self == TASSEL_A :: TASSEL_1 } # [doc = "Checks if the value of the field is `TASSEL_2`"]
# [inline (always)]
pub fn is_tassel_2 (& self) -> bool { * self == TASSEL_A :: TASSEL_2 } # [doc = "Checks if the value of the field is `TASSEL_3`"]
# [inline (always)]
pub fn is_tassel_3 (& self) -> bool { * self == TASSEL_A :: TASSEL_3 } } # [doc = "Field `TASSEL` writer - Timer A clock source select 1"]
pub type TASSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CTL_SPEC , u8 , TASSEL_A , 2 , O > ; impl < 'a , const O : u8 > TASSEL_W < 'a , O > { # [doc = "Timer A clock source select: 0 - TACLK"]
# [inline (always)]
pub fn tassel_0 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_0) } # [doc = "Timer A clock source select: 1 - ACLK"]
# [inline (always)]
pub fn tassel_1 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_1) } # [doc = "Timer A clock source select: 2 - SMCLK"]
# [inline (always)]
pub fn tassel_2 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_2) } # [doc = "Timer A clock source select: 3 - INCLK"]
# [inline (always)]
pub fn tassel_3 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_3) } } impl R { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& self) -> TAIFG_R { TAIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& self) -> TAIE_R { TAIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& self) -> TACLR_R { TACLR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& self) -> MC_R { MC_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& self) -> TASSEL_R { TASSEL_R :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& mut self) -> TAIFG_W < 0 > { TAIFG_W :: new (self) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& mut self) -> TAIE_W < 1 > { TAIE_W :: new (self) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& mut self) -> TACLR_W < 2 > { TACLR_W :: new (self) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& mut self) -> MC_W < 4 > { MC_W :: new (self) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& mut self) -> ID_W < 6 > { ID_W :: new (self) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& mut self) -> TASSEL_W < 8 > { TASSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2ctl](index.html) module"]
pub struct TA2CTL_SPEC ; impl crate :: RegisterSpec for TA2CTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2ctl::R](R) reader structure"]
impl crate :: Readable for TA2CTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2ctl::W](W) writer structure"]
impl crate :: Writable for TA2CTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2CTL to value 0"]
impl crate :: Resettable for TA2CTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2CCTL0 register accessor: an alias for `Reg<TA2CCTL0_SPEC>`"]
pub type TA2CCTL0 = crate :: Reg < ta2cctl0 :: TA2CCTL0_SPEC > ; # [doc = "Timer2_A2 Capture/Compare Control 0"]
pub mod ta2cctl0 { # [doc = "Register `TA2CCTL0` reader"]
pub struct R (crate :: R < TA2CCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2CCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2CCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2CCTL0` writer"]
pub struct W (crate :: W < TA2CCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2CCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2CCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL0_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL0_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL0_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL0_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Capture/Compare Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2cctl0](index.html) module"]
pub struct TA2CCTL0_SPEC ; impl crate :: RegisterSpec for TA2CCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2cctl0::R](R) reader structure"]
impl crate :: Readable for TA2CCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2cctl0::W](W) writer structure"]
impl crate :: Writable for TA2CCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2CCTL0 to value 0"]
impl crate :: Resettable for TA2CCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2CCTL1 register accessor: an alias for `Reg<TA2CCTL1_SPEC>`"]
pub type TA2CCTL1 = crate :: Reg < ta2cctl1 :: TA2CCTL1_SPEC > ; # [doc = "Timer2_A2 Capture/Compare Control 1"]
pub mod ta2cctl1 { # [doc = "Register `TA2CCTL1` reader"]
pub struct R (crate :: R < TA2CCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2CCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2CCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2CCTL1` writer"]
pub struct W (crate :: W < TA2CCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2CCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2CCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL1_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA2CCTL1_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL1_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2CCTL1_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Capture/Compare Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2cctl1](index.html) module"]
pub struct TA2CCTL1_SPEC ; impl crate :: RegisterSpec for TA2CCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2cctl1::R](R) reader structure"]
impl crate :: Readable for TA2CCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2cctl1::W](W) writer structure"]
impl crate :: Writable for TA2CCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2CCTL1 to value 0"]
impl crate :: Resettable for TA2CCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2R register accessor: an alias for `Reg<TA2R_SPEC>`"]
pub type TA2R = crate :: Reg < ta2r :: TA2R_SPEC > ; # [doc = "Timer2_A2"]
pub mod ta2r { # [doc = "Register `TA2R` reader"]
pub struct R (crate :: R < TA2R_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2R_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2R_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2R` writer"]
pub struct W (crate :: W < TA2R_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2R_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2R_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2r](index.html) module"]
pub struct TA2R_SPEC ; impl crate :: RegisterSpec for TA2R_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2r::R](R) reader structure"]
impl crate :: Readable for TA2R_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2r::W](W) writer structure"]
impl crate :: Writable for TA2R_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2R to value 0"]
impl crate :: Resettable for TA2R_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2CCR0 register accessor: an alias for `Reg<TA2CCR0_SPEC>`"]
pub type TA2CCR0 = crate :: Reg < ta2ccr0 :: TA2CCR0_SPEC > ; # [doc = "Timer2_A2 Capture/Compare 0"]
pub mod ta2ccr0 { # [doc = "Register `TA2CCR0` reader"]
pub struct R (crate :: R < TA2CCR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2CCR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2CCR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2CCR0` writer"]
pub struct W (crate :: W < TA2CCR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2CCR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2CCR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Capture/Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2ccr0](index.html) module"]
pub struct TA2CCR0_SPEC ; impl crate :: RegisterSpec for TA2CCR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2ccr0::R](R) reader structure"]
impl crate :: Readable for TA2CCR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2ccr0::W](W) writer structure"]
impl crate :: Writable for TA2CCR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2CCR0 to value 0"]
impl crate :: Resettable for TA2CCR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2CCR1 register accessor: an alias for `Reg<TA2CCR1_SPEC>`"]
pub type TA2CCR1 = crate :: Reg < ta2ccr1 :: TA2CCR1_SPEC > ; # [doc = "Timer2_A2 Capture/Compare 1"]
pub mod ta2ccr1 { # [doc = "Register `TA2CCR1` reader"]
pub struct R (crate :: R < TA2CCR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2CCR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2CCR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2CCR1` writer"]
pub struct W (crate :: W < TA2CCR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2CCR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2CCR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Capture/Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2ccr1](index.html) module"]
pub struct TA2CCR1_SPEC ; impl crate :: RegisterSpec for TA2CCR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2ccr1::R](R) reader structure"]
impl crate :: Readable for TA2CCR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2ccr1::W](W) writer structure"]
impl crate :: Writable for TA2CCR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2CCR1 to value 0"]
impl crate :: Resettable for TA2CCR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2EX0 register accessor: an alias for `Reg<TA2EX0_SPEC>`"]
pub type TA2EX0 = crate :: Reg < ta2ex0 :: TA2EX0_SPEC > ; # [doc = "Timer2_A2 Expansion Register 0"]
pub mod ta2ex0 { # [doc = "Register `TA2EX0` reader"]
pub struct R (crate :: R < TA2EX0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2EX0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2EX0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2EX0` writer"]
pub struct W (crate :: W < TA2EX0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2EX0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2EX0_SPEC >) -> Self { W (writer) } } # [doc = "Timer A Input divider expansion Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TAIDEX_A { # [doc = "0: Timer A Input divider expansion : /1"]
TAIDEX_0 = 0 , # [doc = "1: Timer A Input divider expansion : /2"]
TAIDEX_1 = 1 , # [doc = "2: Timer A Input divider expansion : /3"]
TAIDEX_2 = 2 , # [doc = "3: Timer A Input divider expansion : /4"]
TAIDEX_3 = 3 , # [doc = "4: Timer A Input divider expansion : /5"]
TAIDEX_4 = 4 , # [doc = "5: Timer A Input divider expansion : /6"]
TAIDEX_5 = 5 , # [doc = "6: Timer A Input divider expansion : /7"]
TAIDEX_6 = 6 , # [doc = "7: Timer A Input divider expansion : /8"]
TAIDEX_7 = 7 , } impl From < TAIDEX_A > for u8 { # [inline (always)]
fn from (variant : TAIDEX_A) -> Self { variant as _ } } # [doc = "Field `TAIDEX` reader - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_R = crate :: FieldReader < u8 , TAIDEX_A > ; impl TAIDEX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TAIDEX_A { match self . bits { 0 => TAIDEX_A :: TAIDEX_0 , 1 => TAIDEX_A :: TAIDEX_1 , 2 => TAIDEX_A :: TAIDEX_2 , 3 => TAIDEX_A :: TAIDEX_3 , 4 => TAIDEX_A :: TAIDEX_4 , 5 => TAIDEX_A :: TAIDEX_5 , 6 => TAIDEX_A :: TAIDEX_6 , 7 => TAIDEX_A :: TAIDEX_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TAIDEX_0`"]
# [inline (always)]
pub fn is_taidex_0 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_0 } # [doc = "Checks if the value of the field is `TAIDEX_1`"]
# [inline (always)]
pub fn is_taidex_1 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_1 } # [doc = "Checks if the value of the field is `TAIDEX_2`"]
# [inline (always)]
pub fn is_taidex_2 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_2 } # [doc = "Checks if the value of the field is `TAIDEX_3`"]
# [inline (always)]
pub fn is_taidex_3 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_3 } # [doc = "Checks if the value of the field is `TAIDEX_4`"]
# [inline (always)]
pub fn is_taidex_4 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_4 } # [doc = "Checks if the value of the field is `TAIDEX_5`"]
# [inline (always)]
pub fn is_taidex_5 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_5 } # [doc = "Checks if the value of the field is `TAIDEX_6`"]
# [inline (always)]
pub fn is_taidex_6 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_6 } # [doc = "Checks if the value of the field is `TAIDEX_7`"]
# [inline (always)]
pub fn is_taidex_7 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_7 } } # [doc = "Field `TAIDEX` writer - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA2EX0_SPEC , u8 , TAIDEX_A , 3 , O > ; impl < 'a , const O : u8 > TAIDEX_W < 'a , O > { # [doc = "Timer A Input divider expansion : /1"]
# [inline (always)]
pub fn taidex_0 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_0) } # [doc = "Timer A Input divider expansion : /2"]
# [inline (always)]
pub fn taidex_1 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_1) } # [doc = "Timer A Input divider expansion : /3"]
# [inline (always)]
pub fn taidex_2 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_2) } # [doc = "Timer A Input divider expansion : /4"]
# [inline (always)]
pub fn taidex_3 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_3) } # [doc = "Timer A Input divider expansion : /5"]
# [inline (always)]
pub fn taidex_4 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_4) } # [doc = "Timer A Input divider expansion : /6"]
# [inline (always)]
pub fn taidex_5 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_5) } # [doc = "Timer A Input divider expansion : /7"]
# [inline (always)]
pub fn taidex_6 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_6) } # [doc = "Timer A Input divider expansion : /8"]
# [inline (always)]
pub fn taidex_7 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_7) } } impl R { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& self) -> TAIDEX_R { TAIDEX_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& mut self) -> TAIDEX_W < 0 > { TAIDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2ex0](index.html) module"]
pub struct TA2EX0_SPEC ; impl crate :: RegisterSpec for TA2EX0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2ex0::R](R) reader structure"]
impl crate :: Readable for TA2EX0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2ex0::W](W) writer structure"]
impl crate :: Writable for TA2EX0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2EX0 to value 0"]
impl crate :: Resettable for TA2EX0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA2IV register accessor: an alias for `Reg<TA2IV_SPEC>`"]
pub type TA2IV = crate :: Reg < ta2iv :: TA2IV_SPEC > ; # [doc = "Timer2_A2 Interrupt Vector Word"]
pub mod ta2iv { # [doc = "Register `TA2IV` reader"]
pub struct R (crate :: R < TA2IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA2IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA2IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA2IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA2IV` writer"]
pub struct W (crate :: W < TA2IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA2IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA2IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA2IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer2_A2 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta2iv](index.html) module"]
pub struct TA2IV_SPEC ; impl crate :: RegisterSpec for TA2IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta2iv::R](R) reader structure"]
impl crate :: Readable for TA2IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta2iv::W](W) writer structure"]
impl crate :: Writable for TA2IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA2IV to value 0"]
impl crate :: Resettable for TA2IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Timer3_A2"]
pub struct TIMER_3_A2 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER_3_A2 { } impl TIMER_3_A2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer_3_a2 :: RegisterBlock = 0x0440 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer_3_a2 :: RegisterBlock { Self :: PTR } } impl Deref for TIMER_3_A2 { type Target = timer_3_a2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER_3_A2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER_3_A2") . finish () } } # [doc = "Timer3_A2"]
pub mod timer_3_a2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer3_A2 Control"]
pub ta3ctl : crate :: Reg < ta3ctl :: TA3CTL_SPEC > , # [doc = "0x02 - Timer3_A2 Capture/Compare Control 0"]
pub ta3cctl0 : crate :: Reg < ta3cctl0 :: TA3CCTL0_SPEC > , # [doc = "0x04 - Timer3_A2 Capture/Compare Control 1"]
pub ta3cctl1 : crate :: Reg < ta3cctl1 :: TA3CCTL1_SPEC > , _reserved3 : [u8 ; 0x0a]
, # [doc = "0x10 - Timer3_A2"]
pub ta3r : crate :: Reg < ta3r :: TA3R_SPEC > , # [doc = "0x12 - Timer3_A2 Capture/Compare 0"]
pub ta3ccr0 : crate :: Reg < ta3ccr0 :: TA3CCR0_SPEC > , # [doc = "0x14 - Timer3_A2 Capture/Compare 1"]
pub ta3ccr1 : crate :: Reg < ta3ccr1 :: TA3CCR1_SPEC > , _reserved6 : [u8 ; 0x0a]
, # [doc = "0x20 - Timer3_A2 Expansion Register 0"]
pub ta3ex0 : crate :: Reg < ta3ex0 :: TA3EX0_SPEC > , _reserved7 : [u8 ; 0x0c]
, # [doc = "0x2e - Timer3_A2 Interrupt Vector Word"]
pub ta3iv : crate :: Reg < ta3iv :: TA3IV_SPEC > , } # [doc = "TA3CTL register accessor: an alias for `Reg<TA3CTL_SPEC>`"]
pub type TA3CTL = crate :: Reg < ta3ctl :: TA3CTL_SPEC > ; # [doc = "Timer3_A2 Control"]
pub mod ta3ctl { # [doc = "Register `TA3CTL` reader"]
pub struct R (crate :: R < TA3CTL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3CTL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3CTL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3CTL` writer"]
pub struct W (crate :: W < TA3CTL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3CTL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3CTL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3CTL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TAIFG` reader - Timer A counter interrupt flag"]
pub type TAIFG_R = crate :: BitReader < bool > ; # [doc = "Field `TAIFG` writer - Timer A counter interrupt flag"]
pub type TAIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CTL_SPEC , bool , O > ; # [doc = "Field `TAIE` reader - Timer A counter interrupt enable"]
pub type TAIE_R = crate :: BitReader < bool > ; # [doc = "Field `TAIE` writer - Timer A counter interrupt enable"]
pub type TAIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CTL_SPEC , bool , O > ; # [doc = "Field `TACLR` reader - Timer A counter clear"]
pub type TACLR_R = crate :: BitReader < bool > ; # [doc = "Field `TACLR` writer - Timer A counter clear"]
pub type TACLR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CTL_SPEC , bool , O > ; # [doc = "Timer A mode control 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MC_A { # [doc = "0: Timer A mode control: 0 - Stop"]
MC_0 = 0 , # [doc = "1: Timer A mode control: 1 - Up to CCR0"]
MC_1 = 1 , # [doc = "2: Timer A mode control: 2 - Continuous up"]
MC_2 = 2 , # [doc = "3: Timer A mode control: 3 - Up/Down"]
MC_3 = 3 , } impl From < MC_A > for u8 { # [inline (always)]
fn from (variant : MC_A) -> Self { variant as _ } } # [doc = "Field `MC` reader - Timer A mode control 1"]
pub type MC_R = crate :: FieldReader < u8 , MC_A > ; impl MC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MC_A { match self . bits { 0 => MC_A :: MC_0 , 1 => MC_A :: MC_1 , 2 => MC_A :: MC_2 , 3 => MC_A :: MC_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `MC_0`"]
# [inline (always)]
pub fn is_mc_0 (& self) -> bool { * self == MC_A :: MC_0 } # [doc = "Checks if the value of the field is `MC_1`"]
# [inline (always)]
pub fn is_mc_1 (& self) -> bool { * self == MC_A :: MC_1 } # [doc = "Checks if the value of the field is `MC_2`"]
# [inline (always)]
pub fn is_mc_2 (& self) -> bool { * self == MC_A :: MC_2 } # [doc = "Checks if the value of the field is `MC_3`"]
# [inline (always)]
pub fn is_mc_3 (& self) -> bool { * self == MC_A :: MC_3 } } # [doc = "Field `MC` writer - Timer A mode control 1"]
pub type MC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CTL_SPEC , u8 , MC_A , 2 , O > ; impl < 'a , const O : u8 > MC_W < 'a , O > { # [doc = "Timer A mode control: 0 - Stop"]
# [inline (always)]
pub fn mc_0 (self) -> & 'a mut W { self . variant (MC_A :: MC_0) } # [doc = "Timer A mode control: 1 - Up to CCR0"]
# [inline (always)]
pub fn mc_1 (self) -> & 'a mut W { self . variant (MC_A :: MC_1) } # [doc = "Timer A mode control: 2 - Continuous up"]
# [inline (always)]
pub fn mc_2 (self) -> & 'a mut W { self . variant (MC_A :: MC_2) } # [doc = "Timer A mode control: 3 - Up/Down"]
# [inline (always)]
pub fn mc_3 (self) -> & 'a mut W { self . variant (MC_A :: MC_3) } } # [doc = "Timer A clock input divider 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ID_A { # [doc = "0: Timer A input divider: 0 - /1"]
ID_0 = 0 , # [doc = "1: Timer A input divider: 1 - /2"]
ID_1 = 1 , # [doc = "2: Timer A input divider: 2 - /4"]
ID_2 = 2 , # [doc = "3: Timer A input divider: 3 - /8"]
ID_3 = 3 , } impl From < ID_A > for u8 { # [inline (always)]
fn from (variant : ID_A) -> Self { variant as _ } } # [doc = "Field `ID` reader - Timer A clock input divider 1"]
pub type ID_R = crate :: FieldReader < u8 , ID_A > ; impl ID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ID_A { match self . bits { 0 => ID_A :: ID_0 , 1 => ID_A :: ID_1 , 2 => ID_A :: ID_2 , 3 => ID_A :: ID_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ID_0`"]
# [inline (always)]
pub fn is_id_0 (& self) -> bool { * self == ID_A :: ID_0 } # [doc = "Checks if the value of the field is `ID_1`"]
# [inline (always)]
pub fn is_id_1 (& self) -> bool { * self == ID_A :: ID_1 } # [doc = "Checks if the value of the field is `ID_2`"]
# [inline (always)]
pub fn is_id_2 (& self) -> bool { * self == ID_A :: ID_2 } # [doc = "Checks if the value of the field is `ID_3`"]
# [inline (always)]
pub fn is_id_3 (& self) -> bool { * self == ID_A :: ID_3 } } # [doc = "Field `ID` writer - Timer A clock input divider 1"]
pub type ID_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CTL_SPEC , u8 , ID_A , 2 , O > ; impl < 'a , const O : u8 > ID_W < 'a , O > { # [doc = "Timer A input divider: 0 - /1"]
# [inline (always)]
pub fn id_0 (self) -> & 'a mut W { self . variant (ID_A :: ID_0) } # [doc = "Timer A input divider: 1 - /2"]
# [inline (always)]
pub fn id_1 (self) -> & 'a mut W { self . variant (ID_A :: ID_1) } # [doc = "Timer A input divider: 2 - /4"]
# [inline (always)]
pub fn id_2 (self) -> & 'a mut W { self . variant (ID_A :: ID_2) } # [doc = "Timer A input divider: 3 - /8"]
# [inline (always)]
pub fn id_3 (self) -> & 'a mut W { self . variant (ID_A :: ID_3) } } # [doc = "Timer A clock source select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TASSEL_A { # [doc = "0: Timer A clock source select: 0 - TACLK"]
TASSEL_0 = 0 , # [doc = "1: Timer A clock source select: 1 - ACLK"]
TASSEL_1 = 1 , # [doc = "2: Timer A clock source select: 2 - SMCLK"]
TASSEL_2 = 2 , # [doc = "3: Timer A clock source select: 3 - INCLK"]
TASSEL_3 = 3 , } impl From < TASSEL_A > for u8 { # [inline (always)]
fn from (variant : TASSEL_A) -> Self { variant as _ } } # [doc = "Field `TASSEL` reader - Timer A clock source select 1"]
pub type TASSEL_R = crate :: FieldReader < u8 , TASSEL_A > ; impl TASSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TASSEL_A { match self . bits { 0 => TASSEL_A :: TASSEL_0 , 1 => TASSEL_A :: TASSEL_1 , 2 => TASSEL_A :: TASSEL_2 , 3 => TASSEL_A :: TASSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TASSEL_0`"]
# [inline (always)]
pub fn is_tassel_0 (& self) -> bool { * self == TASSEL_A :: TASSEL_0 } # [doc = "Checks if the value of the field is `TASSEL_1`"]
# [inline (always)]
pub fn is_tassel_1 (& self) -> bool { * self == TASSEL_A :: TASSEL_1 } # [doc = "Checks if the value of the field is `TASSEL_2`"]
# [inline (always)]
pub fn is_tassel_2 (& self) -> bool { * self == TASSEL_A :: TASSEL_2 } # [doc = "Checks if the value of the field is `TASSEL_3`"]
# [inline (always)]
pub fn is_tassel_3 (& self) -> bool { * self == TASSEL_A :: TASSEL_3 } } # [doc = "Field `TASSEL` writer - Timer A clock source select 1"]
pub type TASSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CTL_SPEC , u8 , TASSEL_A , 2 , O > ; impl < 'a , const O : u8 > TASSEL_W < 'a , O > { # [doc = "Timer A clock source select: 0 - TACLK"]
# [inline (always)]
pub fn tassel_0 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_0) } # [doc = "Timer A clock source select: 1 - ACLK"]
# [inline (always)]
pub fn tassel_1 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_1) } # [doc = "Timer A clock source select: 2 - SMCLK"]
# [inline (always)]
pub fn tassel_2 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_2) } # [doc = "Timer A clock source select: 3 - INCLK"]
# [inline (always)]
pub fn tassel_3 (self) -> & 'a mut W { self . variant (TASSEL_A :: TASSEL_3) } } impl R { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& self) -> TAIFG_R { TAIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& self) -> TAIE_R { TAIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& self) -> TACLR_R { TACLR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& self) -> MC_R { MC_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& self) -> TASSEL_R { TASSEL_R :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 0 - Timer A counter interrupt flag"]
# [inline (always)]
pub fn taifg (& mut self) -> TAIFG_W < 0 > { TAIFG_W :: new (self) } # [doc = "Bit 1 - Timer A counter interrupt enable"]
# [inline (always)]
pub fn taie (& mut self) -> TAIE_W < 1 > { TAIE_W :: new (self) } # [doc = "Bit 2 - Timer A counter clear"]
# [inline (always)]
pub fn taclr (& mut self) -> TACLR_W < 2 > { TACLR_W :: new (self) } # [doc = "Bits 4:5 - Timer A mode control 1"]
# [inline (always)]
pub fn mc (& mut self) -> MC_W < 4 > { MC_W :: new (self) } # [doc = "Bits 6:7 - Timer A clock input divider 1"]
# [inline (always)]
pub fn id (& mut self) -> ID_W < 6 > { ID_W :: new (self) } # [doc = "Bits 8:9 - Timer A clock source select 1"]
# [inline (always)]
pub fn tassel (& mut self) -> TASSEL_W < 8 > { TASSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3ctl](index.html) module"]
pub struct TA3CTL_SPEC ; impl crate :: RegisterSpec for TA3CTL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3ctl::R](R) reader structure"]
impl crate :: Readable for TA3CTL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3ctl::W](W) writer structure"]
impl crate :: Writable for TA3CTL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3CTL to value 0"]
impl crate :: Resettable for TA3CTL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3CCTL0 register accessor: an alias for `Reg<TA3CCTL0_SPEC>`"]
pub type TA3CCTL0 = crate :: Reg < ta3cctl0 :: TA3CCTL0_SPEC > ; # [doc = "Timer3_A2 Capture/Compare Control 0"]
pub mod ta3cctl0 { # [doc = "Register `TA3CCTL0` reader"]
pub struct R (crate :: R < TA3CCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3CCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3CCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3CCTL0` writer"]
pub struct W (crate :: W < TA3CCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3CCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3CCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3CCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL0_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL0_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL0_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL0_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Capture/Compare Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3cctl0](index.html) module"]
pub struct TA3CCTL0_SPEC ; impl crate :: RegisterSpec for TA3CCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3cctl0::R](R) reader structure"]
impl crate :: Readable for TA3CCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3cctl0::W](W) writer structure"]
impl crate :: Writable for TA3CCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3CCTL0 to value 0"]
impl crate :: Resettable for TA3CCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3CCTL1 register accessor: an alias for `Reg<TA3CCTL1_SPEC>`"]
pub type TA3CCTL1 = crate :: Reg < ta3cctl1 :: TA3CCTL1_SPEC > ; # [doc = "Timer3_A2 Capture/Compare Control 1"]
pub mod ta3cctl1 { # [doc = "Register `TA3CCTL1` reader"]
pub struct R (crate :: R < TA3CCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3CCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3CCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3CCTL1` writer"]
pub struct W (crate :: W < TA3CCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3CCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3CCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3CCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
pub type CCIFG_R = crate :: BitReader < bool > ; # [doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
pub type CCIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `COV` reader - Capture/compare overflow flag"]
pub type COV_R = crate :: BitReader < bool > ; # [doc = "Field `COV` writer - Capture/compare overflow flag"]
pub type COV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
pub type OUT_R = crate :: BitReader < bool > ; # [doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
pub type OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `CCI` reader - Capture input signal (read)"]
pub type CCI_R = crate :: BitReader < bool > ; # [doc = "Field `CCI` writer - Capture input signal (read)"]
pub type CCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
pub type CCIE_R = crate :: BitReader < bool > ; # [doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
pub type CCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Output mode 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUTMOD_A { # [doc = "0: PWM output mode: 0 - output only"]
OUTMOD_0 = 0 , # [doc = "1: PWM output mode: 1 - set"]
OUTMOD_1 = 1 , # [doc = "2: PWM output mode: 2 - PWM toggle/reset"]
OUTMOD_2 = 2 , # [doc = "3: PWM output mode: 3 - PWM set/reset"]
OUTMOD_3 = 3 , # [doc = "4: PWM output mode: 4 - toggle"]
OUTMOD_4 = 4 , # [doc = "5: PWM output mode: 5 - Reset"]
OUTMOD_5 = 5 , # [doc = "6: PWM output mode: 6 - PWM toggle/set"]
OUTMOD_6 = 6 , # [doc = "7: PWM output mode: 7 - PWM reset/set"]
OUTMOD_7 = 7 , } impl From < OUTMOD_A > for u8 { # [inline (always)]
fn from (variant : OUTMOD_A) -> Self { variant as _ } } # [doc = "Field `OUTMOD` reader - Output mode 2"]
pub type OUTMOD_R = crate :: FieldReader < u8 , OUTMOD_A > ; impl OUTMOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OUTMOD_A { match self . bits { 0 => OUTMOD_A :: OUTMOD_0 , 1 => OUTMOD_A :: OUTMOD_1 , 2 => OUTMOD_A :: OUTMOD_2 , 3 => OUTMOD_A :: OUTMOD_3 , 4 => OUTMOD_A :: OUTMOD_4 , 5 => OUTMOD_A :: OUTMOD_5 , 6 => OUTMOD_A :: OUTMOD_6 , 7 => OUTMOD_A :: OUTMOD_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OUTMOD_0`"]
# [inline (always)]
pub fn is_outmod_0 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_0 } # [doc = "Checks if the value of the field is `OUTMOD_1`"]
# [inline (always)]
pub fn is_outmod_1 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_1 } # [doc = "Checks if the value of the field is `OUTMOD_2`"]
# [inline (always)]
pub fn is_outmod_2 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_2 } # [doc = "Checks if the value of the field is `OUTMOD_3`"]
# [inline (always)]
pub fn is_outmod_3 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_3 } # [doc = "Checks if the value of the field is `OUTMOD_4`"]
# [inline (always)]
pub fn is_outmod_4 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_4 } # [doc = "Checks if the value of the field is `OUTMOD_5`"]
# [inline (always)]
pub fn is_outmod_5 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_5 } # [doc = "Checks if the value of the field is `OUTMOD_6`"]
# [inline (always)]
pub fn is_outmod_6 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_6 } # [doc = "Checks if the value of the field is `OUTMOD_7`"]
# [inline (always)]
pub fn is_outmod_7 (& self) -> bool { * self == OUTMOD_A :: OUTMOD_7 } } # [doc = "Field `OUTMOD` writer - Output mode 2"]
pub type OUTMOD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL1_SPEC , u8 , OUTMOD_A , 3 , O > ; impl < 'a , const O : u8 > OUTMOD_W < 'a , O > { # [doc = "PWM output mode: 0 - output only"]
# [inline (always)]
pub fn outmod_0 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_0) } # [doc = "PWM output mode: 1 - set"]
# [inline (always)]
pub fn outmod_1 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_1) } # [doc = "PWM output mode: 2 - PWM toggle/reset"]
# [inline (always)]
pub fn outmod_2 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_2) } # [doc = "PWM output mode: 3 - PWM set/reset"]
# [inline (always)]
pub fn outmod_3 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_3) } # [doc = "PWM output mode: 4 - toggle"]
# [inline (always)]
pub fn outmod_4 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_4) } # [doc = "PWM output mode: 5 - Reset"]
# [inline (always)]
pub fn outmod_5 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_5) } # [doc = "PWM output mode: 6 - PWM toggle/set"]
# [inline (always)]
pub fn outmod_6 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_6) } # [doc = "PWM output mode: 7 - PWM reset/set"]
# [inline (always)]
pub fn outmod_7 (self) -> & 'a mut W { self . variant (OUTMOD_A :: OUTMOD_7) } } # [doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
pub type CAP_R = crate :: BitReader < bool > ; # [doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
pub type CAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `SCCI` reader - Latched capture signal (read)"]
pub type SCCI_R = crate :: BitReader < bool > ; # [doc = "Field `SCCI` writer - Latched capture signal (read)"]
pub type SCCI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Field `SCS` reader - Capture sychronize"]
pub type SCS_R = crate :: BitReader < bool > ; # [doc = "Field `SCS` writer - Capture sychronize"]
pub type SCS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , TA3CCTL1_SPEC , bool , O > ; # [doc = "Capture input select 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CCIS_A { # [doc = "0: Capture input select: 0 - CCIxA"]
CCIS_0 = 0 , # [doc = "1: Capture input select: 1 - CCIxB"]
CCIS_1 = 1 , # [doc = "2: Capture input select: 2 - GND"]
CCIS_2 = 2 , # [doc = "3: Capture input select: 3 - Vcc"]
CCIS_3 = 3 , } impl From < CCIS_A > for u8 { # [inline (always)]
fn from (variant : CCIS_A) -> Self { variant as _ } } # [doc = "Field `CCIS` reader - Capture input select 1"]
pub type CCIS_R = crate :: FieldReader < u8 , CCIS_A > ; impl CCIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCIS_A { match self . bits { 0 => CCIS_A :: CCIS_0 , 1 => CCIS_A :: CCIS_1 , 2 => CCIS_A :: CCIS_2 , 3 => CCIS_A :: CCIS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCIS_0`"]
# [inline (always)]
pub fn is_ccis_0 (& self) -> bool { * self == CCIS_A :: CCIS_0 } # [doc = "Checks if the value of the field is `CCIS_1`"]
# [inline (always)]
pub fn is_ccis_1 (& self) -> bool { * self == CCIS_A :: CCIS_1 } # [doc = "Checks if the value of the field is `CCIS_2`"]
# [inline (always)]
pub fn is_ccis_2 (& self) -> bool { * self == CCIS_A :: CCIS_2 } # [doc = "Checks if the value of the field is `CCIS_3`"]
# [inline (always)]
pub fn is_ccis_3 (& self) -> bool { * self == CCIS_A :: CCIS_3 } } # [doc = "Field `CCIS` writer - Capture input select 1"]
pub type CCIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL1_SPEC , u8 , CCIS_A , 2 , O > ; impl < 'a , const O : u8 > CCIS_W < 'a , O > { # [doc = "Capture input select: 0 - CCIxA"]
# [inline (always)]
pub fn ccis_0 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_0) } # [doc = "Capture input select: 1 - CCIxB"]
# [inline (always)]
pub fn ccis_1 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_1) } # [doc = "Capture input select: 2 - GND"]
# [inline (always)]
pub fn ccis_2 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_2) } # [doc = "Capture input select: 3 - Vcc"]
# [inline (always)]
pub fn ccis_3 (self) -> & 'a mut W { self . variant (CCIS_A :: CCIS_3) } } # [doc = "Capture mode 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CM_A { # [doc = "0: Capture mode: 0 - disabled"]
CM_0 = 0 , # [doc = "1: Capture mode: 1 - pos. edge"]
CM_1 = 1 , # [doc = "2: Capture mode: 1 - neg. edge"]
CM_2 = 2 , # [doc = "3: Capture mode: 1 - both edges"]
CM_3 = 3 , } impl From < CM_A > for u8 { # [inline (always)]
fn from (variant : CM_A) -> Self { variant as _ } } # [doc = "Field `CM` reader - Capture mode 1"]
pub type CM_R = crate :: FieldReader < u8 , CM_A > ; impl CM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CM_A { match self . bits { 0 => CM_A :: CM_0 , 1 => CM_A :: CM_1 , 2 => CM_A :: CM_2 , 3 => CM_A :: CM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CM_0`"]
# [inline (always)]
pub fn is_cm_0 (& self) -> bool { * self == CM_A :: CM_0 } # [doc = "Checks if the value of the field is `CM_1`"]
# [inline (always)]
pub fn is_cm_1 (& self) -> bool { * self == CM_A :: CM_1 } # [doc = "Checks if the value of the field is `CM_2`"]
# [inline (always)]
pub fn is_cm_2 (& self) -> bool { * self == CM_A :: CM_2 } # [doc = "Checks if the value of the field is `CM_3`"]
# [inline (always)]
pub fn is_cm_3 (& self) -> bool { * self == CM_A :: CM_3 } } # [doc = "Field `CM` writer - Capture mode 1"]
pub type CM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3CCTL1_SPEC , u8 , CM_A , 2 , O > ; impl < 'a , const O : u8 > CM_W < 'a , O > { # [doc = "Capture mode: 0 - disabled"]
# [inline (always)]
pub fn cm_0 (self) -> & 'a mut W { self . variant (CM_A :: CM_0) } # [doc = "Capture mode: 1 - pos. edge"]
# [inline (always)]
pub fn cm_1 (self) -> & 'a mut W { self . variant (CM_A :: CM_1) } # [doc = "Capture mode: 1 - neg. edge"]
# [inline (always)]
pub fn cm_2 (self) -> & 'a mut W { self . variant (CM_A :: CM_2) } # [doc = "Capture mode: 1 - both edges"]
# [inline (always)]
pub fn cm_3 (self) -> & 'a mut W { self . variant (CM_A :: CM_3) } } impl R { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& self) -> CCIFG_R { CCIFG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& self) -> COV_R { COV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& self) -> CCI_R { CCI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& self) -> CCIE_R { CCIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& self) -> OUTMOD_R { OUTMOD_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& self) -> CAP_R { CAP_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& self) -> SCCI_R { SCCI_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& self) -> SCS_R { SCS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& self) -> CCIS_R { CCIS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& self) -> CM_R { CM_R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bit 0 - Capture/compare interrupt flag"]
# [inline (always)]
pub fn ccifg (& mut self) -> CCIFG_W < 0 > { CCIFG_W :: new (self) } # [doc = "Bit 1 - Capture/compare overflow flag"]
# [inline (always)]
pub fn cov (& mut self) -> COV_W < 1 > { COV_W :: new (self) } # [doc = "Bit 2 - PWM Output signal if output mode 0"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W < 2 > { OUT_W :: new (self) } # [doc = "Bit 3 - Capture input signal (read)"]
# [inline (always)]
pub fn cci (& mut self) -> CCI_W < 3 > { CCI_W :: new (self) } # [doc = "Bit 4 - Capture/compare interrupt enable"]
# [inline (always)]
pub fn ccie (& mut self) -> CCIE_W < 4 > { CCIE_W :: new (self) } # [doc = "Bits 5:7 - Output mode 2"]
# [inline (always)]
pub fn outmod (& mut self) -> OUTMOD_W < 5 > { OUTMOD_W :: new (self) } # [doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
# [inline (always)]
pub fn cap (& mut self) -> CAP_W < 8 > { CAP_W :: new (self) } # [doc = "Bit 10 - Latched capture signal (read)"]
# [inline (always)]
pub fn scci (& mut self) -> SCCI_W < 10 > { SCCI_W :: new (self) } # [doc = "Bit 11 - Capture sychronize"]
# [inline (always)]
pub fn scs (& mut self) -> SCS_W < 11 > { SCS_W :: new (self) } # [doc = "Bits 12:13 - Capture input select 1"]
# [inline (always)]
pub fn ccis (& mut self) -> CCIS_W < 12 > { CCIS_W :: new (self) } # [doc = "Bits 14:15 - Capture mode 1"]
# [inline (always)]
pub fn cm (& mut self) -> CM_W < 14 > { CM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Capture/Compare Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3cctl1](index.html) module"]
pub struct TA3CCTL1_SPEC ; impl crate :: RegisterSpec for TA3CCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3cctl1::R](R) reader structure"]
impl crate :: Readable for TA3CCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3cctl1::W](W) writer structure"]
impl crate :: Writable for TA3CCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3CCTL1 to value 0"]
impl crate :: Resettable for TA3CCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3R register accessor: an alias for `Reg<TA3R_SPEC>`"]
pub type TA3R = crate :: Reg < ta3r :: TA3R_SPEC > ; # [doc = "Timer3_A2"]
pub mod ta3r { # [doc = "Register `TA3R` reader"]
pub struct R (crate :: R < TA3R_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3R_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3R_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3R` writer"]
pub struct W (crate :: W < TA3R_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3R_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3R_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3R_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3r](index.html) module"]
pub struct TA3R_SPEC ; impl crate :: RegisterSpec for TA3R_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3r::R](R) reader structure"]
impl crate :: Readable for TA3R_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3r::W](W) writer structure"]
impl crate :: Writable for TA3R_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3R to value 0"]
impl crate :: Resettable for TA3R_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3CCR0 register accessor: an alias for `Reg<TA3CCR0_SPEC>`"]
pub type TA3CCR0 = crate :: Reg < ta3ccr0 :: TA3CCR0_SPEC > ; # [doc = "Timer3_A2 Capture/Compare 0"]
pub mod ta3ccr0 { # [doc = "Register `TA3CCR0` reader"]
pub struct R (crate :: R < TA3CCR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3CCR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3CCR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3CCR0` writer"]
pub struct W (crate :: W < TA3CCR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3CCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3CCR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3CCR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Capture/Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3ccr0](index.html) module"]
pub struct TA3CCR0_SPEC ; impl crate :: RegisterSpec for TA3CCR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3ccr0::R](R) reader structure"]
impl crate :: Readable for TA3CCR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3ccr0::W](W) writer structure"]
impl crate :: Writable for TA3CCR0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3CCR0 to value 0"]
impl crate :: Resettable for TA3CCR0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3CCR1 register accessor: an alias for `Reg<TA3CCR1_SPEC>`"]
pub type TA3CCR1 = crate :: Reg < ta3ccr1 :: TA3CCR1_SPEC > ; # [doc = "Timer3_A2 Capture/Compare 1"]
pub mod ta3ccr1 { # [doc = "Register `TA3CCR1` reader"]
pub struct R (crate :: R < TA3CCR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3CCR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3CCR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3CCR1` writer"]
pub struct W (crate :: W < TA3CCR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3CCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3CCR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3CCR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Capture/Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3ccr1](index.html) module"]
pub struct TA3CCR1_SPEC ; impl crate :: RegisterSpec for TA3CCR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3ccr1::R](R) reader structure"]
impl crate :: Readable for TA3CCR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3ccr1::W](W) writer structure"]
impl crate :: Writable for TA3CCR1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3CCR1 to value 0"]
impl crate :: Resettable for TA3CCR1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3EX0 register accessor: an alias for `Reg<TA3EX0_SPEC>`"]
pub type TA3EX0 = crate :: Reg < ta3ex0 :: TA3EX0_SPEC > ; # [doc = "Timer3_A2 Expansion Register 0"]
pub mod ta3ex0 { # [doc = "Register `TA3EX0` reader"]
pub struct R (crate :: R < TA3EX0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3EX0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3EX0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3EX0` writer"]
pub struct W (crate :: W < TA3EX0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3EX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3EX0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3EX0_SPEC >) -> Self { W (writer) } } # [doc = "Timer A Input divider expansion Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TAIDEX_A { # [doc = "0: Timer A Input divider expansion : /1"]
TAIDEX_0 = 0 , # [doc = "1: Timer A Input divider expansion : /2"]
TAIDEX_1 = 1 , # [doc = "2: Timer A Input divider expansion : /3"]
TAIDEX_2 = 2 , # [doc = "3: Timer A Input divider expansion : /4"]
TAIDEX_3 = 3 , # [doc = "4: Timer A Input divider expansion : /5"]
TAIDEX_4 = 4 , # [doc = "5: Timer A Input divider expansion : /6"]
TAIDEX_5 = 5 , # [doc = "6: Timer A Input divider expansion : /7"]
TAIDEX_6 = 6 , # [doc = "7: Timer A Input divider expansion : /8"]
TAIDEX_7 = 7 , } impl From < TAIDEX_A > for u8 { # [inline (always)]
fn from (variant : TAIDEX_A) -> Self { variant as _ } } # [doc = "Field `TAIDEX` reader - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_R = crate :: FieldReader < u8 , TAIDEX_A > ; impl TAIDEX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TAIDEX_A { match self . bits { 0 => TAIDEX_A :: TAIDEX_0 , 1 => TAIDEX_A :: TAIDEX_1 , 2 => TAIDEX_A :: TAIDEX_2 , 3 => TAIDEX_A :: TAIDEX_3 , 4 => TAIDEX_A :: TAIDEX_4 , 5 => TAIDEX_A :: TAIDEX_5 , 6 => TAIDEX_A :: TAIDEX_6 , 7 => TAIDEX_A :: TAIDEX_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TAIDEX_0`"]
# [inline (always)]
pub fn is_taidex_0 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_0 } # [doc = "Checks if the value of the field is `TAIDEX_1`"]
# [inline (always)]
pub fn is_taidex_1 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_1 } # [doc = "Checks if the value of the field is `TAIDEX_2`"]
# [inline (always)]
pub fn is_taidex_2 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_2 } # [doc = "Checks if the value of the field is `TAIDEX_3`"]
# [inline (always)]
pub fn is_taidex_3 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_3 } # [doc = "Checks if the value of the field is `TAIDEX_4`"]
# [inline (always)]
pub fn is_taidex_4 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_4 } # [doc = "Checks if the value of the field is `TAIDEX_5`"]
# [inline (always)]
pub fn is_taidex_5 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_5 } # [doc = "Checks if the value of the field is `TAIDEX_6`"]
# [inline (always)]
pub fn is_taidex_6 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_6 } # [doc = "Checks if the value of the field is `TAIDEX_7`"]
# [inline (always)]
pub fn is_taidex_7 (& self) -> bool { * self == TAIDEX_A :: TAIDEX_7 } } # [doc = "Field `TAIDEX` writer - Timer A Input divider expansion Bit: 0"]
pub type TAIDEX_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , TA3EX0_SPEC , u8 , TAIDEX_A , 3 , O > ; impl < 'a , const O : u8 > TAIDEX_W < 'a , O > { # [doc = "Timer A Input divider expansion : /1"]
# [inline (always)]
pub fn taidex_0 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_0) } # [doc = "Timer A Input divider expansion : /2"]
# [inline (always)]
pub fn taidex_1 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_1) } # [doc = "Timer A Input divider expansion : /3"]
# [inline (always)]
pub fn taidex_2 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_2) } # [doc = "Timer A Input divider expansion : /4"]
# [inline (always)]
pub fn taidex_3 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_3) } # [doc = "Timer A Input divider expansion : /5"]
# [inline (always)]
pub fn taidex_4 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_4) } # [doc = "Timer A Input divider expansion : /6"]
# [inline (always)]
pub fn taidex_5 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_5) } # [doc = "Timer A Input divider expansion : /7"]
# [inline (always)]
pub fn taidex_6 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_6) } # [doc = "Timer A Input divider expansion : /8"]
# [inline (always)]
pub fn taidex_7 (self) -> & 'a mut W { self . variant (TAIDEX_A :: TAIDEX_7) } } impl R { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& self) -> TAIDEX_R { TAIDEX_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Timer A Input divider expansion Bit: 0"]
# [inline (always)]
pub fn taidex (& mut self) -> TAIDEX_W < 0 > { TAIDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Expansion Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3ex0](index.html) module"]
pub struct TA3EX0_SPEC ; impl crate :: RegisterSpec for TA3EX0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3ex0::R](R) reader structure"]
impl crate :: Readable for TA3EX0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3ex0::W](W) writer structure"]
impl crate :: Writable for TA3EX0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3EX0 to value 0"]
impl crate :: Resettable for TA3EX0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "TA3IV register accessor: an alias for `Reg<TA3IV_SPEC>`"]
pub type TA3IV = crate :: Reg < ta3iv :: TA3IV_SPEC > ; # [doc = "Timer3_A2 Interrupt Vector Word"]
pub mod ta3iv { # [doc = "Register `TA3IV` reader"]
pub struct R (crate :: R < TA3IV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TA3IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TA3IV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TA3IV_SPEC >) -> Self { R (reader) } } # [doc = "Register `TA3IV` writer"]
pub struct W (crate :: W < TA3IV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TA3IV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TA3IV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TA3IV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer3_A2 Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ta3iv](index.html) module"]
pub struct TA3IV_SPEC ; impl crate :: RegisterSpec for TA3IV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ta3iv::R](R) reader structure"]
impl crate :: Readable for TA3IV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ta3iv::W](W) writer structure"]
impl crate :: Writable for TA3IV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets TA3IV to value 0"]
impl crate :: Resettable for TA3IV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "MPY 16 Multiplier 16 Bit Mode"]
pub struct MPY_16 { _marker : PhantomData < * const () > } unsafe impl Send for MPY_16 { } impl MPY_16 { # [doc = r"Pointer to the register block"]
pub const PTR : * const mpy_16 :: RegisterBlock = 0x04c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const mpy_16 :: RegisterBlock { Self :: PTR } } impl Deref for MPY_16 { type Target = mpy_16 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MPY_16 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MPY_16") . finish () } } # [doc = "MPY 16 Multiplier 16 Bit Mode"]
pub mod mpy_16 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Multiply Unsigned/Operand 1"]
pub mpy : crate :: Reg < mpy :: MPY_SPEC > , # [doc = "0x02 - Multiply Signed/Operand 1"]
pub mpys : crate :: Reg < mpys :: MPYS_SPEC > , # [doc = "0x04 - Multiply Unsigned and Accumulate/Operand 1"]
pub mac : crate :: Reg < mac :: MAC_SPEC > , # [doc = "0x06 - Multiply Signed and Accumulate/Operand 1"]
pub macs : crate :: Reg < macs :: MACS_SPEC > , # [doc = "0x08 - Operand 2"]
pub op2 : crate :: Reg < op2 :: OP2_SPEC > , # [doc = "0x0a - Result Low Word"]
pub reslo : crate :: Reg < reslo :: RESLO_SPEC > , # [doc = "0x0c - Result High Word"]
pub reshi : crate :: Reg < reshi :: RESHI_SPEC > , # [doc = "0x0e - Sum Extend"]
pub sumext : crate :: Reg < sumext :: SUMEXT_SPEC > , _reserved8 : [u8 ; 0x1c]
, # [doc = "0x2c - MPY32 Control Register 0"]
pub mpy32ctl0 : crate :: Reg < mpy32ctl0 :: MPY32CTL0_SPEC > , } # [doc = "MPY register accessor: an alias for `Reg<MPY_SPEC>`"]
pub type MPY = crate :: Reg < mpy :: MPY_SPEC > ; # [doc = "Multiply Unsigned/Operand 1"]
pub mod mpy { # [doc = "Register `MPY` reader"]
pub struct R (crate :: R < MPY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPY_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPY` writer"]
pub struct W (crate :: W < MPY_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPY_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPY_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiply Unsigned/Operand 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy](index.html) module"]
pub struct MPY_SPEC ; impl crate :: RegisterSpec for MPY_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpy::R](R) reader structure"]
impl crate :: Readable for MPY_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpy::W](W) writer structure"]
impl crate :: Writable for MPY_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPY to value 0"]
impl crate :: Resettable for MPY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MPYS register accessor: an alias for `Reg<MPYS_SPEC>`"]
pub type MPYS = crate :: Reg < mpys :: MPYS_SPEC > ; # [doc = "Multiply Signed/Operand 1"]
pub mod mpys { # [doc = "Register `MPYS` reader"]
pub struct R (crate :: R < MPYS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPYS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPYS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPYS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPYS` writer"]
pub struct W (crate :: W < MPYS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPYS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPYS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPYS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiply Signed/Operand 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys](index.html) module"]
pub struct MPYS_SPEC ; impl crate :: RegisterSpec for MPYS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpys::R](R) reader structure"]
impl crate :: Readable for MPYS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpys::W](W) writer structure"]
impl crate :: Writable for MPYS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPYS to value 0"]
impl crate :: Resettable for MPYS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MAC register accessor: an alias for `Reg<MAC_SPEC>`"]
pub type MAC = crate :: Reg < mac :: MAC_SPEC > ; # [doc = "Multiply Unsigned and Accumulate/Operand 1"]
pub mod mac { # [doc = "Register `MAC` reader"]
pub struct R (crate :: R < MAC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MAC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MAC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MAC_SPEC >) -> Self { R (reader) } } # [doc = "Register `MAC` writer"]
pub struct W (crate :: W < MAC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MAC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MAC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MAC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiply Unsigned and Accumulate/Operand 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac](index.html) module"]
pub struct MAC_SPEC ; impl crate :: RegisterSpec for MAC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mac::R](R) reader structure"]
impl crate :: Readable for MAC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mac::W](W) writer structure"]
impl crate :: Writable for MAC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MAC to value 0"]
impl crate :: Resettable for MAC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MACS register accessor: an alias for `Reg<MACS_SPEC>`"]
pub type MACS = crate :: Reg < macs :: MACS_SPEC > ; # [doc = "Multiply Signed and Accumulate/Operand 1"]
pub mod macs { # [doc = "Register `MACS` reader"]
pub struct R (crate :: R < MACS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MACS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MACS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MACS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MACS` writer"]
pub struct W (crate :: W < MACS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MACS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MACS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MACS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiply Signed and Accumulate/Operand 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs](index.html) module"]
pub struct MACS_SPEC ; impl crate :: RegisterSpec for MACS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [macs::R](R) reader structure"]
impl crate :: Readable for MACS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [macs::W](W) writer structure"]
impl crate :: Writable for MACS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MACS to value 0"]
impl crate :: Resettable for MACS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OP2 register accessor: an alias for `Reg<OP2_SPEC>`"]
pub type OP2 = crate :: Reg < op2 :: OP2_SPEC > ; # [doc = "Operand 2"]
pub mod op2 { # [doc = "Register `OP2` reader"]
pub struct R (crate :: R < OP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `OP2` writer"]
pub struct W (crate :: W < OP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Operand 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2](index.html) module"]
pub struct OP2_SPEC ; impl crate :: RegisterSpec for OP2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [op2::R](R) reader structure"]
impl crate :: Readable for OP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [op2::W](W) writer structure"]
impl crate :: Writable for OP2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OP2 to value 0"]
impl crate :: Resettable for OP2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RESLO register accessor: an alias for `Reg<RESLO_SPEC>`"]
pub type RESLO = crate :: Reg < reslo :: RESLO_SPEC > ; # [doc = "Result Low Word"]
pub mod reslo { # [doc = "Register `RESLO` reader"]
pub struct R (crate :: R < RESLO_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RESLO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RESLO_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RESLO_SPEC >) -> Self { R (reader) } } # [doc = "Register `RESLO` writer"]
pub struct W (crate :: W < RESLO_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RESLO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RESLO_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RESLO_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Result Low Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reslo](index.html) module"]
pub struct RESLO_SPEC ; impl crate :: RegisterSpec for RESLO_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [reslo::R](R) reader structure"]
impl crate :: Readable for RESLO_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [reslo::W](W) writer structure"]
impl crate :: Writable for RESLO_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RESLO to value 0"]
impl crate :: Resettable for RESLO_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RESHI register accessor: an alias for `Reg<RESHI_SPEC>`"]
pub type RESHI = crate :: Reg < reshi :: RESHI_SPEC > ; # [doc = "Result High Word"]
pub mod reshi { # [doc = "Register `RESHI` reader"]
pub struct R (crate :: R < RESHI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RESHI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RESHI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RESHI_SPEC >) -> Self { R (reader) } } # [doc = "Register `RESHI` writer"]
pub struct W (crate :: W < RESHI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RESHI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RESHI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RESHI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Result High Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reshi](index.html) module"]
pub struct RESHI_SPEC ; impl crate :: RegisterSpec for RESHI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [reshi::R](R) reader structure"]
impl crate :: Readable for RESHI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [reshi::W](W) writer structure"]
impl crate :: Writable for RESHI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RESHI to value 0"]
impl crate :: Resettable for RESHI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SUMEXT register accessor: an alias for `Reg<SUMEXT_SPEC>`"]
pub type SUMEXT = crate :: Reg < sumext :: SUMEXT_SPEC > ; # [doc = "Sum Extend"]
pub mod sumext { # [doc = "Register `SUMEXT` reader"]
pub struct R (crate :: R < SUMEXT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SUMEXT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SUMEXT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SUMEXT_SPEC >) -> Self { R (reader) } } # [doc = "Register `SUMEXT` writer"]
pub struct W (crate :: W < SUMEXT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SUMEXT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SUMEXT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SUMEXT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sum Extend\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sumext](index.html) module"]
pub struct SUMEXT_SPEC ; impl crate :: RegisterSpec for SUMEXT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [sumext::R](R) reader structure"]
impl crate :: Readable for SUMEXT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sumext::W](W) writer structure"]
impl crate :: Writable for SUMEXT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SUMEXT to value 0"]
impl crate :: Resettable for SUMEXT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MPY32CTL0 register accessor: an alias for `Reg<MPY32CTL0_SPEC>`"]
pub type MPY32CTL0 = crate :: Reg < mpy32ctl0 :: MPY32CTL0_SPEC > ; # [doc = "MPY32 Control Register 0"]
pub mod mpy32ctl0 { # [doc = "Register `MPY32CTL0` reader"]
pub struct R (crate :: R < MPY32CTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPY32CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPY32CTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPY32CTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPY32CTL0` writer"]
pub struct W (crate :: W < MPY32CTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPY32CTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPY32CTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPY32CTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPYC` reader - Carry of the multiplier"]
pub type MPYC_R = crate :: BitReader < bool > ; # [doc = "Field `MPYC` writer - Carry of the multiplier"]
pub type MPYC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Field `MPYFRAC` reader - Fractional mode"]
pub type MPYFRAC_R = crate :: BitReader < bool > ; # [doc = "Field `MPYFRAC` writer - Fractional mode"]
pub type MPYFRAC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Field `MPYSAT` reader - Saturation mode"]
pub type MPYSAT_R = crate :: BitReader < bool > ; # [doc = "Field `MPYSAT` writer - Saturation mode"]
pub type MPYSAT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Multiplier mode Bit:0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MPYM_A { # [doc = "0: Multiplier mode: MPY"]
MPYM_0 = 0 , # [doc = "1: Multiplier mode: MPYS"]
MPYM_1 = 1 , # [doc = "2: Multiplier mode: MAC"]
MPYM_2 = 2 , # [doc = "3: Multiplier mode: MACS"]
MPYM_3 = 3 , } impl From < MPYM_A > for u8 { # [inline (always)]
fn from (variant : MPYM_A) -> Self { variant as _ } } # [doc = "Field `MPYM` reader - Multiplier mode Bit:0"]
pub type MPYM_R = crate :: FieldReader < u8 , MPYM_A > ; impl MPYM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MPYM_A { match self . bits { 0 => MPYM_A :: MPYM_0 , 1 => MPYM_A :: MPYM_1 , 2 => MPYM_A :: MPYM_2 , 3 => MPYM_A :: MPYM_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `MPYM_0`"]
# [inline (always)]
pub fn is_mpym_0 (& self) -> bool { * self == MPYM_A :: MPYM_0 } # [doc = "Checks if the value of the field is `MPYM_1`"]
# [inline (always)]
pub fn is_mpym_1 (& self) -> bool { * self == MPYM_A :: MPYM_1 } # [doc = "Checks if the value of the field is `MPYM_2`"]
# [inline (always)]
pub fn is_mpym_2 (& self) -> bool { * self == MPYM_A :: MPYM_2 } # [doc = "Checks if the value of the field is `MPYM_3`"]
# [inline (always)]
pub fn is_mpym_3 (& self) -> bool { * self == MPYM_A :: MPYM_3 } } # [doc = "Field `MPYM` writer - Multiplier mode Bit:0"]
pub type MPYM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , MPY32CTL0_SPEC , u8 , MPYM_A , 2 , O > ; impl < 'a , const O : u8 > MPYM_W < 'a , O > { # [doc = "Multiplier mode: MPY"]
# [inline (always)]
pub fn mpym_0 (self) -> & 'a mut W { self . variant (MPYM_A :: MPYM_0) } # [doc = "Multiplier mode: MPYS"]
# [inline (always)]
pub fn mpym_1 (self) -> & 'a mut W { self . variant (MPYM_A :: MPYM_1) } # [doc = "Multiplier mode: MAC"]
# [inline (always)]
pub fn mpym_2 (self) -> & 'a mut W { self . variant (MPYM_A :: MPYM_2) } # [doc = "Multiplier mode: MACS"]
# [inline (always)]
pub fn mpym_3 (self) -> & 'a mut W { self . variant (MPYM_A :: MPYM_3) } } # [doc = "Field `OP1_32` reader - Bit-width of operand 1 0:16Bit / 1:32Bit"]
pub type OP1_32_R = crate :: BitReader < bool > ; # [doc = "Field `OP1_32` writer - Bit-width of operand 1 0:16Bit / 1:32Bit"]
pub type OP1_32_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Field `OP2_32` reader - Bit-width of operand 2 0:16Bit / 1:32Bit"]
pub type OP2_32_R = crate :: BitReader < bool > ; # [doc = "Field `OP2_32` writer - Bit-width of operand 2 0:16Bit / 1:32Bit"]
pub type OP2_32_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Field `MPYDLYWRTEN` reader - Delayed write enable"]
pub type MPYDLYWRTEN_R = crate :: BitReader < bool > ; # [doc = "Field `MPYDLYWRTEN` writer - Delayed write enable"]
pub type MPYDLYWRTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; # [doc = "Field `MPYDLY32` reader - Delayed write mode"]
pub type MPYDLY32_R = crate :: BitReader < bool > ; # [doc = "Field `MPYDLY32` writer - Delayed write mode"]
pub type MPYDLY32_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , MPY32CTL0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Carry of the multiplier"]
# [inline (always)]
pub fn mpyc (& self) -> MPYC_R { MPYC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Fractional mode"]
# [inline (always)]
pub fn mpyfrac (& self) -> MPYFRAC_R { MPYFRAC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Saturation mode"]
# [inline (always)]
pub fn mpysat (& self) -> MPYSAT_R { MPYSAT_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Multiplier mode Bit:0"]
# [inline (always)]
pub fn mpym (& self) -> MPYM_R { MPYM_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 6 - Bit-width of operand 1 0:16Bit / 1:32Bit"]
# [inline (always)]
pub fn op1_32 (& self) -> OP1_32_R { OP1_32_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Bit-width of operand 2 0:16Bit / 1:32Bit"]
# [inline (always)]
pub fn op2_32 (& self) -> OP2_32_R { OP2_32_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Delayed write enable"]
# [inline (always)]
pub fn mpydlywrten (& self) -> MPYDLYWRTEN_R { MPYDLYWRTEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Delayed write mode"]
# [inline (always)]
pub fn mpydly32 (& self) -> MPYDLY32_R { MPYDLY32_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Carry of the multiplier"]
# [inline (always)]
pub fn mpyc (& mut self) -> MPYC_W < 0 > { MPYC_W :: new (self) } # [doc = "Bit 2 - Fractional mode"]
# [inline (always)]
pub fn mpyfrac (& mut self) -> MPYFRAC_W < 2 > { MPYFRAC_W :: new (self) } # [doc = "Bit 3 - Saturation mode"]
# [inline (always)]
pub fn mpysat (& mut self) -> MPYSAT_W < 3 > { MPYSAT_W :: new (self) } # [doc = "Bits 4:5 - Multiplier mode Bit:0"]
# [inline (always)]
pub fn mpym (& mut self) -> MPYM_W < 4 > { MPYM_W :: new (self) } # [doc = "Bit 6 - Bit-width of operand 1 0:16Bit / 1:32Bit"]
# [inline (always)]
pub fn op1_32 (& mut self) -> OP1_32_W < 6 > { OP1_32_W :: new (self) } # [doc = "Bit 7 - Bit-width of operand 2 0:16Bit / 1:32Bit"]
# [inline (always)]
pub fn op2_32 (& mut self) -> OP2_32_W < 7 > { OP2_32_W :: new (self) } # [doc = "Bit 8 - Delayed write enable"]
# [inline (always)]
pub fn mpydlywrten (& mut self) -> MPYDLYWRTEN_W < 8 > { MPYDLYWRTEN_W :: new (self) } # [doc = "Bit 9 - Delayed write mode"]
# [inline (always)]
pub fn mpydly32 (& mut self) -> MPYDLY32_W < 9 > { MPYDLY32_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MPY32 Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32ctl0](index.html) module"]
pub struct MPY32CTL0_SPEC ; impl crate :: RegisterSpec for MPY32CTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpy32ctl0::R](R) reader structure"]
impl crate :: Readable for MPY32CTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpy32ctl0::W](W) writer structure"]
impl crate :: Writable for MPY32CTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPY32CTL0 to value 0"]
impl crate :: Resettable for MPY32CTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "MPY 32 Multiplier 32 Bit Mode"]
pub struct MPY_32 { _marker : PhantomData < * const () > } unsafe impl Send for MPY_32 { } impl MPY_32 { # [doc = r"Pointer to the register block"]
pub const PTR : * const mpy_32 :: RegisterBlock = 0x04d0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const mpy_32 :: RegisterBlock { Self :: PTR } } impl Deref for MPY_32 { type Target = mpy_32 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MPY_32 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MPY_32") . finish () } } # [doc = "MPY 32 Multiplier 32 Bit Mode"]
pub mod mpy_32 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - 32-bit operand 1 - multiply - low word"]
pub mpy32l : crate :: Reg < mpy32l :: MPY32L_SPEC > , # [doc = "0x02 - 32-bit operand 1 - multiply - high word"]
pub mpy32h : crate :: Reg < mpy32h :: MPY32H_SPEC > , # [doc = "0x04 - 32-bit operand 1 - signed multiply - low word"]
pub mpys32l : crate :: Reg < mpys32l :: MPYS32L_SPEC > , # [doc = "0x06 - 32-bit operand 1 - signed multiply - high word"]
pub mpys32h : crate :: Reg < mpys32h :: MPYS32H_SPEC > , # [doc = "0x08 - 32-bit operand 1 - multiply accumulate - low word"]
pub mac32l : crate :: Reg < mac32l :: MAC32L_SPEC > , # [doc = "0x0a - 32-bit operand 1 - multiply accumulate - high word"]
pub mac32h : crate :: Reg < mac32h :: MAC32H_SPEC > , # [doc = "0x0c - 32-bit operand 1 - signed multiply accumulate - low word"]
pub macs32l : crate :: Reg < macs32l :: MACS32L_SPEC > , # [doc = "0x0e - 32-bit operand 1 - signed multiply accumulate - high word"]
pub macs32h : crate :: Reg < macs32h :: MACS32H_SPEC > , # [doc = "0x10 - 32-bit operand 2 - low word"]
pub op2l : crate :: Reg < op2l :: OP2L_SPEC > , # [doc = "0x12 - 32-bit operand 2 - high word"]
pub op2h : crate :: Reg < op2h :: OP2H_SPEC > , # [doc = "0x14 - 32x32-bit result 0 - least significant word"]
pub res0 : crate :: Reg < res0 :: RES0_SPEC > , # [doc = "0x16 - 32x32-bit result 1"]
pub res1 : crate :: Reg < res1 :: RES1_SPEC > , # [doc = "0x18 - 32x32-bit result 2"]
pub res2 : crate :: Reg < res2 :: RES2_SPEC > , # [doc = "0x1a - 32x32-bit result 3 - most significant word"]
pub res3 : crate :: Reg < res3 :: RES3_SPEC > , } # [doc = "MPY32L register accessor: an alias for `Reg<MPY32L_SPEC>`"]
pub type MPY32L = crate :: Reg < mpy32l :: MPY32L_SPEC > ; # [doc = "32-bit operand 1 - multiply - low word"]
pub mod mpy32l { # [doc = "Register `MPY32L` reader"]
pub struct R (crate :: R < MPY32L_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPY32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPY32L_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPY32L_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPY32L` writer"]
pub struct W (crate :: W < MPY32L_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPY32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPY32L_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPY32L_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - multiply - low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32l](index.html) module"]
pub struct MPY32L_SPEC ; impl crate :: RegisterSpec for MPY32L_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpy32l::R](R) reader structure"]
impl crate :: Readable for MPY32L_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpy32l::W](W) writer structure"]
impl crate :: Writable for MPY32L_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPY32L to value 0"]
impl crate :: Resettable for MPY32L_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MPY32H register accessor: an alias for `Reg<MPY32H_SPEC>`"]
pub type MPY32H = crate :: Reg < mpy32h :: MPY32H_SPEC > ; # [doc = "32-bit operand 1 - multiply - high word"]
pub mod mpy32h { # [doc = "Register `MPY32H` reader"]
pub struct R (crate :: R < MPY32H_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPY32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPY32H_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPY32H_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPY32H` writer"]
pub struct W (crate :: W < MPY32H_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPY32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPY32H_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPY32H_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - multiply - high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpy32h](index.html) module"]
pub struct MPY32H_SPEC ; impl crate :: RegisterSpec for MPY32H_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpy32h::R](R) reader structure"]
impl crate :: Readable for MPY32H_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpy32h::W](W) writer structure"]
impl crate :: Writable for MPY32H_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPY32H to value 0"]
impl crate :: Resettable for MPY32H_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MPYS32L register accessor: an alias for `Reg<MPYS32L_SPEC>`"]
pub type MPYS32L = crate :: Reg < mpys32l :: MPYS32L_SPEC > ; # [doc = "32-bit operand 1 - signed multiply - low word"]
pub mod mpys32l { # [doc = "Register `MPYS32L` reader"]
pub struct R (crate :: R < MPYS32L_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPYS32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPYS32L_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPYS32L_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPYS32L` writer"]
pub struct W (crate :: W < MPYS32L_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPYS32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPYS32L_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPYS32L_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - signed multiply - low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32l](index.html) module"]
pub struct MPYS32L_SPEC ; impl crate :: RegisterSpec for MPYS32L_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpys32l::R](R) reader structure"]
impl crate :: Readable for MPYS32L_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpys32l::W](W) writer structure"]
impl crate :: Writable for MPYS32L_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPYS32L to value 0"]
impl crate :: Resettable for MPYS32L_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MPYS32H register accessor: an alias for `Reg<MPYS32H_SPEC>`"]
pub type MPYS32H = crate :: Reg < mpys32h :: MPYS32H_SPEC > ; # [doc = "32-bit operand 1 - signed multiply - high word"]
pub mod mpys32h { # [doc = "Register `MPYS32H` reader"]
pub struct R (crate :: R < MPYS32H_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPYS32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPYS32H_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPYS32H_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPYS32H` writer"]
pub struct W (crate :: W < MPYS32H_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPYS32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPYS32H_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPYS32H_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - signed multiply - high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpys32h](index.html) module"]
pub struct MPYS32H_SPEC ; impl crate :: RegisterSpec for MPYS32H_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mpys32h::R](R) reader structure"]
impl crate :: Readable for MPYS32H_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpys32h::W](W) writer structure"]
impl crate :: Writable for MPYS32H_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MPYS32H to value 0"]
impl crate :: Resettable for MPYS32H_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MAC32L register accessor: an alias for `Reg<MAC32L_SPEC>`"]
pub type MAC32L = crate :: Reg < mac32l :: MAC32L_SPEC > ; # [doc = "32-bit operand 1 - multiply accumulate - low word"]
pub mod mac32l { # [doc = "Register `MAC32L` reader"]
pub struct R (crate :: R < MAC32L_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MAC32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MAC32L_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MAC32L_SPEC >) -> Self { R (reader) } } # [doc = "Register `MAC32L` writer"]
pub struct W (crate :: W < MAC32L_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MAC32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MAC32L_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MAC32L_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - multiply accumulate - low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32l](index.html) module"]
pub struct MAC32L_SPEC ; impl crate :: RegisterSpec for MAC32L_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mac32l::R](R) reader structure"]
impl crate :: Readable for MAC32L_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mac32l::W](W) writer structure"]
impl crate :: Writable for MAC32L_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MAC32L to value 0"]
impl crate :: Resettable for MAC32L_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MAC32H register accessor: an alias for `Reg<MAC32H_SPEC>`"]
pub type MAC32H = crate :: Reg < mac32h :: MAC32H_SPEC > ; # [doc = "32-bit operand 1 - multiply accumulate - high word"]
pub mod mac32h { # [doc = "Register `MAC32H` reader"]
pub struct R (crate :: R < MAC32H_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MAC32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MAC32H_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MAC32H_SPEC >) -> Self { R (reader) } } # [doc = "Register `MAC32H` writer"]
pub struct W (crate :: W < MAC32H_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MAC32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MAC32H_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MAC32H_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - multiply accumulate - high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mac32h](index.html) module"]
pub struct MAC32H_SPEC ; impl crate :: RegisterSpec for MAC32H_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [mac32h::R](R) reader structure"]
impl crate :: Readable for MAC32H_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mac32h::W](W) writer structure"]
impl crate :: Writable for MAC32H_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MAC32H to value 0"]
impl crate :: Resettable for MAC32H_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MACS32L register accessor: an alias for `Reg<MACS32L_SPEC>`"]
pub type MACS32L = crate :: Reg < macs32l :: MACS32L_SPEC > ; # [doc = "32-bit operand 1 - signed multiply accumulate - low word"]
pub mod macs32l { # [doc = "Register `MACS32L` reader"]
pub struct R (crate :: R < MACS32L_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MACS32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MACS32L_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MACS32L_SPEC >) -> Self { R (reader) } } # [doc = "Register `MACS32L` writer"]
pub struct W (crate :: W < MACS32L_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MACS32L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MACS32L_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MACS32L_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - signed multiply accumulate - low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32l](index.html) module"]
pub struct MACS32L_SPEC ; impl crate :: RegisterSpec for MACS32L_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [macs32l::R](R) reader structure"]
impl crate :: Readable for MACS32L_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [macs32l::W](W) writer structure"]
impl crate :: Writable for MACS32L_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MACS32L to value 0"]
impl crate :: Resettable for MACS32L_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MACS32H register accessor: an alias for `Reg<MACS32H_SPEC>`"]
pub type MACS32H = crate :: Reg < macs32h :: MACS32H_SPEC > ; # [doc = "32-bit operand 1 - signed multiply accumulate - high word"]
pub mod macs32h { # [doc = "Register `MACS32H` reader"]
pub struct R (crate :: R < MACS32H_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MACS32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MACS32H_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MACS32H_SPEC >) -> Self { R (reader) } } # [doc = "Register `MACS32H` writer"]
pub struct W (crate :: W < MACS32H_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MACS32H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MACS32H_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MACS32H_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 1 - signed multiply accumulate - high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [macs32h](index.html) module"]
pub struct MACS32H_SPEC ; impl crate :: RegisterSpec for MACS32H_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [macs32h::R](R) reader structure"]
impl crate :: Readable for MACS32H_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [macs32h::W](W) writer structure"]
impl crate :: Writable for MACS32H_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MACS32H to value 0"]
impl crate :: Resettable for MACS32H_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OP2L register accessor: an alias for `Reg<OP2L_SPEC>`"]
pub type OP2L = crate :: Reg < op2l :: OP2L_SPEC > ; # [doc = "32-bit operand 2 - low word"]
pub mod op2l { # [doc = "Register `OP2L` reader"]
pub struct R (crate :: R < OP2L_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OP2L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OP2L_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OP2L_SPEC >) -> Self { R (reader) } } # [doc = "Register `OP2L` writer"]
pub struct W (crate :: W < OP2L_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OP2L_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OP2L_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OP2L_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 2 - low word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2l](index.html) module"]
pub struct OP2L_SPEC ; impl crate :: RegisterSpec for OP2L_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [op2l::R](R) reader structure"]
impl crate :: Readable for OP2L_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [op2l::W](W) writer structure"]
impl crate :: Writable for OP2L_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OP2L to value 0"]
impl crate :: Resettable for OP2L_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OP2H register accessor: an alias for `Reg<OP2H_SPEC>`"]
pub type OP2H = crate :: Reg < op2h :: OP2H_SPEC > ; # [doc = "32-bit operand 2 - high word"]
pub mod op2h { # [doc = "Register `OP2H` reader"]
pub struct R (crate :: R < OP2H_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OP2H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OP2H_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OP2H_SPEC >) -> Self { R (reader) } } # [doc = "Register `OP2H` writer"]
pub struct W (crate :: W < OP2H_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OP2H_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OP2H_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OP2H_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32-bit operand 2 - high word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [op2h](index.html) module"]
pub struct OP2H_SPEC ; impl crate :: RegisterSpec for OP2H_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [op2h::R](R) reader structure"]
impl crate :: Readable for OP2H_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [op2h::W](W) writer structure"]
impl crate :: Writable for OP2H_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OP2H to value 0"]
impl crate :: Resettable for OP2H_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RES0 register accessor: an alias for `Reg<RES0_SPEC>`"]
pub type RES0 = crate :: Reg < res0 :: RES0_SPEC > ; # [doc = "32x32-bit result 0 - least significant word"]
pub mod res0 { # [doc = "Register `RES0` reader"]
pub struct R (crate :: R < RES0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES0_SPEC >) -> Self { R (reader) } } # [doc = "Register `RES0` writer"]
pub struct W (crate :: W < RES0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RES0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RES0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RES0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32x32-bit result 0 - least significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res0](index.html) module"]
pub struct RES0_SPEC ; impl crate :: RegisterSpec for RES0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res0::R](R) reader structure"]
impl crate :: Readable for RES0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [res0::W](W) writer structure"]
impl crate :: Writable for RES0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RES0 to value 0"]
impl crate :: Resettable for RES0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RES1 register accessor: an alias for `Reg<RES1_SPEC>`"]
pub type RES1 = crate :: Reg < res1 :: RES1_SPEC > ; # [doc = "32x32-bit result 1"]
pub mod res1 { # [doc = "Register `RES1` reader"]
pub struct R (crate :: R < RES1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES1_SPEC >) -> Self { R (reader) } } # [doc = "Register `RES1` writer"]
pub struct W (crate :: W < RES1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RES1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RES1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RES1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32x32-bit result 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res1](index.html) module"]
pub struct RES1_SPEC ; impl crate :: RegisterSpec for RES1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res1::R](R) reader structure"]
impl crate :: Readable for RES1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [res1::W](W) writer structure"]
impl crate :: Writable for RES1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RES1 to value 0"]
impl crate :: Resettable for RES1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RES2 register accessor: an alias for `Reg<RES2_SPEC>`"]
pub type RES2 = crate :: Reg < res2 :: RES2_SPEC > ; # [doc = "32x32-bit result 2"]
pub mod res2 { # [doc = "Register `RES2` reader"]
pub struct R (crate :: R < RES2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES2_SPEC >) -> Self { R (reader) } } # [doc = "Register `RES2` writer"]
pub struct W (crate :: W < RES2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RES2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RES2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RES2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32x32-bit result 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res2](index.html) module"]
pub struct RES2_SPEC ; impl crate :: RegisterSpec for RES2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res2::R](R) reader structure"]
impl crate :: Readable for RES2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [res2::W](W) writer structure"]
impl crate :: Writable for RES2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RES2 to value 0"]
impl crate :: Resettable for RES2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RES3 register accessor: an alias for `Reg<RES3_SPEC>`"]
pub type RES3 = crate :: Reg < res3 :: RES3_SPEC > ; # [doc = "32x32-bit result 3 - most significant word"]
pub mod res3 { # [doc = "Register `RES3` reader"]
pub struct R (crate :: R < RES3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES3_SPEC >) -> Self { R (reader) } } # [doc = "Register `RES3` writer"]
pub struct W (crate :: W < RES3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RES3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RES3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RES3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32x32-bit result 3 - most significant word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res3](index.html) module"]
pub struct RES3_SPEC ; impl crate :: RegisterSpec for RES3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res3::R](R) reader structure"]
impl crate :: Readable for RES3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [res3::W](W) writer structure"]
impl crate :: Writable for RES3_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RES3 to value 0"]
impl crate :: Resettable for RES3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Backup Memory"]
pub struct BACKUP_MEMORY { _marker : PhantomData < * const () > } unsafe impl Send for BACKUP_MEMORY { } impl BACKUP_MEMORY { # [doc = r"Pointer to the register block"]
pub const PTR : * const backup_memory :: RegisterBlock = 0x0660 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const backup_memory :: RegisterBlock { Self :: PTR } } impl Deref for BACKUP_MEMORY { type Target = backup_memory :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for BACKUP_MEMORY { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("BACKUP_MEMORY") . finish () } } # [doc = "Backup Memory"]
pub mod backup_memory { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Battery Backup Memory 0"]
pub bakmem0 : crate :: Reg < bakmem0 :: BAKMEM0_SPEC > , # [doc = "0x02 - Battery Backup Memory 1"]
pub bakmem1 : crate :: Reg < bakmem1 :: BAKMEM1_SPEC > , # [doc = "0x04 - Battery Backup Memory 2"]
pub bakmem2 : crate :: Reg < bakmem2 :: BAKMEM2_SPEC > , # [doc = "0x06 - Battery Backup Memory 3"]
pub bakmem3 : crate :: Reg < bakmem3 :: BAKMEM3_SPEC > , # [doc = "0x08 - Battery Backup Memory 4"]
pub bakmem4 : crate :: Reg < bakmem4 :: BAKMEM4_SPEC > , # [doc = "0x0a - Battery Backup Memory 5"]
pub bakmem5 : crate :: Reg < bakmem5 :: BAKMEM5_SPEC > , # [doc = "0x0c - Battery Backup Memory 6"]
pub bakmem6 : crate :: Reg < bakmem6 :: BAKMEM6_SPEC > , # [doc = "0x0e - Battery Backup Memory 7"]
pub bakmem7 : crate :: Reg < bakmem7 :: BAKMEM7_SPEC > , # [doc = "0x10 - Battery Backup Memory 8"]
pub bakmem8 : crate :: Reg < bakmem8 :: BAKMEM8_SPEC > , # [doc = "0x12 - Battery Backup Memory 9"]
pub bakmem9 : crate :: Reg < bakmem9 :: BAKMEM9_SPEC > , # [doc = "0x14 - Battery Backup Memory 10"]
pub bakmem10 : crate :: Reg < bakmem10 :: BAKMEM10_SPEC > , # [doc = "0x16 - Battery Backup Memory 11"]
pub bakmem11 : crate :: Reg < bakmem11 :: BAKMEM11_SPEC > , # [doc = "0x18 - Battery Backup Memory 12"]
pub bakmem12 : crate :: Reg < bakmem12 :: BAKMEM12_SPEC > , # [doc = "0x1a - Battery Backup Memory 13"]
pub bakmem13 : crate :: Reg < bakmem13 :: BAKMEM13_SPEC > , # [doc = "0x1c - Battery Backup Memory 14"]
pub bakmem14 : crate :: Reg < bakmem14 :: BAKMEM14_SPEC > , # [doc = "0x1e - Battery Backup Memory 15"]
pub bakmem15 : crate :: Reg < bakmem15 :: BAKMEM15_SPEC > , } # [doc = "BAKMEM0 register accessor: an alias for `Reg<BAKMEM0_SPEC>`"]
pub type BAKMEM0 = crate :: Reg < bakmem0 :: BAKMEM0_SPEC > ; # [doc = "Battery Backup Memory 0"]
pub mod bakmem0 { # [doc = "Register `BAKMEM0` reader"]
pub struct R (crate :: R < BAKMEM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM0_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM0` writer"]
pub struct W (crate :: W < BAKMEM0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem0](index.html) module"]
pub struct BAKMEM0_SPEC ; impl crate :: RegisterSpec for BAKMEM0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem0::R](R) reader structure"]
impl crate :: Readable for BAKMEM0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem0::W](W) writer structure"]
impl crate :: Writable for BAKMEM0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM0 to value 0"]
impl crate :: Resettable for BAKMEM0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM1 register accessor: an alias for `Reg<BAKMEM1_SPEC>`"]
pub type BAKMEM1 = crate :: Reg < bakmem1 :: BAKMEM1_SPEC > ; # [doc = "Battery Backup Memory 1"]
pub mod bakmem1 { # [doc = "Register `BAKMEM1` reader"]
pub struct R (crate :: R < BAKMEM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM1_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM1` writer"]
pub struct W (crate :: W < BAKMEM1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem1](index.html) module"]
pub struct BAKMEM1_SPEC ; impl crate :: RegisterSpec for BAKMEM1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem1::R](R) reader structure"]
impl crate :: Readable for BAKMEM1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem1::W](W) writer structure"]
impl crate :: Writable for BAKMEM1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM1 to value 0"]
impl crate :: Resettable for BAKMEM1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM2 register accessor: an alias for `Reg<BAKMEM2_SPEC>`"]
pub type BAKMEM2 = crate :: Reg < bakmem2 :: BAKMEM2_SPEC > ; # [doc = "Battery Backup Memory 2"]
pub mod bakmem2 { # [doc = "Register `BAKMEM2` reader"]
pub struct R (crate :: R < BAKMEM2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM2_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM2` writer"]
pub struct W (crate :: W < BAKMEM2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem2](index.html) module"]
pub struct BAKMEM2_SPEC ; impl crate :: RegisterSpec for BAKMEM2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem2::R](R) reader structure"]
impl crate :: Readable for BAKMEM2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem2::W](W) writer structure"]
impl crate :: Writable for BAKMEM2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM2 to value 0"]
impl crate :: Resettable for BAKMEM2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM3 register accessor: an alias for `Reg<BAKMEM3_SPEC>`"]
pub type BAKMEM3 = crate :: Reg < bakmem3 :: BAKMEM3_SPEC > ; # [doc = "Battery Backup Memory 3"]
pub mod bakmem3 { # [doc = "Register `BAKMEM3` reader"]
pub struct R (crate :: R < BAKMEM3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM3_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM3` writer"]
pub struct W (crate :: W < BAKMEM3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem3](index.html) module"]
pub struct BAKMEM3_SPEC ; impl crate :: RegisterSpec for BAKMEM3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem3::R](R) reader structure"]
impl crate :: Readable for BAKMEM3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem3::W](W) writer structure"]
impl crate :: Writable for BAKMEM3_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM3 to value 0"]
impl crate :: Resettable for BAKMEM3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM4 register accessor: an alias for `Reg<BAKMEM4_SPEC>`"]
pub type BAKMEM4 = crate :: Reg < bakmem4 :: BAKMEM4_SPEC > ; # [doc = "Battery Backup Memory 4"]
pub mod bakmem4 { # [doc = "Register `BAKMEM4` reader"]
pub struct R (crate :: R < BAKMEM4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM4_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM4` writer"]
pub struct W (crate :: W < BAKMEM4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem4](index.html) module"]
pub struct BAKMEM4_SPEC ; impl crate :: RegisterSpec for BAKMEM4_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem4::R](R) reader structure"]
impl crate :: Readable for BAKMEM4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem4::W](W) writer structure"]
impl crate :: Writable for BAKMEM4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM4 to value 0"]
impl crate :: Resettable for BAKMEM4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM5 register accessor: an alias for `Reg<BAKMEM5_SPEC>`"]
pub type BAKMEM5 = crate :: Reg < bakmem5 :: BAKMEM5_SPEC > ; # [doc = "Battery Backup Memory 5"]
pub mod bakmem5 { # [doc = "Register `BAKMEM5` reader"]
pub struct R (crate :: R < BAKMEM5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM5_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM5` writer"]
pub struct W (crate :: W < BAKMEM5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem5](index.html) module"]
pub struct BAKMEM5_SPEC ; impl crate :: RegisterSpec for BAKMEM5_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem5::R](R) reader structure"]
impl crate :: Readable for BAKMEM5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem5::W](W) writer structure"]
impl crate :: Writable for BAKMEM5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM5 to value 0"]
impl crate :: Resettable for BAKMEM5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM6 register accessor: an alias for `Reg<BAKMEM6_SPEC>`"]
pub type BAKMEM6 = crate :: Reg < bakmem6 :: BAKMEM6_SPEC > ; # [doc = "Battery Backup Memory 6"]
pub mod bakmem6 { # [doc = "Register `BAKMEM6` reader"]
pub struct R (crate :: R < BAKMEM6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM6_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM6` writer"]
pub struct W (crate :: W < BAKMEM6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM6_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem6](index.html) module"]
pub struct BAKMEM6_SPEC ; impl crate :: RegisterSpec for BAKMEM6_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem6::R](R) reader structure"]
impl crate :: Readable for BAKMEM6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem6::W](W) writer structure"]
impl crate :: Writable for BAKMEM6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM6 to value 0"]
impl crate :: Resettable for BAKMEM6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM7 register accessor: an alias for `Reg<BAKMEM7_SPEC>`"]
pub type BAKMEM7 = crate :: Reg < bakmem7 :: BAKMEM7_SPEC > ; # [doc = "Battery Backup Memory 7"]
pub mod bakmem7 { # [doc = "Register `BAKMEM7` reader"]
pub struct R (crate :: R < BAKMEM7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM7_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM7` writer"]
pub struct W (crate :: W < BAKMEM7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM7_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem7](index.html) module"]
pub struct BAKMEM7_SPEC ; impl crate :: RegisterSpec for BAKMEM7_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem7::R](R) reader structure"]
impl crate :: Readable for BAKMEM7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem7::W](W) writer structure"]
impl crate :: Writable for BAKMEM7_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM7 to value 0"]
impl crate :: Resettable for BAKMEM7_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM8 register accessor: an alias for `Reg<BAKMEM8_SPEC>`"]
pub type BAKMEM8 = crate :: Reg < bakmem8 :: BAKMEM8_SPEC > ; # [doc = "Battery Backup Memory 8"]
pub mod bakmem8 { # [doc = "Register `BAKMEM8` reader"]
pub struct R (crate :: R < BAKMEM8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM8_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM8` writer"]
pub struct W (crate :: W < BAKMEM8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM8_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem8](index.html) module"]
pub struct BAKMEM8_SPEC ; impl crate :: RegisterSpec for BAKMEM8_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem8::R](R) reader structure"]
impl crate :: Readable for BAKMEM8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem8::W](W) writer structure"]
impl crate :: Writable for BAKMEM8_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM8 to value 0"]
impl crate :: Resettable for BAKMEM8_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM9 register accessor: an alias for `Reg<BAKMEM9_SPEC>`"]
pub type BAKMEM9 = crate :: Reg < bakmem9 :: BAKMEM9_SPEC > ; # [doc = "Battery Backup Memory 9"]
pub mod bakmem9 { # [doc = "Register `BAKMEM9` reader"]
pub struct R (crate :: R < BAKMEM9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM9_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM9` writer"]
pub struct W (crate :: W < BAKMEM9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM9_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 9\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem9](index.html) module"]
pub struct BAKMEM9_SPEC ; impl crate :: RegisterSpec for BAKMEM9_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem9::R](R) reader structure"]
impl crate :: Readable for BAKMEM9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem9::W](W) writer structure"]
impl crate :: Writable for BAKMEM9_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM9 to value 0"]
impl crate :: Resettable for BAKMEM9_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM10 register accessor: an alias for `Reg<BAKMEM10_SPEC>`"]
pub type BAKMEM10 = crate :: Reg < bakmem10 :: BAKMEM10_SPEC > ; # [doc = "Battery Backup Memory 10"]
pub mod bakmem10 { # [doc = "Register `BAKMEM10` reader"]
pub struct R (crate :: R < BAKMEM10_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM10_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM10_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM10` writer"]
pub struct W (crate :: W < BAKMEM10_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM10_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM10_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 10\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem10](index.html) module"]
pub struct BAKMEM10_SPEC ; impl crate :: RegisterSpec for BAKMEM10_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem10::R](R) reader structure"]
impl crate :: Readable for BAKMEM10_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem10::W](W) writer structure"]
impl crate :: Writable for BAKMEM10_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM10 to value 0"]
impl crate :: Resettable for BAKMEM10_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM11 register accessor: an alias for `Reg<BAKMEM11_SPEC>`"]
pub type BAKMEM11 = crate :: Reg < bakmem11 :: BAKMEM11_SPEC > ; # [doc = "Battery Backup Memory 11"]
pub mod bakmem11 { # [doc = "Register `BAKMEM11` reader"]
pub struct R (crate :: R < BAKMEM11_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM11_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM11_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM11` writer"]
pub struct W (crate :: W < BAKMEM11_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM11_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM11_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 11\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem11](index.html) module"]
pub struct BAKMEM11_SPEC ; impl crate :: RegisterSpec for BAKMEM11_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem11::R](R) reader structure"]
impl crate :: Readable for BAKMEM11_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem11::W](W) writer structure"]
impl crate :: Writable for BAKMEM11_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM11 to value 0"]
impl crate :: Resettable for BAKMEM11_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM12 register accessor: an alias for `Reg<BAKMEM12_SPEC>`"]
pub type BAKMEM12 = crate :: Reg < bakmem12 :: BAKMEM12_SPEC > ; # [doc = "Battery Backup Memory 12"]
pub mod bakmem12 { # [doc = "Register `BAKMEM12` reader"]
pub struct R (crate :: R < BAKMEM12_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM12_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM12_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM12` writer"]
pub struct W (crate :: W < BAKMEM12_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM12_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM12_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 12\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem12](index.html) module"]
pub struct BAKMEM12_SPEC ; impl crate :: RegisterSpec for BAKMEM12_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem12::R](R) reader structure"]
impl crate :: Readable for BAKMEM12_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem12::W](W) writer structure"]
impl crate :: Writable for BAKMEM12_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM12 to value 0"]
impl crate :: Resettable for BAKMEM12_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM13 register accessor: an alias for `Reg<BAKMEM13_SPEC>`"]
pub type BAKMEM13 = crate :: Reg < bakmem13 :: BAKMEM13_SPEC > ; # [doc = "Battery Backup Memory 13"]
pub mod bakmem13 { # [doc = "Register `BAKMEM13` reader"]
pub struct R (crate :: R < BAKMEM13_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM13_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM13_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM13` writer"]
pub struct W (crate :: W < BAKMEM13_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM13_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM13_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 13\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem13](index.html) module"]
pub struct BAKMEM13_SPEC ; impl crate :: RegisterSpec for BAKMEM13_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem13::R](R) reader structure"]
impl crate :: Readable for BAKMEM13_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem13::W](W) writer structure"]
impl crate :: Writable for BAKMEM13_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM13 to value 0"]
impl crate :: Resettable for BAKMEM13_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM14 register accessor: an alias for `Reg<BAKMEM14_SPEC>`"]
pub type BAKMEM14 = crate :: Reg < bakmem14 :: BAKMEM14_SPEC > ; # [doc = "Battery Backup Memory 14"]
pub mod bakmem14 { # [doc = "Register `BAKMEM14` reader"]
pub struct R (crate :: R < BAKMEM14_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM14_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM14_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM14` writer"]
pub struct W (crate :: W < BAKMEM14_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM14_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM14_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 14\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem14](index.html) module"]
pub struct BAKMEM14_SPEC ; impl crate :: RegisterSpec for BAKMEM14_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem14::R](R) reader structure"]
impl crate :: Readable for BAKMEM14_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem14::W](W) writer structure"]
impl crate :: Writable for BAKMEM14_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM14 to value 0"]
impl crate :: Resettable for BAKMEM14_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAKMEM15 register accessor: an alias for `Reg<BAKMEM15_SPEC>`"]
pub type BAKMEM15 = crate :: Reg < bakmem15 :: BAKMEM15_SPEC > ; # [doc = "Battery Backup Memory 15"]
pub mod bakmem15 { # [doc = "Register `BAKMEM15` reader"]
pub struct R (crate :: R < BAKMEM15_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAKMEM15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAKMEM15_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAKMEM15_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAKMEM15` writer"]
pub struct W (crate :: W < BAKMEM15_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAKMEM15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAKMEM15_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAKMEM15_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Backup Memory 15\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bakmem15](index.html) module"]
pub struct BAKMEM15_SPEC ; impl crate :: RegisterSpec for BAKMEM15_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [bakmem15::R](R) reader structure"]
impl crate :: Readable for BAKMEM15_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bakmem15::W](W) writer structure"]
impl crate :: Writable for BAKMEM15_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAKMEM15 to value 0"]
impl crate :: Resettable for BAKMEM15_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "ADC"]
pub struct ADC { _marker : PhantomData < * const () > } unsafe impl Send for ADC { } impl ADC { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc :: RegisterBlock = 0x0700 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc :: RegisterBlock { Self :: PTR } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC") . finish () } } # [doc = "ADC"]
pub mod adc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - ADC Control 0"]
pub adcctl0 : crate :: Reg < adcctl0 :: ADCCTL0_SPEC > , # [doc = "0x02 - ADC Control 1"]
pub adcctl1 : crate :: Reg < adcctl1 :: ADCCTL1_SPEC > , # [doc = "0x04 - ADC Control 2"]
pub adcctl2 : crate :: Reg < adcctl2 :: ADCCTL2_SPEC > , # [doc = "0x06 - ADC Window Comparator High Threshold"]
pub adclo : crate :: Reg < adclo :: ADCLO_SPEC > , # [doc = "0x08 - ADC Window Comparator High Threshold"]
pub adchi : crate :: Reg < adchi :: ADCHI_SPEC > , # [doc = "0x0a - ADC Memory Control 0"]
pub adcmctl0 : crate :: Reg < adcmctl0 :: ADCMCTL0_SPEC > , _reserved6 : [u8 ; 0x06]
, # [doc = "0x12 - ADC Conversion Memory 0"]
pub adcmem0 : crate :: Reg < adcmem0 :: ADCMEM0_SPEC > , _reserved7 : [u8 ; 0x06]
, # [doc = "0x1a - ADC Interrupt Enable"]
pub adcie : crate :: Reg < adcie :: ADCIE_SPEC > , # [doc = "0x1c - ADC Interrupt Flag"]
pub adcifg : crate :: Reg < adcifg :: ADCIFG_SPEC > , # [doc = "0x1e - ADC Interrupt Vector Word"]
pub adciv : crate :: Reg < adciv :: ADCIV_SPEC > , } # [doc = "ADCCTL0 register accessor: an alias for `Reg<ADCCTL0_SPEC>`"]
pub type ADCCTL0 = crate :: Reg < adcctl0 :: ADCCTL0_SPEC > ; # [doc = "ADC Control 0"]
pub mod adcctl0 { # [doc = "Register `ADCCTL0` reader"]
pub struct R (crate :: R < ADCCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCCTL0` writer"]
pub struct W (crate :: W < ADCCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCCTL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCSC` reader - ADC Start Conversion"]
pub type ADCSC_R = crate :: BitReader < bool > ; # [doc = "Field `ADCSC` writer - ADC Start Conversion"]
pub type ADCSC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL0_SPEC , bool , O > ; # [doc = "Field `ADCENC` reader - ADC Enable Conversion"]
pub type ADCENC_R = crate :: BitReader < bool > ; # [doc = "Field `ADCENC` writer - ADC Enable Conversion"]
pub type ADCENC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL0_SPEC , bool , O > ; # [doc = "Field `ADCON` reader - ADC On/enable"]
pub type ADCON_R = crate :: BitReader < bool > ; # [doc = "Field `ADCON` writer - ADC On/enable"]
pub type ADCON_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL0_SPEC , bool , O > ; # [doc = "Field `ADCMSC` reader - ADC Multiple SampleConversion"]
pub type ADCMSC_R = crate :: BitReader < bool > ; # [doc = "Field `ADCMSC` writer - ADC Multiple SampleConversion"]
pub type ADCMSC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL0_SPEC , bool , O > ; # [doc = "ADC Sample Hold Select Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCSHT_A { # [doc = "0: ADC Sample Hold Select 0"]
ADCSHT_0 = 0 , # [doc = "1: ADC Sample Hold Select 1"]
ADCSHT_1 = 1 , # [doc = "2: ADC Sample Hold Select 2"]
ADCSHT_2 = 2 , # [doc = "3: ADC Sample Hold Select 3"]
ADCSHT_3 = 3 , # [doc = "4: ADC Sample Hold Select 4"]
ADCSHT_4 = 4 , # [doc = "5: ADC Sample Hold Select 5"]
ADCSHT_5 = 5 , # [doc = "6: ADC Sample Hold Select 6"]
ADCSHT_6 = 6 , # [doc = "7: ADC Sample Hold Select 7"]
ADCSHT_7 = 7 , # [doc = "8: ADC Sample Hold Select 8"]
ADCSHT_8 = 8 , # [doc = "9: ADC Sample Hold Select 9"]
ADCSHT_9 = 9 , # [doc = "10: ADC Sample Hold Select 10"]
ADCSHT_10 = 10 , # [doc = "11: ADC Sample Hold Select 11"]
ADCSHT_11 = 11 , # [doc = "12: ADC Sample Hold Select 12"]
ADCSHT_12 = 12 , # [doc = "13: ADC Sample Hold Select 13"]
ADCSHT_13 = 13 , # [doc = "14: ADC Sample Hold Select 14"]
ADCSHT_14 = 14 , # [doc = "15: ADC Sample Hold Select 15"]
ADCSHT_15 = 15 , } impl From < ADCSHT_A > for u8 { # [inline (always)]
fn from (variant : ADCSHT_A) -> Self { variant as _ } } # [doc = "Field `ADCSHT` reader - ADC Sample Hold Select Bit: 0"]
pub type ADCSHT_R = crate :: FieldReader < u8 , ADCSHT_A > ; impl ADCSHT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCSHT_A { match self . bits { 0 => ADCSHT_A :: ADCSHT_0 , 1 => ADCSHT_A :: ADCSHT_1 , 2 => ADCSHT_A :: ADCSHT_2 , 3 => ADCSHT_A :: ADCSHT_3 , 4 => ADCSHT_A :: ADCSHT_4 , 5 => ADCSHT_A :: ADCSHT_5 , 6 => ADCSHT_A :: ADCSHT_6 , 7 => ADCSHT_A :: ADCSHT_7 , 8 => ADCSHT_A :: ADCSHT_8 , 9 => ADCSHT_A :: ADCSHT_9 , 10 => ADCSHT_A :: ADCSHT_10 , 11 => ADCSHT_A :: ADCSHT_11 , 12 => ADCSHT_A :: ADCSHT_12 , 13 => ADCSHT_A :: ADCSHT_13 , 14 => ADCSHT_A :: ADCSHT_14 , 15 => ADCSHT_A :: ADCSHT_15 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCSHT_0`"]
# [inline (always)]
pub fn is_adcsht_0 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_0 } # [doc = "Checks if the value of the field is `ADCSHT_1`"]
# [inline (always)]
pub fn is_adcsht_1 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_1 } # [doc = "Checks if the value of the field is `ADCSHT_2`"]
# [inline (always)]
pub fn is_adcsht_2 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_2 } # [doc = "Checks if the value of the field is `ADCSHT_3`"]
# [inline (always)]
pub fn is_adcsht_3 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_3 } # [doc = "Checks if the value of the field is `ADCSHT_4`"]
# [inline (always)]
pub fn is_adcsht_4 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_4 } # [doc = "Checks if the value of the field is `ADCSHT_5`"]
# [inline (always)]
pub fn is_adcsht_5 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_5 } # [doc = "Checks if the value of the field is `ADCSHT_6`"]
# [inline (always)]
pub fn is_adcsht_6 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_6 } # [doc = "Checks if the value of the field is `ADCSHT_7`"]
# [inline (always)]
pub fn is_adcsht_7 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_7 } # [doc = "Checks if the value of the field is `ADCSHT_8`"]
# [inline (always)]
pub fn is_adcsht_8 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_8 } # [doc = "Checks if the value of the field is `ADCSHT_9`"]
# [inline (always)]
pub fn is_adcsht_9 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_9 } # [doc = "Checks if the value of the field is `ADCSHT_10`"]
# [inline (always)]
pub fn is_adcsht_10 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_10 } # [doc = "Checks if the value of the field is `ADCSHT_11`"]
# [inline (always)]
pub fn is_adcsht_11 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_11 } # [doc = "Checks if the value of the field is `ADCSHT_12`"]
# [inline (always)]
pub fn is_adcsht_12 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_12 } # [doc = "Checks if the value of the field is `ADCSHT_13`"]
# [inline (always)]
pub fn is_adcsht_13 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_13 } # [doc = "Checks if the value of the field is `ADCSHT_14`"]
# [inline (always)]
pub fn is_adcsht_14 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_14 } # [doc = "Checks if the value of the field is `ADCSHT_15`"]
# [inline (always)]
pub fn is_adcsht_15 (& self) -> bool { * self == ADCSHT_A :: ADCSHT_15 } } # [doc = "Field `ADCSHT` writer - ADC Sample Hold Select Bit: 0"]
pub type ADCSHT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL0_SPEC , u8 , ADCSHT_A , 4 , O > ; impl < 'a , const O : u8 > ADCSHT_W < 'a , O > { # [doc = "ADC Sample Hold Select 0"]
# [inline (always)]
pub fn adcsht_0 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_0) } # [doc = "ADC Sample Hold Select 1"]
# [inline (always)]
pub fn adcsht_1 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_1) } # [doc = "ADC Sample Hold Select 2"]
# [inline (always)]
pub fn adcsht_2 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_2) } # [doc = "ADC Sample Hold Select 3"]
# [inline (always)]
pub fn adcsht_3 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_3) } # [doc = "ADC Sample Hold Select 4"]
# [inline (always)]
pub fn adcsht_4 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_4) } # [doc = "ADC Sample Hold Select 5"]
# [inline (always)]
pub fn adcsht_5 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_5) } # [doc = "ADC Sample Hold Select 6"]
# [inline (always)]
pub fn adcsht_6 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_6) } # [doc = "ADC Sample Hold Select 7"]
# [inline (always)]
pub fn adcsht_7 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_7) } # [doc = "ADC Sample Hold Select 8"]
# [inline (always)]
pub fn adcsht_8 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_8) } # [doc = "ADC Sample Hold Select 9"]
# [inline (always)]
pub fn adcsht_9 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_9) } # [doc = "ADC Sample Hold Select 10"]
# [inline (always)]
pub fn adcsht_10 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_10) } # [doc = "ADC Sample Hold Select 11"]
# [inline (always)]
pub fn adcsht_11 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_11) } # [doc = "ADC Sample Hold Select 12"]
# [inline (always)]
pub fn adcsht_12 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_12) } # [doc = "ADC Sample Hold Select 13"]
# [inline (always)]
pub fn adcsht_13 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_13) } # [doc = "ADC Sample Hold Select 14"]
# [inline (always)]
pub fn adcsht_14 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_14) } # [doc = "ADC Sample Hold Select 15"]
# [inline (always)]
pub fn adcsht_15 (self) -> & 'a mut W { self . variant (ADCSHT_A :: ADCSHT_15) } } impl R { # [doc = "Bit 0 - ADC Start Conversion"]
# [inline (always)]
pub fn adcsc (& self) -> ADCSC_R { ADCSC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Enable Conversion"]
# [inline (always)]
pub fn adcenc (& self) -> ADCENC_R { ADCENC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - ADC On/enable"]
# [inline (always)]
pub fn adcon (& self) -> ADCON_R { ADCON_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - ADC Multiple SampleConversion"]
# [inline (always)]
pub fn adcmsc (& self) -> ADCMSC_R { ADCMSC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - ADC Sample Hold Select Bit: 0"]
# [inline (always)]
pub fn adcsht (& self) -> ADCSHT_R { ADCSHT_R :: new (((self . bits >> 8) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - ADC Start Conversion"]
# [inline (always)]
pub fn adcsc (& mut self) -> ADCSC_W < 0 > { ADCSC_W :: new (self) } # [doc = "Bit 1 - ADC Enable Conversion"]
# [inline (always)]
pub fn adcenc (& mut self) -> ADCENC_W < 1 > { ADCENC_W :: new (self) } # [doc = "Bit 4 - ADC On/enable"]
# [inline (always)]
pub fn adcon (& mut self) -> ADCON_W < 4 > { ADCON_W :: new (self) } # [doc = "Bit 7 - ADC Multiple SampleConversion"]
# [inline (always)]
pub fn adcmsc (& mut self) -> ADCMSC_W < 7 > { ADCMSC_W :: new (self) } # [doc = "Bits 8:11 - ADC Sample Hold Select Bit: 0"]
# [inline (always)]
pub fn adcsht (& mut self) -> ADCSHT_W < 8 > { ADCSHT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl0](index.html) module"]
pub struct ADCCTL0_SPEC ; impl crate :: RegisterSpec for ADCCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcctl0::R](R) reader structure"]
impl crate :: Readable for ADCCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcctl0::W](W) writer structure"]
impl crate :: Writable for ADCCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCCTL0 to value 0"]
impl crate :: Resettable for ADCCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCCTL1 register accessor: an alias for `Reg<ADCCTL1_SPEC>`"]
pub type ADCCTL1 = crate :: Reg < adcctl1 :: ADCCTL1_SPEC > ; # [doc = "ADC Control 1"]
pub mod adcctl1 { # [doc = "Register `ADCCTL1` reader"]
pub struct R (crate :: R < ADCCTL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCCTL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCCTL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCCTL1` writer"]
pub struct W (crate :: W < ADCCTL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCCTL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCCTL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCCTL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCBUSY` reader - ADC Busy"]
pub type ADCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `ADCBUSY` writer - ADC Busy"]
pub type ADCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL1_SPEC , bool , O > ; # [doc = "ADC Conversion Sequence Select 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCCONSEQ_A { # [doc = "0: ADC Conversion Sequence Select: 0"]
ADCCONSEQ_0 = 0 , # [doc = "1: ADC Conversion Sequence Select: 1"]
ADCCONSEQ_1 = 1 , # [doc = "2: ADC Conversion Sequence Select: 2"]
ADCCONSEQ_2 = 2 , # [doc = "3: ADC Conversion Sequence Select: 3"]
ADCCONSEQ_3 = 3 , } impl From < ADCCONSEQ_A > for u8 { # [inline (always)]
fn from (variant : ADCCONSEQ_A) -> Self { variant as _ } } # [doc = "Field `ADCCONSEQ` reader - ADC Conversion Sequence Select 0"]
pub type ADCCONSEQ_R = crate :: FieldReader < u8 , ADCCONSEQ_A > ; impl ADCCONSEQ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCCONSEQ_A { match self . bits { 0 => ADCCONSEQ_A :: ADCCONSEQ_0 , 1 => ADCCONSEQ_A :: ADCCONSEQ_1 , 2 => ADCCONSEQ_A :: ADCCONSEQ_2 , 3 => ADCCONSEQ_A :: ADCCONSEQ_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCCONSEQ_0`"]
# [inline (always)]
pub fn is_adcconseq_0 (& self) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_0 } # [doc = "Checks if the value of the field is `ADCCONSEQ_1`"]
# [inline (always)]
pub fn is_adcconseq_1 (& self) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_1 } # [doc = "Checks if the value of the field is `ADCCONSEQ_2`"]
# [inline (always)]
pub fn is_adcconseq_2 (& self) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_2 } # [doc = "Checks if the value of the field is `ADCCONSEQ_3`"]
# [inline (always)]
pub fn is_adcconseq_3 (& self) -> bool { * self == ADCCONSEQ_A :: ADCCONSEQ_3 } } # [doc = "Field `ADCCONSEQ` writer - ADC Conversion Sequence Select 0"]
pub type ADCCONSEQ_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL1_SPEC , u8 , ADCCONSEQ_A , 2 , O > ; impl < 'a , const O : u8 > ADCCONSEQ_W < 'a , O > { # [doc = "ADC Conversion Sequence Select: 0"]
# [inline (always)]
pub fn adcconseq_0 (self) -> & 'a mut W { self . variant (ADCCONSEQ_A :: ADCCONSEQ_0) } # [doc = "ADC Conversion Sequence Select: 1"]
# [inline (always)]
pub fn adcconseq_1 (self) -> & 'a mut W { self . variant (ADCCONSEQ_A :: ADCCONSEQ_1) } # [doc = "ADC Conversion Sequence Select: 2"]
# [inline (always)]
pub fn adcconseq_2 (self) -> & 'a mut W { self . variant (ADCCONSEQ_A :: ADCCONSEQ_2) } # [doc = "ADC Conversion Sequence Select: 3"]
# [inline (always)]
pub fn adcconseq_3 (self) -> & 'a mut W { self . variant (ADCCONSEQ_A :: ADCCONSEQ_3) } } # [doc = "ADC Clock Source Select 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCSSEL_A { # [doc = "0: ADC Clock Source Select: 0"]
ADCSSEL_0 = 0 , # [doc = "1: ADC Clock Source Select: 1"]
ADCSSEL_1 = 1 , # [doc = "2: ADC Clock Source Select: 2"]
ADCSSEL_2 = 2 , # [doc = "3: ADC Clock Source Select: 3"]
ADCSSEL_3 = 3 , } impl From < ADCSSEL_A > for u8 { # [inline (always)]
fn from (variant : ADCSSEL_A) -> Self { variant as _ } } # [doc = "Field `ADCSSEL` reader - ADC Clock Source Select 0"]
pub type ADCSSEL_R = crate :: FieldReader < u8 , ADCSSEL_A > ; impl ADCSSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCSSEL_A { match self . bits { 0 => ADCSSEL_A :: ADCSSEL_0 , 1 => ADCSSEL_A :: ADCSSEL_1 , 2 => ADCSSEL_A :: ADCSSEL_2 , 3 => ADCSSEL_A :: ADCSSEL_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCSSEL_0`"]
# [inline (always)]
pub fn is_adcssel_0 (& self) -> bool { * self == ADCSSEL_A :: ADCSSEL_0 } # [doc = "Checks if the value of the field is `ADCSSEL_1`"]
# [inline (always)]
pub fn is_adcssel_1 (& self) -> bool { * self == ADCSSEL_A :: ADCSSEL_1 } # [doc = "Checks if the value of the field is `ADCSSEL_2`"]
# [inline (always)]
pub fn is_adcssel_2 (& self) -> bool { * self == ADCSSEL_A :: ADCSSEL_2 } # [doc = "Checks if the value of the field is `ADCSSEL_3`"]
# [inline (always)]
pub fn is_adcssel_3 (& self) -> bool { * self == ADCSSEL_A :: ADCSSEL_3 } } # [doc = "Field `ADCSSEL` writer - ADC Clock Source Select 0"]
pub type ADCSSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL1_SPEC , u8 , ADCSSEL_A , 2 , O > ; impl < 'a , const O : u8 > ADCSSEL_W < 'a , O > { # [doc = "ADC Clock Source Select: 0"]
# [inline (always)]
pub fn adcssel_0 (self) -> & 'a mut W { self . variant (ADCSSEL_A :: ADCSSEL_0) } # [doc = "ADC Clock Source Select: 1"]
# [inline (always)]
pub fn adcssel_1 (self) -> & 'a mut W { self . variant (ADCSSEL_A :: ADCSSEL_1) } # [doc = "ADC Clock Source Select: 2"]
# [inline (always)]
pub fn adcssel_2 (self) -> & 'a mut W { self . variant (ADCSSEL_A :: ADCSSEL_2) } # [doc = "ADC Clock Source Select: 3"]
# [inline (always)]
pub fn adcssel_3 (self) -> & 'a mut W { self . variant (ADCSSEL_A :: ADCSSEL_3) } } # [doc = "ADC Clock Divider Select 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCDIV_A { # [doc = "0: ADC Clock Divider Select: 0"]
ADCDIV_0 = 0 , # [doc = "1: ADC Clock Divider Select: 1"]
ADCDIV_1 = 1 , # [doc = "2: ADC Clock Divider Select: 2"]
ADCDIV_2 = 2 , # [doc = "3: ADC Clock Divider Select: 3"]
ADCDIV_3 = 3 , # [doc = "4: ADC Clock Divider Select: 4"]
ADCDIV_4 = 4 , # [doc = "5: ADC Clock Divider Select: 5"]
ADCDIV_5 = 5 , # [doc = "6: ADC Clock Divider Select: 6"]
ADCDIV_6 = 6 , # [doc = "7: ADC Clock Divider Select: 7"]
ADCDIV_7 = 7 , } impl From < ADCDIV_A > for u8 { # [inline (always)]
fn from (variant : ADCDIV_A) -> Self { variant as _ } } # [doc = "Field `ADCDIV` reader - ADC Clock Divider Select 0"]
pub type ADCDIV_R = crate :: FieldReader < u8 , ADCDIV_A > ; impl ADCDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCDIV_A { match self . bits { 0 => ADCDIV_A :: ADCDIV_0 , 1 => ADCDIV_A :: ADCDIV_1 , 2 => ADCDIV_A :: ADCDIV_2 , 3 => ADCDIV_A :: ADCDIV_3 , 4 => ADCDIV_A :: ADCDIV_4 , 5 => ADCDIV_A :: ADCDIV_5 , 6 => ADCDIV_A :: ADCDIV_6 , 7 => ADCDIV_A :: ADCDIV_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCDIV_0`"]
# [inline (always)]
pub fn is_adcdiv_0 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_0 } # [doc = "Checks if the value of the field is `ADCDIV_1`"]
# [inline (always)]
pub fn is_adcdiv_1 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_1 } # [doc = "Checks if the value of the field is `ADCDIV_2`"]
# [inline (always)]
pub fn is_adcdiv_2 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_2 } # [doc = "Checks if the value of the field is `ADCDIV_3`"]
# [inline (always)]
pub fn is_adcdiv_3 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_3 } # [doc = "Checks if the value of the field is `ADCDIV_4`"]
# [inline (always)]
pub fn is_adcdiv_4 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_4 } # [doc = "Checks if the value of the field is `ADCDIV_5`"]
# [inline (always)]
pub fn is_adcdiv_5 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_5 } # [doc = "Checks if the value of the field is `ADCDIV_6`"]
# [inline (always)]
pub fn is_adcdiv_6 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_6 } # [doc = "Checks if the value of the field is `ADCDIV_7`"]
# [inline (always)]
pub fn is_adcdiv_7 (& self) -> bool { * self == ADCDIV_A :: ADCDIV_7 } } # [doc = "Field `ADCDIV` writer - ADC Clock Divider Select 0"]
pub type ADCDIV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL1_SPEC , u8 , ADCDIV_A , 3 , O > ; impl < 'a , const O : u8 > ADCDIV_W < 'a , O > { # [doc = "ADC Clock Divider Select: 0"]
# [inline (always)]
pub fn adcdiv_0 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_0) } # [doc = "ADC Clock Divider Select: 1"]
# [inline (always)]
pub fn adcdiv_1 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_1) } # [doc = "ADC Clock Divider Select: 2"]
# [inline (always)]
pub fn adcdiv_2 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_2) } # [doc = "ADC Clock Divider Select: 3"]
# [inline (always)]
pub fn adcdiv_3 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_3) } # [doc = "ADC Clock Divider Select: 4"]
# [inline (always)]
pub fn adcdiv_4 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_4) } # [doc = "ADC Clock Divider Select: 5"]
# [inline (always)]
pub fn adcdiv_5 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_5) } # [doc = "ADC Clock Divider Select: 6"]
# [inline (always)]
pub fn adcdiv_6 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_6) } # [doc = "ADC Clock Divider Select: 7"]
# [inline (always)]
pub fn adcdiv_7 (self) -> & 'a mut W { self . variant (ADCDIV_A :: ADCDIV_7) } } # [doc = "Field `ADCISSH` reader - ADC Invert Sample Hold Signal"]
pub type ADCISSH_R = crate :: BitReader < bool > ; # [doc = "Field `ADCISSH` writer - ADC Invert Sample Hold Signal"]
pub type ADCISSH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL1_SPEC , bool , O > ; # [doc = "Field `ADCSHP` reader - ADC Sample/Hold Pulse Mode"]
pub type ADCSHP_R = crate :: BitReader < bool > ; # [doc = "Field `ADCSHP` writer - ADC Sample/Hold Pulse Mode"]
pub type ADCSHP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL1_SPEC , bool , O > ; # [doc = "ADC Sample/Hold Source 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCSHS_A { # [doc = "0: ADC Sample/Hold Source: 0"]
ADCSHS_0 = 0 , # [doc = "1: ADC Sample/Hold Source: 1"]
ADCSHS_1 = 1 , # [doc = "2: ADC Sample/Hold Source: 2"]
ADCSHS_2 = 2 , # [doc = "3: ADC Sample/Hold Source: 3"]
ADCSHS_3 = 3 , } impl From < ADCSHS_A > for u8 { # [inline (always)]
fn from (variant : ADCSHS_A) -> Self { variant as _ } } # [doc = "Field `ADCSHS` reader - ADC Sample/Hold Source 0"]
pub type ADCSHS_R = crate :: FieldReader < u8 , ADCSHS_A > ; impl ADCSHS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCSHS_A { match self . bits { 0 => ADCSHS_A :: ADCSHS_0 , 1 => ADCSHS_A :: ADCSHS_1 , 2 => ADCSHS_A :: ADCSHS_2 , 3 => ADCSHS_A :: ADCSHS_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCSHS_0`"]
# [inline (always)]
pub fn is_adcshs_0 (& self) -> bool { * self == ADCSHS_A :: ADCSHS_0 } # [doc = "Checks if the value of the field is `ADCSHS_1`"]
# [inline (always)]
pub fn is_adcshs_1 (& self) -> bool { * self == ADCSHS_A :: ADCSHS_1 } # [doc = "Checks if the value of the field is `ADCSHS_2`"]
# [inline (always)]
pub fn is_adcshs_2 (& self) -> bool { * self == ADCSHS_A :: ADCSHS_2 } # [doc = "Checks if the value of the field is `ADCSHS_3`"]
# [inline (always)]
pub fn is_adcshs_3 (& self) -> bool { * self == ADCSHS_A :: ADCSHS_3 } } # [doc = "Field `ADCSHS` writer - ADC Sample/Hold Source 0"]
pub type ADCSHS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL1_SPEC , u8 , ADCSHS_A , 2 , O > ; impl < 'a , const O : u8 > ADCSHS_W < 'a , O > { # [doc = "ADC Sample/Hold Source: 0"]
# [inline (always)]
pub fn adcshs_0 (self) -> & 'a mut W { self . variant (ADCSHS_A :: ADCSHS_0) } # [doc = "ADC Sample/Hold Source: 1"]
# [inline (always)]
pub fn adcshs_1 (self) -> & 'a mut W { self . variant (ADCSHS_A :: ADCSHS_1) } # [doc = "ADC Sample/Hold Source: 2"]
# [inline (always)]
pub fn adcshs_2 (self) -> & 'a mut W { self . variant (ADCSHS_A :: ADCSHS_2) } # [doc = "ADC Sample/Hold Source: 3"]
# [inline (always)]
pub fn adcshs_3 (self) -> & 'a mut W { self . variant (ADCSHS_A :: ADCSHS_3) } } impl R { # [doc = "Bit 0 - ADC Busy"]
# [inline (always)]
pub fn adcbusy (& self) -> ADCBUSY_R { ADCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - ADC Conversion Sequence Select 0"]
# [inline (always)]
pub fn adcconseq (& self) -> ADCCONSEQ_R { ADCCONSEQ_R :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bits 3:4 - ADC Clock Source Select 0"]
# [inline (always)]
pub fn adcssel (& self) -> ADCSSEL_R { ADCSSEL_R :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 5:7 - ADC Clock Divider Select 0"]
# [inline (always)]
pub fn adcdiv (& self) -> ADCDIV_R { ADCDIV_R :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - ADC Invert Sample Hold Signal"]
# [inline (always)]
pub fn adcissh (& self) -> ADCISSH_R { ADCISSH_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - ADC Sample/Hold Pulse Mode"]
# [inline (always)]
pub fn adcshp (& self) -> ADCSHP_R { ADCSHP_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bits 10:11 - ADC Sample/Hold Source 0"]
# [inline (always)]
pub fn adcshs (& self) -> ADCSHS_R { ADCSHS_R :: new (((self . bits >> 10) & 3) as u8) } } impl W { # [doc = "Bit 0 - ADC Busy"]
# [inline (always)]
pub fn adcbusy (& mut self) -> ADCBUSY_W < 0 > { ADCBUSY_W :: new (self) } # [doc = "Bits 1:2 - ADC Conversion Sequence Select 0"]
# [inline (always)]
pub fn adcconseq (& mut self) -> ADCCONSEQ_W < 1 > { ADCCONSEQ_W :: new (self) } # [doc = "Bits 3:4 - ADC Clock Source Select 0"]
# [inline (always)]
pub fn adcssel (& mut self) -> ADCSSEL_W < 3 > { ADCSSEL_W :: new (self) } # [doc = "Bits 5:7 - ADC Clock Divider Select 0"]
# [inline (always)]
pub fn adcdiv (& mut self) -> ADCDIV_W < 5 > { ADCDIV_W :: new (self) } # [doc = "Bit 8 - ADC Invert Sample Hold Signal"]
# [inline (always)]
pub fn adcissh (& mut self) -> ADCISSH_W < 8 > { ADCISSH_W :: new (self) } # [doc = "Bit 9 - ADC Sample/Hold Pulse Mode"]
# [inline (always)]
pub fn adcshp (& mut self) -> ADCSHP_W < 9 > { ADCSHP_W :: new (self) } # [doc = "Bits 10:11 - ADC Sample/Hold Source 0"]
# [inline (always)]
pub fn adcshs (& mut self) -> ADCSHS_W < 10 > { ADCSHS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl1](index.html) module"]
pub struct ADCCTL1_SPEC ; impl crate :: RegisterSpec for ADCCTL1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcctl1::R](R) reader structure"]
impl crate :: Readable for ADCCTL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcctl1::W](W) writer structure"]
impl crate :: Writable for ADCCTL1_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCCTL1 to value 0"]
impl crate :: Resettable for ADCCTL1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCCTL2 register accessor: an alias for `Reg<ADCCTL2_SPEC>`"]
pub type ADCCTL2 = crate :: Reg < adcctl2 :: ADCCTL2_SPEC > ; # [doc = "ADC Control 2"]
pub mod adcctl2 { # [doc = "Register `ADCCTL2` reader"]
pub struct R (crate :: R < ADCCTL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCCTL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCCTL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCCTL2` writer"]
pub struct W (crate :: W < ADCCTL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCCTL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCCTL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCCTL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCSR` reader - ADC Sampling Rate"]
pub type ADCSR_R = crate :: BitReader < bool > ; # [doc = "Field `ADCSR` writer - ADC Sampling Rate"]
pub type ADCSR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL2_SPEC , bool , O > ; # [doc = "Field `ADCDF` reader - ADC Data Format"]
pub type ADCDF_R = crate :: BitReader < bool > ; # [doc = "Field `ADCDF` writer - ADC Data Format"]
pub type ADCDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCCTL2_SPEC , bool , O > ; # [doc = "ADC Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCRES_A { # [doc = "0: 8 bit"]
ADCRES_0 = 0 , # [doc = "1: 10 bit"]
ADCRES_1 = 1 , # [doc = "2: Reserved"]
ADCRES_2 = 2 , # [doc = "3: Reserved"]
ADCRES_3 = 3 , } impl From < ADCRES_A > for u8 { # [inline (always)]
fn from (variant : ADCRES_A) -> Self { variant as _ } } # [doc = "Field `ADCRES` reader - ADC Resolution"]
pub type ADCRES_R = crate :: FieldReader < u8 , ADCRES_A > ; impl ADCRES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCRES_A { match self . bits { 0 => ADCRES_A :: ADCRES_0 , 1 => ADCRES_A :: ADCRES_1 , 2 => ADCRES_A :: ADCRES_2 , 3 => ADCRES_A :: ADCRES_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCRES_0`"]
# [inline (always)]
pub fn is_adcres_0 (& self) -> bool { * self == ADCRES_A :: ADCRES_0 } # [doc = "Checks if the value of the field is `ADCRES_1`"]
# [inline (always)]
pub fn is_adcres_1 (& self) -> bool { * self == ADCRES_A :: ADCRES_1 } # [doc = "Checks if the value of the field is `ADCRES_2`"]
# [inline (always)]
pub fn is_adcres_2 (& self) -> bool { * self == ADCRES_A :: ADCRES_2 } # [doc = "Checks if the value of the field is `ADCRES_3`"]
# [inline (always)]
pub fn is_adcres_3 (& self) -> bool { * self == ADCRES_A :: ADCRES_3 } } # [doc = "Field `ADCRES` writer - ADC Resolution"]
pub type ADCRES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL2_SPEC , u8 , ADCRES_A , 2 , O > ; impl < 'a , const O : u8 > ADCRES_W < 'a , O > { # [doc = "8 bit"]
# [inline (always)]
pub fn adcres_0 (self) -> & 'a mut W { self . variant (ADCRES_A :: ADCRES_0) } # [doc = "10 bit"]
# [inline (always)]
pub fn adcres_1 (self) -> & 'a mut W { self . variant (ADCRES_A :: ADCRES_1) } # [doc = "Reserved"]
# [inline (always)]
pub fn adcres_2 (self) -> & 'a mut W { self . variant (ADCRES_A :: ADCRES_2) } # [doc = "Reserved"]
# [inline (always)]
pub fn adcres_3 (self) -> & 'a mut W { self . variant (ADCRES_A :: ADCRES_3) } } # [doc = "ADC predivider Bit: 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCPDIV_A { # [doc = "0: ADC predivider /1"]
ADCPDIV_0 = 0 , # [doc = "1: ADC predivider /2"]
ADCPDIV_1 = 1 , # [doc = "2: ADC predivider /64"]
ADCPDIV_2 = 2 , # [doc = "3: ADC predivider reserved"]
ADCPDIV_3 = 3 , } impl From < ADCPDIV_A > for u8 { # [inline (always)]
fn from (variant : ADCPDIV_A) -> Self { variant as _ } } # [doc = "Field `ADCPDIV` reader - ADC predivider Bit: 0"]
pub type ADCPDIV_R = crate :: FieldReader < u8 , ADCPDIV_A > ; impl ADCPDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCPDIV_A { match self . bits { 0 => ADCPDIV_A :: ADCPDIV_0 , 1 => ADCPDIV_A :: ADCPDIV_1 , 2 => ADCPDIV_A :: ADCPDIV_2 , 3 => ADCPDIV_A :: ADCPDIV_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCPDIV_0`"]
# [inline (always)]
pub fn is_adcpdiv_0 (& self) -> bool { * self == ADCPDIV_A :: ADCPDIV_0 } # [doc = "Checks if the value of the field is `ADCPDIV_1`"]
# [inline (always)]
pub fn is_adcpdiv_1 (& self) -> bool { * self == ADCPDIV_A :: ADCPDIV_1 } # [doc = "Checks if the value of the field is `ADCPDIV_2`"]
# [inline (always)]
pub fn is_adcpdiv_2 (& self) -> bool { * self == ADCPDIV_A :: ADCPDIV_2 } # [doc = "Checks if the value of the field is `ADCPDIV_3`"]
# [inline (always)]
pub fn is_adcpdiv_3 (& self) -> bool { * self == ADCPDIV_A :: ADCPDIV_3 } } # [doc = "Field `ADCPDIV` writer - ADC predivider Bit: 0"]
pub type ADCPDIV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCCTL2_SPEC , u8 , ADCPDIV_A , 2 , O > ; impl < 'a , const O : u8 > ADCPDIV_W < 'a , O > { # [doc = "ADC predivider /1"]
# [inline (always)]
pub fn adcpdiv_0 (self) -> & 'a mut W { self . variant (ADCPDIV_A :: ADCPDIV_0) } # [doc = "ADC predivider /2"]
# [inline (always)]
pub fn adcpdiv_1 (self) -> & 'a mut W { self . variant (ADCPDIV_A :: ADCPDIV_1) } # [doc = "ADC predivider /64"]
# [inline (always)]
pub fn adcpdiv_2 (self) -> & 'a mut W { self . variant (ADCPDIV_A :: ADCPDIV_2) } # [doc = "ADC predivider reserved"]
# [inline (always)]
pub fn adcpdiv_3 (self) -> & 'a mut W { self . variant (ADCPDIV_A :: ADCPDIV_3) } } impl R { # [doc = "Bit 2 - ADC Sampling Rate"]
# [inline (always)]
pub fn adcsr (& self) -> ADCSR_R { ADCSR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - ADC Data Format"]
# [inline (always)]
pub fn adcdf (& self) -> ADCDF_R { ADCDF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - ADC Resolution"]
# [inline (always)]
pub fn adcres (& self) -> ADCRES_R { ADCRES_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 8:9 - ADC predivider Bit: 0"]
# [inline (always)]
pub fn adcpdiv (& self) -> ADCPDIV_R { ADCPDIV_R :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 2 - ADC Sampling Rate"]
# [inline (always)]
pub fn adcsr (& mut self) -> ADCSR_W < 2 > { ADCSR_W :: new (self) } # [doc = "Bit 3 - ADC Data Format"]
# [inline (always)]
pub fn adcdf (& mut self) -> ADCDF_W < 3 > { ADCDF_W :: new (self) } # [doc = "Bits 4:5 - ADC Resolution"]
# [inline (always)]
pub fn adcres (& mut self) -> ADCRES_W < 4 > { ADCRES_W :: new (self) } # [doc = "Bits 8:9 - ADC predivider Bit: 0"]
# [inline (always)]
pub fn adcpdiv (& mut self) -> ADCPDIV_W < 8 > { ADCPDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Control 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl2](index.html) module"]
pub struct ADCCTL2_SPEC ; impl crate :: RegisterSpec for ADCCTL2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcctl2::R](R) reader structure"]
impl crate :: Readable for ADCCTL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcctl2::W](W) writer structure"]
impl crate :: Writable for ADCCTL2_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCCTL2 to value 0"]
impl crate :: Resettable for ADCCTL2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCLO register accessor: an alias for `Reg<ADCLO_SPEC>`"]
pub type ADCLO = crate :: Reg < adclo :: ADCLO_SPEC > ; # [doc = "ADC Window Comparator High Threshold"]
pub mod adclo { # [doc = "Register `ADCLO` reader"]
pub struct R (crate :: R < ADCLO_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCLO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCLO_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCLO_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCLO` writer"]
pub struct W (crate :: W < ADCLO_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCLO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCLO_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCLO_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Window Comparator High Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adclo](index.html) module"]
pub struct ADCLO_SPEC ; impl crate :: RegisterSpec for ADCLO_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adclo::R](R) reader structure"]
impl crate :: Readable for ADCLO_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adclo::W](W) writer structure"]
impl crate :: Writable for ADCLO_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCLO to value 0"]
impl crate :: Resettable for ADCLO_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCHI register accessor: an alias for `Reg<ADCHI_SPEC>`"]
pub type ADCHI = crate :: Reg < adchi :: ADCHI_SPEC > ; # [doc = "ADC Window Comparator High Threshold"]
pub mod adchi { # [doc = "Register `ADCHI` reader"]
pub struct R (crate :: R < ADCHI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCHI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCHI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCHI_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCHI` writer"]
pub struct W (crate :: W < ADCHI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCHI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCHI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCHI_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Window Comparator High Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adchi](index.html) module"]
pub struct ADCHI_SPEC ; impl crate :: RegisterSpec for ADCHI_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adchi::R](R) reader structure"]
impl crate :: Readable for ADCHI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adchi::W](W) writer structure"]
impl crate :: Writable for ADCHI_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCHI to value 0"]
impl crate :: Resettable for ADCHI_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCMCTL0 register accessor: an alias for `Reg<ADCMCTL0_SPEC>`"]
pub type ADCMCTL0 = crate :: Reg < adcmctl0 :: ADCMCTL0_SPEC > ; # [doc = "ADC Memory Control 0"]
pub mod adcmctl0 { # [doc = "Register `ADCMCTL0` reader"]
pub struct R (crate :: R < ADCMCTL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCMCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCMCTL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCMCTL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCMCTL0` writer"]
pub struct W (crate :: W < ADCMCTL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCMCTL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCMCTL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCMCTL0_SPEC >) -> Self { W (writer) } } # [doc = "ADC Input Channel Select Bit 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCINCH_A { # [doc = "0: ADC Input Channel 0"]
ADCINCH_0 = 0 , # [doc = "1: ADC Input Channel 1"]
ADCINCH_1 = 1 , # [doc = "2: ADC Input Channel 2"]
ADCINCH_2 = 2 , # [doc = "3: ADC Input Channel 3"]
ADCINCH_3 = 3 , # [doc = "4: ADC Input Channel 4"]
ADCINCH_4 = 4 , # [doc = "5: ADC Input Channel 5"]
ADCINCH_5 = 5 , # [doc = "6: ADC Input Channel 6"]
ADCINCH_6 = 6 , # [doc = "7: ADC Input Channel 7"]
ADCINCH_7 = 7 , # [doc = "8: ADC Input Channel 8"]
ADCINCH_8 = 8 , # [doc = "9: ADC Input Channel 9"]
ADCINCH_9 = 9 , # [doc = "10: ADC Input Channel 10"]
ADCINCH_10 = 10 , # [doc = "11: ADC Input Channel 11"]
ADCINCH_11 = 11 , # [doc = "12: ADC Input Channel 12"]
ADCINCH_12 = 12 , # [doc = "13: ADC Input Channel 13"]
ADCINCH_13 = 13 , # [doc = "14: ADC Input Channel 14"]
ADCINCH_14 = 14 , # [doc = "15: ADC Input Channel 15"]
ADCINCH_15 = 15 , } impl From < ADCINCH_A > for u8 { # [inline (always)]
fn from (variant : ADCINCH_A) -> Self { variant as _ } } # [doc = "Field `ADCINCH` reader - ADC Input Channel Select Bit 0"]
pub type ADCINCH_R = crate :: FieldReader < u8 , ADCINCH_A > ; impl ADCINCH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCINCH_A { match self . bits { 0 => ADCINCH_A :: ADCINCH_0 , 1 => ADCINCH_A :: ADCINCH_1 , 2 => ADCINCH_A :: ADCINCH_2 , 3 => ADCINCH_A :: ADCINCH_3 , 4 => ADCINCH_A :: ADCINCH_4 , 5 => ADCINCH_A :: ADCINCH_5 , 6 => ADCINCH_A :: ADCINCH_6 , 7 => ADCINCH_A :: ADCINCH_7 , 8 => ADCINCH_A :: ADCINCH_8 , 9 => ADCINCH_A :: ADCINCH_9 , 10 => ADCINCH_A :: ADCINCH_10 , 11 => ADCINCH_A :: ADCINCH_11 , 12 => ADCINCH_A :: ADCINCH_12 , 13 => ADCINCH_A :: ADCINCH_13 , 14 => ADCINCH_A :: ADCINCH_14 , 15 => ADCINCH_A :: ADCINCH_15 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCINCH_0`"]
# [inline (always)]
pub fn is_adcinch_0 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_0 } # [doc = "Checks if the value of the field is `ADCINCH_1`"]
# [inline (always)]
pub fn is_adcinch_1 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_1 } # [doc = "Checks if the value of the field is `ADCINCH_2`"]
# [inline (always)]
pub fn is_adcinch_2 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_2 } # [doc = "Checks if the value of the field is `ADCINCH_3`"]
# [inline (always)]
pub fn is_adcinch_3 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_3 } # [doc = "Checks if the value of the field is `ADCINCH_4`"]
# [inline (always)]
pub fn is_adcinch_4 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_4 } # [doc = "Checks if the value of the field is `ADCINCH_5`"]
# [inline (always)]
pub fn is_adcinch_5 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_5 } # [doc = "Checks if the value of the field is `ADCINCH_6`"]
# [inline (always)]
pub fn is_adcinch_6 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_6 } # [doc = "Checks if the value of the field is `ADCINCH_7`"]
# [inline (always)]
pub fn is_adcinch_7 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_7 } # [doc = "Checks if the value of the field is `ADCINCH_8`"]
# [inline (always)]
pub fn is_adcinch_8 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_8 } # [doc = "Checks if the value of the field is `ADCINCH_9`"]
# [inline (always)]
pub fn is_adcinch_9 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_9 } # [doc = "Checks if the value of the field is `ADCINCH_10`"]
# [inline (always)]
pub fn is_adcinch_10 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_10 } # [doc = "Checks if the value of the field is `ADCINCH_11`"]
# [inline (always)]
pub fn is_adcinch_11 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_11 } # [doc = "Checks if the value of the field is `ADCINCH_12`"]
# [inline (always)]
pub fn is_adcinch_12 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_12 } # [doc = "Checks if the value of the field is `ADCINCH_13`"]
# [inline (always)]
pub fn is_adcinch_13 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_13 } # [doc = "Checks if the value of the field is `ADCINCH_14`"]
# [inline (always)]
pub fn is_adcinch_14 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_14 } # [doc = "Checks if the value of the field is `ADCINCH_15`"]
# [inline (always)]
pub fn is_adcinch_15 (& self) -> bool { * self == ADCINCH_A :: ADCINCH_15 } } # [doc = "Field `ADCINCH` writer - ADC Input Channel Select Bit 0"]
pub type ADCINCH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCMCTL0_SPEC , u8 , ADCINCH_A , 4 , O > ; impl < 'a , const O : u8 > ADCINCH_W < 'a , O > { # [doc = "ADC Input Channel 0"]
# [inline (always)]
pub fn adcinch_0 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_0) } # [doc = "ADC Input Channel 1"]
# [inline (always)]
pub fn adcinch_1 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_1) } # [doc = "ADC Input Channel 2"]
# [inline (always)]
pub fn adcinch_2 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_2) } # [doc = "ADC Input Channel 3"]
# [inline (always)]
pub fn adcinch_3 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_3) } # [doc = "ADC Input Channel 4"]
# [inline (always)]
pub fn adcinch_4 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_4) } # [doc = "ADC Input Channel 5"]
# [inline (always)]
pub fn adcinch_5 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_5) } # [doc = "ADC Input Channel 6"]
# [inline (always)]
pub fn adcinch_6 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_6) } # [doc = "ADC Input Channel 7"]
# [inline (always)]
pub fn adcinch_7 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_7) } # [doc = "ADC Input Channel 8"]
# [inline (always)]
pub fn adcinch_8 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_8) } # [doc = "ADC Input Channel 9"]
# [inline (always)]
pub fn adcinch_9 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_9) } # [doc = "ADC Input Channel 10"]
# [inline (always)]
pub fn adcinch_10 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_10) } # [doc = "ADC Input Channel 11"]
# [inline (always)]
pub fn adcinch_11 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_11) } # [doc = "ADC Input Channel 12"]
# [inline (always)]
pub fn adcinch_12 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_12) } # [doc = "ADC Input Channel 13"]
# [inline (always)]
pub fn adcinch_13 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_13) } # [doc = "ADC Input Channel 14"]
# [inline (always)]
pub fn adcinch_14 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_14) } # [doc = "ADC Input Channel 15"]
# [inline (always)]
pub fn adcinch_15 (self) -> & 'a mut W { self . variant (ADCINCH_A :: ADCINCH_15) } } # [doc = "ADC Select Reference Bit 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ADCSREF_A { # [doc = "0: ADC Select Reference 0"]
ADCSREF_0 = 0 , # [doc = "1: ADC Select Reference 1"]
ADCSREF_1 = 1 , # [doc = "2: ADC Select Reference 2"]
ADCSREF_2 = 2 , # [doc = "3: ADC Select Reference 3"]
ADCSREF_3 = 3 , # [doc = "4: ADC Select Reference 4"]
ADCSREF_4 = 4 , # [doc = "5: ADC Select Reference 5"]
ADCSREF_5 = 5 , # [doc = "6: ADC Select Reference 6"]
ADCSREF_6 = 6 , # [doc = "7: ADC Select Reference 7"]
ADCSREF_7 = 7 , } impl From < ADCSREF_A > for u8 { # [inline (always)]
fn from (variant : ADCSREF_A) -> Self { variant as _ } } # [doc = "Field `ADCSREF` reader - ADC Select Reference Bit 0"]
pub type ADCSREF_R = crate :: FieldReader < u8 , ADCSREF_A > ; impl ADCSREF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADCSREF_A { match self . bits { 0 => ADCSREF_A :: ADCSREF_0 , 1 => ADCSREF_A :: ADCSREF_1 , 2 => ADCSREF_A :: ADCSREF_2 , 3 => ADCSREF_A :: ADCSREF_3 , 4 => ADCSREF_A :: ADCSREF_4 , 5 => ADCSREF_A :: ADCSREF_5 , 6 => ADCSREF_A :: ADCSREF_6 , 7 => ADCSREF_A :: ADCSREF_7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ADCSREF_0`"]
# [inline (always)]
pub fn is_adcsref_0 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_0 } # [doc = "Checks if the value of the field is `ADCSREF_1`"]
# [inline (always)]
pub fn is_adcsref_1 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_1 } # [doc = "Checks if the value of the field is `ADCSREF_2`"]
# [inline (always)]
pub fn is_adcsref_2 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_2 } # [doc = "Checks if the value of the field is `ADCSREF_3`"]
# [inline (always)]
pub fn is_adcsref_3 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_3 } # [doc = "Checks if the value of the field is `ADCSREF_4`"]
# [inline (always)]
pub fn is_adcsref_4 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_4 } # [doc = "Checks if the value of the field is `ADCSREF_5`"]
# [inline (always)]
pub fn is_adcsref_5 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_5 } # [doc = "Checks if the value of the field is `ADCSREF_6`"]
# [inline (always)]
pub fn is_adcsref_6 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_6 } # [doc = "Checks if the value of the field is `ADCSREF_7`"]
# [inline (always)]
pub fn is_adcsref_7 (& self) -> bool { * self == ADCSREF_A :: ADCSREF_7 } } # [doc = "Field `ADCSREF` writer - ADC Select Reference Bit 0"]
pub type ADCSREF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , ADCMCTL0_SPEC , u8 , ADCSREF_A , 3 , O > ; impl < 'a , const O : u8 > ADCSREF_W < 'a , O > { # [doc = "ADC Select Reference 0"]
# [inline (always)]
pub fn adcsref_0 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_0) } # [doc = "ADC Select Reference 1"]
# [inline (always)]
pub fn adcsref_1 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_1) } # [doc = "ADC Select Reference 2"]
# [inline (always)]
pub fn adcsref_2 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_2) } # [doc = "ADC Select Reference 3"]
# [inline (always)]
pub fn adcsref_3 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_3) } # [doc = "ADC Select Reference 4"]
# [inline (always)]
pub fn adcsref_4 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_4) } # [doc = "ADC Select Reference 5"]
# [inline (always)]
pub fn adcsref_5 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_5) } # [doc = "ADC Select Reference 6"]
# [inline (always)]
pub fn adcsref_6 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_6) } # [doc = "ADC Select Reference 7"]
# [inline (always)]
pub fn adcsref_7 (self) -> & 'a mut W { self . variant (ADCSREF_A :: ADCSREF_7) } } impl R { # [doc = "Bits 0:3 - ADC Input Channel Select Bit 0"]
# [inline (always)]
pub fn adcinch (& self) -> ADCINCH_R { ADCINCH_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:6 - ADC Select Reference Bit 0"]
# [inline (always)]
pub fn adcsref (& self) -> ADCSREF_R { ADCSREF_R :: new (((self . bits >> 4) & 7) as u8) } } impl W { # [doc = "Bits 0:3 - ADC Input Channel Select Bit 0"]
# [inline (always)]
pub fn adcinch (& mut self) -> ADCINCH_W < 0 > { ADCINCH_W :: new (self) } # [doc = "Bits 4:6 - ADC Select Reference Bit 0"]
# [inline (always)]
pub fn adcsref (& mut self) -> ADCSREF_W < 4 > { ADCSREF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Memory Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmctl0](index.html) module"]
pub struct ADCMCTL0_SPEC ; impl crate :: RegisterSpec for ADCMCTL0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcmctl0::R](R) reader structure"]
impl crate :: Readable for ADCMCTL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcmctl0::W](W) writer structure"]
impl crate :: Writable for ADCMCTL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCMCTL0 to value 0"]
impl crate :: Resettable for ADCMCTL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCMEM0 register accessor: an alias for `Reg<ADCMEM0_SPEC>`"]
pub type ADCMEM0 = crate :: Reg < adcmem0 :: ADCMEM0_SPEC > ; # [doc = "ADC Conversion Memory 0"]
pub mod adcmem0 { # [doc = "Register `ADCMEM0` reader"]
pub struct R (crate :: R < ADCMEM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCMEM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCMEM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCMEM0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCMEM0` writer"]
pub struct W (crate :: W < ADCMEM0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCMEM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCMEM0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCMEM0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Conversion Memory 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcmem0](index.html) module"]
pub struct ADCMEM0_SPEC ; impl crate :: RegisterSpec for ADCMEM0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcmem0::R](R) reader structure"]
impl crate :: Readable for ADCMEM0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcmem0::W](W) writer structure"]
impl crate :: Writable for ADCMEM0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCMEM0 to value 0"]
impl crate :: Resettable for ADCMEM0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCIE register accessor: an alias for `Reg<ADCIE_SPEC>`"]
pub type ADCIE = crate :: Reg < adcie :: ADCIE_SPEC > ; # [doc = "ADC Interrupt Enable"]
pub mod adcie { # [doc = "Register `ADCIE` reader"]
pub struct R (crate :: R < ADCIE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCIE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCIE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCIE_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCIE` writer"]
pub struct W (crate :: W < ADCIE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCIE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCIE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCIE_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCIE0` reader - ADC Interrupt enable"]
pub type ADCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `ADCIE0` writer - ADC Interrupt enable"]
pub type ADCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; # [doc = "Field `ADCINIE` reader - ADC Interrupt enable for the inside of window of the Window comparator"]
pub type ADCINIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADCINIE` writer - ADC Interrupt enable for the inside of window of the Window comparator"]
pub type ADCINIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; # [doc = "Field `ADCLOIE` reader - ADC Interrupt enable for lower threshold of the Window comparator"]
pub type ADCLOIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADCLOIE` writer - ADC Interrupt enable for lower threshold of the Window comparator"]
pub type ADCLOIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; # [doc = "Field `ADCHIIE` reader - ADC Interrupt enable for upper threshold of the Window comparator"]
pub type ADCHIIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADCHIIE` writer - ADC Interrupt enable for upper threshold of the Window comparator"]
pub type ADCHIIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; # [doc = "Field `ADCOVIE` reader - ADC ADCMEM overflow Interrupt enable"]
pub type ADCOVIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADCOVIE` writer - ADC ADCMEM overflow Interrupt enable"]
pub type ADCOVIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; # [doc = "Field `ADCTOVIE` reader - ADC conversion-time-overflow Interrupt enable"]
pub type ADCTOVIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADCTOVIE` writer - ADC conversion-time-overflow Interrupt enable"]
pub type ADCTOVIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ADC Interrupt enable"]
# [inline (always)]
pub fn adcie0 (& self) -> ADCIE0_R { ADCIE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Interrupt enable for the inside of window of the Window comparator"]
# [inline (always)]
pub fn adcinie (& self) -> ADCINIE_R { ADCINIE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - ADC Interrupt enable for lower threshold of the Window comparator"]
# [inline (always)]
pub fn adcloie (& self) -> ADCLOIE_R { ADCLOIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - ADC Interrupt enable for upper threshold of the Window comparator"]
# [inline (always)]
pub fn adchiie (& self) -> ADCHIIE_R { ADCHIIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ADC ADCMEM overflow Interrupt enable"]
# [inline (always)]
pub fn adcovie (& self) -> ADCOVIE_R { ADCOVIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - ADC conversion-time-overflow Interrupt enable"]
# [inline (always)]
pub fn adctovie (& self) -> ADCTOVIE_R { ADCTOVIE_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC Interrupt enable"]
# [inline (always)]
pub fn adcie0 (& mut self) -> ADCIE0_W < 0 > { ADCIE0_W :: new (self) } # [doc = "Bit 1 - ADC Interrupt enable for the inside of window of the Window comparator"]
# [inline (always)]
pub fn adcinie (& mut self) -> ADCINIE_W < 1 > { ADCINIE_W :: new (self) } # [doc = "Bit 2 - ADC Interrupt enable for lower threshold of the Window comparator"]
# [inline (always)]
pub fn adcloie (& mut self) -> ADCLOIE_W < 2 > { ADCLOIE_W :: new (self) } # [doc = "Bit 3 - ADC Interrupt enable for upper threshold of the Window comparator"]
# [inline (always)]
pub fn adchiie (& mut self) -> ADCHIIE_W < 3 > { ADCHIIE_W :: new (self) } # [doc = "Bit 4 - ADC ADCMEM overflow Interrupt enable"]
# [inline (always)]
pub fn adcovie (& mut self) -> ADCOVIE_W < 4 > { ADCOVIE_W :: new (self) } # [doc = "Bit 5 - ADC conversion-time-overflow Interrupt enable"]
# [inline (always)]
pub fn adctovie (& mut self) -> ADCTOVIE_W < 5 > { ADCTOVIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcie](index.html) module"]
pub struct ADCIE_SPEC ; impl crate :: RegisterSpec for ADCIE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcie::R](R) reader structure"]
impl crate :: Readable for ADCIE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcie::W](W) writer structure"]
impl crate :: Writable for ADCIE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCIE to value 0"]
impl crate :: Resettable for ADCIE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCIFG register accessor: an alias for `Reg<ADCIFG_SPEC>`"]
pub type ADCIFG = crate :: Reg < adcifg :: ADCIFG_SPEC > ; # [doc = "ADC Interrupt Flag"]
pub mod adcifg { # [doc = "Register `ADCIFG` reader"]
pub struct R (crate :: R < ADCIFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCIFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCIFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCIFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCIFG` writer"]
pub struct W (crate :: W < ADCIFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCIFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCIFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCIFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADCIFG0` reader - ADC Interrupt Flag"]
pub type ADCIFG0_R = crate :: BitReader < bool > ; # [doc = "Field `ADCIFG0` writer - ADC Interrupt Flag"]
pub type ADCIFG0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; # [doc = "Field `ADCINIFG` reader - ADC Interrupt Flag for the inside of window of the Window comparator"]
pub type ADCINIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ADCINIFG` writer - ADC Interrupt Flag for the inside of window of the Window comparator"]
pub type ADCINIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; # [doc = "Field `ADCLOIFG` reader - ADC Interrupt Flag for lower threshold of the Window comparator"]
pub type ADCLOIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ADCLOIFG` writer - ADC Interrupt Flag for lower threshold of the Window comparator"]
pub type ADCLOIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; # [doc = "Field `ADCHIIFG` reader - ADC Interrupt Flag for upper threshold of the Window comparator"]
pub type ADCHIIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ADCHIIFG` writer - ADC Interrupt Flag for upper threshold of the Window comparator"]
pub type ADCHIIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; # [doc = "Field `ADCOVIFG` reader - ADC ADCMEM overflow Interrupt Flag"]
pub type ADCOVIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ADCOVIFG` writer - ADC ADCMEM overflow Interrupt Flag"]
pub type ADCOVIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; # [doc = "Field `ADCTOVIFG` reader - ADC conversion-time-overflow Interrupt Flag"]
pub type ADCTOVIFG_R = crate :: BitReader < bool > ; # [doc = "Field `ADCTOVIFG` writer - ADC conversion-time-overflow Interrupt Flag"]
pub type ADCTOVIFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u16 , ADCIFG_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ADC Interrupt Flag"]
# [inline (always)]
pub fn adcifg0 (& self) -> ADCIFG0_R { ADCIFG0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Interrupt Flag for the inside of window of the Window comparator"]
# [inline (always)]
pub fn adcinifg (& self) -> ADCINIFG_R { ADCINIFG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - ADC Interrupt Flag for lower threshold of the Window comparator"]
# [inline (always)]
pub fn adcloifg (& self) -> ADCLOIFG_R { ADCLOIFG_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - ADC Interrupt Flag for upper threshold of the Window comparator"]
# [inline (always)]
pub fn adchiifg (& self) -> ADCHIIFG_R { ADCHIIFG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ADC ADCMEM overflow Interrupt Flag"]
# [inline (always)]
pub fn adcovifg (& self) -> ADCOVIFG_R { ADCOVIFG_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - ADC conversion-time-overflow Interrupt Flag"]
# [inline (always)]
pub fn adctovifg (& self) -> ADCTOVIFG_R { ADCTOVIFG_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC Interrupt Flag"]
# [inline (always)]
pub fn adcifg0 (& mut self) -> ADCIFG0_W < 0 > { ADCIFG0_W :: new (self) } # [doc = "Bit 1 - ADC Interrupt Flag for the inside of window of the Window comparator"]
# [inline (always)]
pub fn adcinifg (& mut self) -> ADCINIFG_W < 1 > { ADCINIFG_W :: new (self) } # [doc = "Bit 2 - ADC Interrupt Flag for lower threshold of the Window comparator"]
# [inline (always)]
pub fn adcloifg (& mut self) -> ADCLOIFG_W < 2 > { ADCLOIFG_W :: new (self) } # [doc = "Bit 3 - ADC Interrupt Flag for upper threshold of the Window comparator"]
# [inline (always)]
pub fn adchiifg (& mut self) -> ADCHIIFG_W < 3 > { ADCHIIFG_W :: new (self) } # [doc = "Bit 4 - ADC ADCMEM overflow Interrupt Flag"]
# [inline (always)]
pub fn adcovifg (& mut self) -> ADCOVIFG_W < 4 > { ADCOVIFG_W :: new (self) } # [doc = "Bit 5 - ADC conversion-time-overflow Interrupt Flag"]
# [inline (always)]
pub fn adctovifg (& mut self) -> ADCTOVIFG_W < 5 > { ADCTOVIFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcifg](index.html) module"]
pub struct ADCIFG_SPEC ; impl crate :: RegisterSpec for ADCIFG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adcifg::R](R) reader structure"]
impl crate :: Readable for ADCIFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcifg::W](W) writer structure"]
impl crate :: Writable for ADCIFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCIFG to value 0"]
impl crate :: Resettable for ADCIFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADCIV register accessor: an alias for `Reg<ADCIV_SPEC>`"]
pub type ADCIV = crate :: Reg < adciv :: ADCIV_SPEC > ; # [doc = "ADC Interrupt Vector Word"]
pub mod adciv { # [doc = "Register `ADCIV` reader"]
pub struct R (crate :: R < ADCIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCIV` writer"]
pub struct W (crate :: W < ADCIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCIV_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Interrupt Vector Word\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adciv](index.html) module"]
pub struct ADCIV_SPEC ; impl crate :: RegisterSpec for ADCIV_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adciv::R](R) reader structure"]
impl crate :: Readable for ADCIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adciv::W](W) writer structure"]
impl crate :: Writable for ADCIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADCIV to value 0"]
impl crate :: Resettable for ADCIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "PORT_1_2"]
pub PORT_1_2 : PORT_1_2 , # [doc = "PORT_3"]
pub PORT_3 : PORT_3 , # [doc = "USCI_A0_UART_MODE"]
pub USCI_A0_UART_MODE : USCI_A0_UART_MODE , # [doc = "USCI_A0_SPI_MODE"]
pub USCI_A0_SPI_MODE : USCI_A0_SPI_MODE , # [doc = "USCI_A1_UART_MODE"]
pub USCI_A1_UART_MODE : USCI_A1_UART_MODE , # [doc = "USCI_A1_SPI_MODE"]
pub USCI_A1_SPI_MODE : USCI_A1_SPI_MODE , # [doc = "USCI_B0_I2C_MODE"]
pub USCI_B0_I2C_MODE : USCI_B0_I2C_MODE , # [doc = "USCI_B0_SPI_MODE"]
pub USCI_B0_SPI_MODE : USCI_B0_SPI_MODE , # [doc = "SFR"]
pub SFR : SFR , # [doc = "PMM"]
pub PMM : PMM , # [doc = "SYS"]
pub SYS : SYS , # [doc = "CS"]
pub CS : CS , # [doc = "FRAM"]
pub FRAM : FRAM , # [doc = "CRC16"]
pub CRC16 : CRC16 , # [doc = "WATCHDOG_TIMER"]
pub WATCHDOG_TIMER : WATCHDOG_TIMER , # [doc = "REAL_TIME_CLOCK"]
pub REAL_TIME_CLOCK : REAL_TIME_CLOCK , # [doc = "TIMER_0_A3"]
pub TIMER_0_A3 : TIMER_0_A3 , # [doc = "TIMER_1_A3"]
pub TIMER_1_A3 : TIMER_1_A3 , # [doc = "TIMER_2_A2"]
pub TIMER_2_A2 : TIMER_2_A2 , # [doc = "TIMER_3_A2"]
pub TIMER_3_A2 : TIMER_3_A2 , # [doc = "MPY_16"]
pub MPY_16 : MPY_16 , # [doc = "MPY_32"]
pub MPY_32 : MPY_32 , # [doc = "BACKUP_MEMORY"]
pub BACKUP_MEMORY : BACKUP_MEMORY , # [doc = "ADC"]
pub ADC : ADC , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"]
# [inline]
pub fn take () -> Option < Self > { msp430 :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { PORT_1_2 : PORT_1_2 { _marker : PhantomData } , PORT_3 : PORT_3 { _marker : PhantomData } , USCI_A0_UART_MODE : USCI_A0_UART_MODE { _marker : PhantomData } , USCI_A0_SPI_MODE : USCI_A0_SPI_MODE { _marker : PhantomData } , USCI_A1_UART_MODE : USCI_A1_UART_MODE { _marker : PhantomData } , USCI_A1_SPI_MODE : USCI_A1_SPI_MODE { _marker : PhantomData } , USCI_B0_I2C_MODE : USCI_B0_I2C_MODE { _marker : PhantomData } , USCI_B0_SPI_MODE : USCI_B0_SPI_MODE { _marker : PhantomData } , SFR : SFR { _marker : PhantomData } , PMM : PMM { _marker : PhantomData } , SYS : SYS { _marker : PhantomData } , CS : CS { _marker : PhantomData } , FRAM : FRAM { _marker : PhantomData } , CRC16 : CRC16 { _marker : PhantomData } , WATCHDOG_TIMER : WATCHDOG_TIMER { _marker : PhantomData } , REAL_TIME_CLOCK : REAL_TIME_CLOCK { _marker : PhantomData } , TIMER_0_A3 : TIMER_0_A3 { _marker : PhantomData } , TIMER_1_A3 : TIMER_1_A3 { _marker : PhantomData } , TIMER_2_A2 : TIMER_2_A2 { _marker : PhantomData } , TIMER_3_A2 : TIMER_3_A2 { _marker : PhantomData } , MPY_16 : MPY_16 { _marker : PhantomData } , MPY_32 : MPY_32 { _marker : PhantomData } , BACKUP_MEMORY : BACKUP_MEMORY { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , } } }